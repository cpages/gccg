#
#    Gccg - Generic collectible card game.
#    Copyright (C) 2001-2013 Tommi Ronkainen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program, in the file license.txt. If not, write
# to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
#############################################################################
#
#                    Function definitions for client
#
##############################################################################
#
# Constants:
#
# BOOK_ROWS - number of rows at card book
# BOOK_COLUMNS - number of columns at card book
# DECKBOX_SIZE - size of the columns of the deck listing.
# DELETE_TO_MINE - if set, Delete key will put to my own discard instead of owner.
# GAME - title of the game
# GAMEDIR - name of the directory of the game
# HELP{mode}{command} - (parameters,short description, users allowed or NULL if not restricted, long description)
# HIGHLIGHT_COLOR - color to use for highlighting touched objects
# IMAGE_FORMAT - default file extension expected by image files (including the dot)
# IMMOBILE_CARDS - list of card numbers not allowed to move with TryTransferTo()
# MENU{context} - menu entries for the given context
# MAX_MESSAGE - maximum length of the message line in pixels
# MAX_PLAYERS - maximum number of simultaneous players
# STRING_KEEP_TAPPED - keep-tapped flag text
# TABLES_X - number of tables in x-direction
# TABLES_Y - number of tables in y-direction
#
# Colors:
#
# COLORS{colorname} - preset colors for RED, ORANGE, YELLOW, GREEN, BLUE, VIOLET, WHITE, BLACK
# BGCOLOR - generic background color
# FGCOLOR - generic foreground color
# BRCOLOR - generic border color
# BGCOLOR2 - play mode background color
# FGCOLOR2 - play mode foreground color
# BRCOLOR2 - play mode border color
# TXCOLOR - generic text color
# INCOLOR - input text color
# BKBGCOLOR - collection background color
# BKBRCOLOR - collection border color
# BKTXCOLOR - collection text color
# TABLE_SHADOW - if set, add {shadow} to table texts
#
# Variables:
#
# active - list of active set objects
# avatar{user name} - mapping from user names to last non-sleep avatars set
# avatar.image{avatar name} - image number of avatar
# avatar.name{player} - name of the avatar assigned to the player
# avatar.object{player} - object numbers of avatars
# away{username} - away status: old avatar name if away, NULL otherwise
# background.image - image number of the chat mode background
# background.object - object number of the chat mode background
# bind_next - if not null, next key press will bind contents of bind_next to the key
# bindk_next - if not null, next key press will bind contents of bindk_next to the key
# bind{key function} - line that overrides normal function of the pressed key
# bindk{key function} - string that overrides normal function of the pressed key
# book.cache - storage for the latest book state
# book.current_index - current filter/sort pair
# book.history - list of earlier filterings (newest is first)
# book.filter_version - a pair (filter code version, number of cards) used to create indices
# book.filter{filter expression} - precalculated filtered card lists
# book.index{(filter expression,sorting expression)} - precalculated book indices
# book_refresh - dictionary mapping card numbers to NULL or 1 if they are refreshed from server.
# books - list of object numbers used for card books
# booster - current real content of booster
# booster.box - box to display a booster/starter bought
# booster.open_at_once - 1 if booster should be opened immediately
# booster.manual_buy - 1 if booster was bought using /buy command
# booster.visible - current visible content of booster
# card.book - object number of my collection
# card.group{category}{group} - group data of the cards on table (see. location algorithm)
# card.width,card.height - pysical size of the cards
# card.design.width,card.design.height - size of the cards in design resolution
# card.book.width,card.book.height - size of the cards in the collection
# card.hand.width,card.hand.height - size of the cards in the hand
# card.deck.width,card.deck.height - size of the cards in the deck
# card.xstep,card.ystep - recommend space between cards during game
# cardmap{import/export}{format}{card} - Card import/export mapping from and to Gccg.
# con - connection number causing event
# deck - my playdeck object number
# deck.box - object number of deck editing list
# deck.groups{groupname} - contains decknames in each category
# decks{deckname}{part} - decks available (each part, i.e. "deck","sideboard", etc. contains list of card numbers)
# deck.name - name of the currently selected deck or NULL if not selected
# deck.objects[player]{name} - object numbers of the decks
# deck.class{object number} - map object number to general deck class
# deck.part - part of the deck under editing
# deck_content{object.number} - known content of the deck during play if any
# design.width,design.height - screen game design resolution
# discard - my discard deck object number
# drag.box - object number for draggable card object
# dragging - 1 while left dragging an object
# dragging.highlight - old state of highlighting when dragging started
# findspace.category - primary category of the card during location algorithm
# findspace.facedown - face down status set for last FindSpace request
# findspace.group - group of the card during location algorithm
# findspace.orientation - orientation set for last FindSpace request
# flag.logging - set when the logging is on
# flag.playing - set when the game is going
# function{name} - function callback table containing valid network events
# game.bindings - game specific bindings, if none given by the user
# game.data - structure holding generic game information (see. game_data())
# hand[player] - hand object numbers
# history - history of old inputs (newest is first)
# history.pos - current position in history or -1 if none
# table.image - image number for table
# info.box - box for displaying zoomed cardimages
# info.current - current card displayed in the infozoom, NULL if none
# input - current content of the input.box
# input.box - chat box at the bottom of the screen
# logs{log name} - collection of logs
# log.name - name of the current log
# menu - NULL if menu not shown, otherwise object number
# menu.object - object number to use for menu
# mode - "chat","shop","watch","play" current screen
# mode_object{mode} - mode specific objects to hide when changing mode
# modifier - list of modifier keys (Ctrl, Alt, Shift) being pressed
# money - current amount of money
# money.box - object number to show money
# me - my player number
# msg.box - message box at the top of the screen
# obj  - next free object number
# options{option} - client side options
#   email (server option) - Your email
#   nosound - Disable beep
#   noalert - Disable visual alert
#   log - Copy messages to the stdout if 'yes'
#   plan (server option) - Additional whois data
#   realname (server option) - Your name
#   trade_limit - how many cards i need before trading
# options.game{option} - client side options during a game (reseted at the start of the game)
#   "PutTableHook" - "on"/"off" enable/disable PutTableHook (default: on)
# options.debug - show debugging info
# options.export_set - If set, export set name always.
# panel_objects{panel name} - list of objects belonging to the panel.
# panel_options{panel name} - options for panel construction
# panel_structure{panel name} - construction info for the panel
# password{user name} - passwords
# players - number of players
# player.name{player number} - list of players during play
# player.icon{player number} - object number for player icon
# player.marker_color - currently selected marker color
# playmat.image - image number of the play mode background
# playmat.object - object number of the play mode background
# pm_name - name of current PM recipient
# port - server port
# price.default{rarity} - default prices for different rarities
# products{product name} - list of products
#   0 amount available
#   1 price
#   2 order code for factory server
# products.box - object number of products panel
# product.images{product name} - image number of the product picture
# product.objects{product name} - object numbers of products
# rarity.display{letter} - format code to apply when opening card of that rarity from pack
# room.players - players in chat room (see meta-server)
# room.tables - tables in chat room (see meta-server)
# rules.category - list of pairs (condition,category), which is used to map a name to category
# rules.coordinate - category to coordinate mapping (see. Mtg.include)
# score[player] - current score text for each player
# score.raw[player] - raw score structure for each players
# score.object[player] - scoreboard object numbers
# screen - name of the current screen
# screen.width,screen.height - screen physical resolution
# screen.has_focus - screen has input focus (0 or 1)
# screen.alert_enabled - visual notification is enabled (0 or 1)
# screen_panels{screen name} - list of panel names belonging to the screen
# search.box - object number of deck search box
# search.source - object number of the current source of search box content
# select.box - object for choosing a card
# select.expression - expression to evaluate for next selection
# select.source - card source for select box or NULL if none
# server - connection number for current game or meta server
# server.meta - connection number for meta server
# server.name - name of the game server set by --server or default
# server.name_backup - list of backup servers or NULL
# server.name_default - name of the default game server
# tab.type - type of tab completion to use ("player" or "command")
# tab.last_item - latest item name shown in tab completion
# tab.last_initial - latest initial part entered before pressing tab
# table.width,table.height - width of the playarea (screen size for <= 2-player)
# table.object[x][y] - object numbers for table images
# table.number[x][y] - connection numbers for table images or NULL if unused
# targeting_queue - list of cards waiting for targets; entries are (card number,)
# timer - list of timing event pairs (seconds,command) where is command is executed after seconds <= 0
# timer_minute - list of timing event pairs (trigger time,command) for minute based resolution
# transfer.options - special options to send by TryTransferTo()
# unbind_next - if not null, next key press will be unbound
# undo_buffer - list of (ID, qty, from_part, to_part) pairs reflecting recent changes to deck contents
# undo.pos - current position in undo_buffer when rewinding/forwarding
# username - name of the player
#
# Functions:
#
# See reference manual.

#
# CONSTANTS
# =========

# Z-levels (for deciding which objects should be placed on top of others)
Z_LOBBYCHAT = 1000;
Z_MENU = 100;
Z_SCORE = 99;
Z_ZOOM = 95;
Z_BOOSTER = 90;
Z_PRODUCTMENU = 80;
Z_DLIST = 70;
Z_COLLECTION = 70;
Z_ALERT = 60;
Z_SETASIDE = 40;
Z_HAND = 30;
Z_MBOX = 20;
Z_DECKS = 10;

# Version number of filtering algorithm.
BOOK_FILTER_VERSION="0.11";

# Mininum binary version required to use this script.
MINIMUM_VERSION="0.9.0";

# How many cards in a row at collection
BOOK_ROWS=3;

# How many cards in a column at collection
BOOK_COLUMNS=5;

# Default file extension expected by image files
IMAGE_FORMAT=".jpg";

# Maximum number of simultaneous players.
MAX_PLAYERS=8;

# Maximum number of characters in one message line in pixels.
MAX_MESSAGE=screen.width-10;

# 1: delete key always moves card to my own discard pile
# 0: delete key moves card to discard pile of its controller
DELETE_TO_MINE=0;

# How much we must move a card before removing it from the
# organizational group, when deciding card postions.
CLEAR_GROUP_DISTANCE=10;

# What to display on "keep tapped" cards.
STRING_KEEP_TAPPED="T";
# What to display on "keep untapped" cards.
STRING_KEEP_UNTAPPED="UNT";

# Game specific menu definitions.
GAME_MENU=(,);
# Extra menu entries provided by extension scripts.
EXTRA_MENU=(,);

# Default export format.
DEFAULT_EXPORT_FORMAT="Gccg";

# Color to use for highlighting touched objects.
HIGHLIGHT_COLOR=(150,0,0);

# Named colors
COLORS=(,);
COLORS{'RED'}=(250,0,0);
COLORS{'ORANGE'}=(250,130,30);
COLORS{'YELLOW'}=(220,220,0);
COLORS{'GREEN'}=(0,180,0);
COLORS{'BLUE'}=(20,20,250);
COLORS{'VIOLET'}=(160,0,160);
COLORS{'WHITE'}=(255,255,255);
COLORS{'BLACK'}=(0,0,0);

# Marker colors
MARKER_COLOR=array(10);

MARKER_COLOR[0]="Red";
MARKER_COLOR[1]="Green";
MARKER_COLOR[2]="Blue";
MARKER_COLOR[3]="Orange";
MARKER_COLOR[4]="Yellow";
MARKER_COLOR[5]="Black";
MARKER_COLOR[6]="White";
MARKER_COLOR[7]="Default";
DEFAULT_MARKER_COLOR=7;

# Default book order.
BOOK_DEFAULT_SORT=("[age]","[name]");

# Mapping from filter function names to a pair (type,short help text).
FILTER_FUNCTIONS=(,);

# Mapping from attribute types to data types:
# if GAME_ATTRIBUTES{attr}=="i", treat as int type
# if "r", treat as real type
# "s" is default, for string type, and in fact string attributes need not be listed
# It's also possible for this to contain "a:OtherAttr", in which case "attr" is treated as an alias for "OtherAttr".
GAME_ATTRIBUTES=(,);

# Common (server-side) basic table size (independent of the display size)
BASE_TABLE_WIDTH=1024;
BASE_TABLE_HEIGHT=768;

# Which load/save functions should be called? (for compatibility)
if(isfunction("binary_load"))
  LOAD_FN="binary_load";
else
  LOAD_FN="load";
if(isfunction("binary_save"))
  SAVE_FN="binary_save";
else
  SAVE_FN="save";

# Standard menu definitions
MENU=(,);
MENU{"Main Menu - "}=((1,"Quit","Ctrl+Q","quit()"),);
MENU{"Main Menu - Offline"}=(
	(1,"Show/Hide Collection","Ctrl+B",""),
	('deck.name!=NULL',"Edit/Hide deck","Ctrl+E",""),
	('length(decks)>0',"Select deck","Ctrl+D",""),
	(1,"Import deck","Ctrl+I",""),
    (1,"Quit","/quit",""),
    );
MENU{"Main Menu - Watch"}=(
	(1,"Show/Hide Collection","Ctrl+B",""),
	('deck.name!=NULL',"Edit/Hide deck","Ctrl+E",""),
	('length(decks)>0',"Select deck","Ctrl+D",""),
	(1,"Import deck","Ctrl+I",""),
    (1,"Leave","/quit",""),
    );
MENU{"Main Menu - Chat"}=(
	(1,"Unbind a key binding","/unbind",""),
	(1,"List key bindings","/bind",""),
	(1,"{hr}","",""),
	(1,"Show/Hide Collection","Ctrl+B",""),
	(1,"Show/Hide Products","Ctrl+P",""),
	(1,"Create new deck","","CreateEmptyDeck()"),
	('deck.name!=NULL',"Edit/Hide deck","Ctrl+E",""),
	(1,"Import deck","Ctrl+I",""),
	('length(decks)>0',"Select deck","Ctrl+D",""),
	(1,"Register full set...","","RegisterSubmenu()"),
	(1,"Register full playset...","","RegisterPlaysetSubmenu()"),
	(1,"{hr}","",""),
	(1,"Show players online","/who",""),
	("length(room.tables)>0","Describe tables","/tables",""),
    (1,"Quit","/quit",""),
    );

MENU{"Main Menu - Play"}=(
	(1,"Unbind a key binding","/unbind",""),
	(1,"{hr}","",""),
	(1,"Untap all","Ctrl+U",""),
	(1,"End of my turn","Ctrl+E",""),
	(1,"Roll dice","Ctrl+R",""),
	(1,"Flip a coin","Ctrl+C",""),
	(1,"Select counter color...","","CounterSubmenu()"),
	(1,"{hr}","",""),
	(1,"Declare win","/win",""),
	(1,"Declare loss","/lose",""),
	(1,"Declare draw","/draw",""),
	(1,"Declare undecided","/undecided",""),
	(1,"Accept result","/ok",""),
	(1,"{hr}","",""),
	(1,"Show/Hide deck","","set_attr(deck.box,'visible',!get_attr(deck.box,'visible'))"),
	(1,"Show/Hide collection","Ctrl+B",""),
	(1,"Save game","/savegame",""),
	(1,"Load game","/loadgame",""),
	(1,"Delete saved game","/delgame",""),
	);

MENU{"Table"}=(
    (1,"Sit down","left click",""),
    (1,"Play or watch","middle click",""),
    (1, "Leave table","/leavetable",""),
    );

MENU{"Open Booster"}=(
     (1,"Reveal one card","left click",""),
     (1,"Reveal all cards","middle click",""),
     (1,"{hr}","",""),
     ('card_back(card.number)!=card.number',"Show card text w/ errata","Ctrl+H",""),
     ('card_back(card.number)!=card.number',"Find from collection",'EVAL:"/find "+canonical_name(card.number)',""),
     (1,"{hr}","",""),
     (1,"Close","Esc",'del_cardbox_all_recenter(booster.box)'),
    );

MENU{"Hand"}=(
	 (1,"Reveal/Hide hand","Ctrl+F",""),
	 (1,"Shuffle hand","Ctrl+S",""),
	 (1,"Shuffle to the deck","",'Send("Transfer",(length(hand(hand[me])),("hand",me,0),("deck.top",deck))); Send("ShuffleDeck",deck);'),
     (1,"Touch","Ctrl+T",""),
     (1,"{hr}","",""),
     (1,"Big size","","SetHandSize(150)"),
     (1,"Normal size","","SetHandSize(100)"),
     (1,"Small size","","SetHandSize(66)"),
     (1,"Normal layout","","set_attr(object.number,'compact',0)"),
     (1,"Wide layout","","set_attr(object.number,'compact',1)"),
    );

MENU{"Card Select Box"}=(
     (1,"Close","Escape",""),
    );

MENU{"Products"}=(
     (1,"Close","Escape",""),
    );

# Initialize help.
HELP=(,);
HELP{""}=(,);
HELP{"any"}=(,);
HELP{"play"}=(,);
HELP{"chat"}=(,);
HELP{"watch"}=(,);
HELP{"offline"}=(,);

# Help texts from serverside commands.
HELP{"chat"}{"addproduct"}=("n,id,t,prc","add product",("God","Salesman"),
"This command adds one product for sale. The ordering code of the product is '{yellow}id{white} {yellow}t{white}', where {yellow}id{white} is the abbreviation of the card set and {yellow}t{white} is the type of the product ('booster', 'starter', etc.). The ordering code is a string which describes the product for the factory server. Number of the sale items available is {yellow}n{white} and the price of them is {yellow}prc{white} apiece.");
HELP{"chat"}{"ban"}=("player","ban a player",("God","Guard"),
"Without any arguments, this command lists all banned users. Adding one or more player nicks as arguments, this commands adds them to the ban list. When a player is banned, he cannot login in to the game anymore. Additionally, if the banned player is online when this command is issued, he is kicked automatically from the server. See also {orange}/help restrict{white} and {orange}/help unban{white}.");
HELP{"chat"}{"bans"}=("","list bans",NULL,
"This command lists all banned users and restricted domains.");
HELP{"play"}{"bid"}=("bid","place a bid",NULL,
"Simple auction system works as follows: each player places their bids using this command. The bid can be any text. When each player has placed their bids, the auction results are displayed and book-keeping for bidding is reseted to be ready for next bidding.");
HELP{"chat"}{"canceldraft"}=("","cancel a draft",NULL,
"If you've reserved a draft and want to take it back, this command will free up the table to be reclaimed. Privileged users can also use this command with a numeric argument to reclaim a draft tbale with the given number, no matter who reserved it.");
HELP{"chat"}{"delproduct"}=("id,t","delete product",("God","Salesman"),
"This command removes one product. The ordering code {yellow}id t{white} is the same as in {yellow}/addproduct{white}.");
HELP{"chat"}{"have"}=("player","show player's have list",NULL,
"Asks the meta server for the have list of the given {yellow}player{white}. The have list contains all cards which you have marked as wanted and which are put for sale by the {yellow}player{white}.");
HELP{"chat"}{"grant"}=("player1,player2","copy password",NULL,
"If the {yellow}player2{white} is online, copy the password of {yellow}player1{white} to the {yellow}player2{white}. Every player can grant his or her password to anybody, but only God can grant others' passwords. After the password is copied, the {yellow}player2{white} who received the password, can log in as {yellow}player1{white}.");
HELP{"chat"}{"products"}=("","show products available",NULL,
"List the quantity and the price of each product for sale.");
HELP{"chat"}{"reboot"}=("","reboot the server",("God",),
"Send Quit-message to all players and game servers. After that, reboot the meta server.");
HELP{"chat"}{"register"}=("set","register complete set",NULL,
"If the player has collected all cards of the {yellow}set{white}, he or she is awarded by a bonus. The bonus is $0.50 per individual card in the set. If the player has not yet collected all cards, the number of missing cards is announced. The {yellow}set{white} must be given as an abbreviation of the card set (case insensitive). If the abbreviation is not valid, the list of valid abbreviations are shown.");
HELP{"chat"}{"registerplayset"}=("set","register playset",NULL,
"If the player has already registered the {yellow}set{white}, and has collected a full playset of each card in the set, he or she is awarded by a bonus.  The bonus is $2 per distinct card in the set. If the player has not yet collected all cards, the number of missing cards is announced. The {yellow}set{white} must be given as an abbreviation of the card set (case insensitive). If the abbreviation is not valid, the list of valid abbreviations are shown.");
HELP{"chat"}{"removeuser"}=("player","delete user",("God",),
"This command deletes all data of {yellow}player{white}.");
HELP{"chat"}{"reproduce"}=("","add products",("God","Salesman"),
"Check all products. If there is a sold out product, then add a shipment of product with halved availability (compared to the previous shipment) and price increased by 10%.");
HELP{"chat"}{"restrict"}=("domain","restric access",("God","Guard"),
"Without any arguments, this command lists all restrictions currently in effect. Domain name can be exact or it can contain * as a joker character, for example *.cheaters.com. When the restriction is added to the domain, all existing players can connect but new players are not accepted any more. They get a message explaining the situation and how to get an account by email from the server administrator. See also {orange}/help ban{white} and {orange}/help unrestrict{white}.");
HELP{"chat"}{"ro"}=("","restore original deck",NULL,
"You can retrieve the original composition of the registered deck with this command. Be careful when using this command, since it overwrites your current deck with the content of the registered deck. See also {orange}/help rd{white}.");
HELP{"chat"}{"ro2"}=("","restore alternative original deck",NULL,
"You can retrieve the original composition of the alternative registered deck with this command. Be careful when using this command, since it overwrites your current deck with the content of the alternative registered deck. See also {orange}/help rd2{white}.");
HELP{"chat"}{"startdraft"}=("n,setcodes","start a draft",NULL,
"If there is an open draft table available, reserve a draft for {yellow}n{white} players using the chosen products; the server will automatically determine the price to enter the draft based on those products. Set codes can be separated by spaces, commas, hyphens, or slashes. If only one set code is given, it defaults to 3 copies of that set.");
HELP{"chat"}{"users"}=("pattern","list of users",NULL,
"Show list of all users matching wildcard {yellow}pattern{white} or all users if not given. The total number of users matching is shown instead if the list is too long.");
HELP{"chat"}{"want"}=("player","show player's want list",NULL,
"Asks the meta server for the want list of the given {yellow}player{white}. The have list contains all cards which he or she have marked as wanted. The cards you have for sale or you have more than {yellow}trade_limit{white}, are shown in green.");
HELP{"chat"}{"whisper"}=("player, message","whisper to user",NULL,
"Send a {yellow}message{white} that only the given {yellow}player{white} will receive.");
HELP{"chat"}{"whois"}=("player","show player info",NULL,
"Ask the meta server to describe a {yellow}player{white}. The personal data (realname, email, plan) set by the player is shown as well as his/her wealth and game play history.");
HELP{"chat"}{"kick"}=("player","disconnect player",("God","Guard"),
"This command forces disconnection for {yellow}player{white}.");
HELP{"chat"}{"kicktable"}=("tblnum","disconnect table",("God","Guard"),
"This command forces disconnection for table {yellow}tblnum{white}. Alternatively {orange}/kicktable all{white} removes all tables.");
HELP{"play"}{"savegame"}=("","save your game",NULL,
"Saves your current game status to the disk in the game server. Each player, player pair, player triple, etc. have one personal save file, which is overwritten each time using this command. Saving the game does not end it, but you can declare undecided result and continue later using {yellow}/loadgame{white}. This command is automatically applied when one of the players' network connection dies. See also {orange}/help delgame{white}.");
HELP{"play"}{"loadgame"}=("","restore your game",NULL,
"Searches if there is a saved game for current player(s) and restores it, if found. Note that you must be playing at the same server, where you saved your game - not necessarily at the same table. The game server announces at the beginning of the game, if there is a saved game available for your play group. Restoring the saved game does not remove it from the server; see also {orange}/help delgame{white}.");
HELP{"play"}{"delgame"}=("","delete your saved game",NULL,
"Remove a saved game for the current group of players. This command should be applied to save disk space on a server, when the saved game is not needed anymore.");
HELP{"play"}{"autopass"}=("","force a draft to proceed",NULL,
"If you are at a draft table, and it has been a while since the cards were last passed, you can use this command to force the server to randomly pick for the players who haven't made their most recent pick.");
HELP{"chat"}{"yell"}=("message","send message to all",NULL,
"This command echoes a {yellow}message{white} to all players, even those who are currently playing.");
HELP{"chat"}{"unban"}=("player","unban a player",("God","Guard"),
"Remove a player from the ban list. See also {orange}/help ban{white}.");
HELP{"chat"}{"unrestrict"}=("domain","remove restriction",("God","Guard"),
"Remove a domain from the restriction list. See also {orange}/help restrict{white}.");
HELP{"any"}{"rtfm"}=("","give some info",NULL,
"Show a link {green}http://gccg.sourceforge.net/pages/faq.php{white} for newbies. Optional arguments are added after the link in parenthesis, e.g. section number to check out.");
HELP{"chat"}{"faq"}=("entry","add FAQ entries",NULL,
"This command displays an {yellow}entry{white} using {cyan}cyan{white} text and adds a line to the FAQ proposals. All proposals are examined manually and added to the FAQ if they are useful. Please add questions starting with {green}Q:{white} and answers starting with {green}A:{white}. Without arguments, show current proposals for the FAQ.");
HELP{"chat"}{"giveticket"}=("u,n,s,p","give boosters",("God","Salesman","Judge"),
"Give {yellow}n{white} free product tickects, each allowing to buy one product {yellow}p{white} of the set {yellow}s{white} without charge, to the player {yellow}u{white}.");
HELP{"chat"}{"info"}=("player,[info]","set info field",("God","Judge"),
"Set, unset or display the system information for a {yellow}player{white}. Without {yellow}info{white} text, it displays the current system information field for the player. If the {yellow}info{white} text is {green}NULL{white}, the information is removed. Otherwise it is taken as a new value. The system information field is displayed in {green}/whois{white} query.");

# Callback table for protocol.
function=(,);
function{"AddMarker"}="AddMarker";
function{"AddRoomPlayer"}="AddRoomPlayer";
function{"AddRoomTable"}="AddRoomTable";
function{"Attach"}="Attach";
function{"Bid"}="Bid";
function{"Buy"}="Buy";
function{"ClearGame"}="ClearGame";
function{"ConnectServer"}="ConnectServer";
function{"CreateActive"}="CreateActive";
function{"CreatePlayerIcon"}="CreatePlayerIcon";
function{"CreateDeck"}="CreateDeck";
function{"CreateHand"}="CreateHand";
function{"DeckDelTable"}="DeckDelTable";
function{"DelActive"}="DelActive";
function{"DelDeck"}="DelDeck";
function{"DelDeckBottom"}="DelDeckBottom";
function{"DelDeckTop"}="DelDeckTop";
function{"DelHand"}="DelHand";
function{"DelMarker"}="DelMarker";
function{"DelRoomPlayer"}="DelRoomPlayer";
function{"DelRoomTable"}="DelRoomTable";
function{"DelTable"}="DelTable";
function{"Detach"}="Detach";
function{"EndGame"}="_EndGame";
function{"Flash"}="Flash";
function{"GameSetup"}="GameSetup";
function{"InitializeGame"}="_InitializeGame";
function{"JoinTable"}="JoinTable";
function{"LeaveTable"}="LeaveTable";
function{"LeaveTableToChat"}="LeaveTableToChat";
function{"Lower"}="Lower";
function{"Message"}="Message";
function{"MoveObject"}="MoveObject";
function{"Null"}="Null";
function{"Play"}="Play";
function{"PlaySound"}="PlaySound";
function{"PutActive"}="PutActive";
function{"PutDeck"}="PutDeckTop";
function{"PutDeckBottom"}="PutDeckBottom";
function{"PutHand"}="PutHand";
function{"PutTable"}="PutTable";
function{"Quit"}="Quit";
function{"Raise"}="Raise";
function{"ReplaceTable"}="ReplaceTable";
function{"RestoreDeck"}="RestoreDeck";
function{"Rotate"}="Rotate";
function{"Score"}="Score";
function{"SearchDeck"}="SearchDeck";
function{"SetActive"}="SetActive";
function{"SetCardbook"}="SetCardbook";
function{"SetDeck"}="SetDeck";
function{"SetDeckTop"}="SetDeckTop";
function{"SetHand"}="SetHand";
function{"SetJoinGame"}="SetJoinGame";
function{"SetMe"}="SetMe";
function{"SetMyName"}="SetMyName";
function{"SetMode"}="SetMode";
function{"SetMoney"}="SetMoney";
function{"SetOption"}="SetOption";
function{"SetPassword"}="SetPassword";
function{"SetPrice"}="SetPrice";
function{"SetProducts"}="SetProducts";
function{"Special"}="Special";
function{"StartGame"}="_StartGame";
function{"Times"}="Times";
function{"Torrent"}="Torrent";
function{"HaveList"}="HaveList";
function{"WantList"}="WantList";

def playerhas {
  if(playerhave{ARG[0]} != NULL)
    return (find(ARG[1],playerhave{ARG[0]}) != NULL);
  else
    return(0);
}

def playerwants {
  if(playerwant{ARG[0]} != NULL)
    return (find(ARG[1],playerwant{ARG[0]}) != NULL);
  else
    return(0);
}

modifier=" ";

#
# FUNCTIONS WAITING FOR C++ IMPLEMENTATION
# ========================================

#
# subobjects(object number) - Return all direct subobjects of the object.
#
def subobjects
{
  return((object_data(ARG))[5]);
}

#
# root_object(object number) - Return the root object of the object.
#
def root_object
{
  if((object_data(ARG))[4])
    return(root_object((object_data(ARG))[4]));
  else
    return(ARG);
}

#
# is_object(object number) - Return 1 if the object exists.
#
def is_object
{
  return(object_data(ARG)!=NULL);
}

#
# FUNCTIONS
# =========

#
# ok() - Check if the client has card data and show error if not.
#
def ok
{
  if(length(sets())==0)
    Msg("{red}You need to download game repository for full functionality.");
  else
    return(1);
}

#
# d(expr) - Dump the arguments to the message box.
#
def d
{
  Msg(tostr(ARG));
}

#
# CheckInitialVariablesOrQuit(v) - Quit with an error message if variable
#   v is not defined.
#
def CheckInitialVariablesOrQuit
{
  if(eval(ARG)==NULL)
  {
    println("");
    println("FATAL: Variable "+ARG+" is not initialized at "+GAMEDIR+".include");
    quit();
  }
}

#
# CheckFunctionsOrQuit(f) - Quit with an error message if function
#   f is not defined.
#
def CheckFunctionsOrQuit
{
  if(!isfunction(ARG))
  {
    println("");
    println("FATAL: Function "+ARG+" is not defined at "+GAMEDIR+".include");
    quit();
  }
}

#
# CheckInitialVariables() - Check that required variables and
#   functions are defined before game initialization.
#
def CheckInitialVariables
{
  CheckInitialVariablesOrQuit("card.width");
  CheckInitialVariablesOrQuit("DECKBOX_SIZE");
  CheckInitialVariablesOrQuit("HANDSIZE");
  CheckInitialVariablesOrQuit("server.name");
  CheckInitialVariablesOrQuit("port");
  CheckInitialVariablesOrQuit("product.image");
  CheckFunctionsOrQuit("NewDeck");
  CheckFunctionsOrQuit("InitializeLocationTables");
  CheckFunctionsOrQuit("StartGame");
}

#
# Initialize() - Initialize screen objects and variables.
#
def Initialize
{
  CheckInitialVariables();
  InitializeInputSystem();
  InitializePanelSystem();

  table.image=load_image("table.png");

  background.image=load_image("background.png");
  background.object=create_image(0,(screen.height-image_height(background.image))/2,obj=obj+1,background.image,"background",0);
  set_attr(background.object,"visible",1);
  set_attr(background.object,"onbottom",1);

  CreatePanel("alert",screen.width/2-w(200),h(100));
  CreatePanel("messages",w(5),h(5));
  if(options{"input"}=="top")
    CreatePanel("input",0,0);
  else
    CreatePanel("input",0,screen.height-h(16));
  CreatePanel("player info",w(5),screen.height-h(82));
  CreatePanel("products",w(5),h(200));

  set_attr(msg.box,"ontop",Z_MBOX);
  raise(msg.box);
  set_attr(alert.box,"ontop",Z_ALERT);
  raise(alert.box);

  chat_msg.box=create_msgbox(screen.width-w(403),screen.height-h(220),obj=obj+1,"chat msg",w(400),h(200),99999);
  set_bgcolor(chat_msg.box,NULL);
  set_fgcolor(chat_msg.box,BRCOLOR);
  set_attr(chat_msg.box,"visible",1);
  set_attr(chat_msg.box,"highlight",1);
  set_attr(chat_msg.box,"clickable",1);
  set_attr(chat_msg.box,"draggable",1);
  set_attr(chat_msg.box,"ontop",Z_MBOX);
  raise(chat_msg.box);
  message(chat_msg.box,"{sz9}press {orange}F6{white} to make this box disappear or reappear");

  message(name.box,username);
  pm_name=NULL;
  
  playerhave = (,);
  playerwant = (,);

  mode_object{"chat"}=mode_object{"chat"}+(money.box,name.box,deckname.box);

  CreateScreen("empty",("input",));
  CreateScreen("chat",("messages","input","player info"));
  ShowScreen("chat");

  Msg("{hr}");
  Msg(L("{sz20}{center}Welcome to Gccg/%s",GAME));
  Msg("{center}{sz16}© 2001-2012 Tommi Ronkainen");
  Msg(L("{sz20}{center}Press {orange}F1{white} for help or {orange}right click{white} for menu."));
  Msg("{hr}");

  card.book=create_book(w(5),h(140),obj=obj+1,"My Collection",BOOK_ROWS,BOOK_COLUMNS);
  set_attr(card.book,"ontop",Z_COLLECTION);
  raise(card.book);
  set_bgcolor(card.book,BKBGCOLOR);
  set_fgcolor(card.book,BKBRCOLOR);
  set_textcolor(card.book,BKTXCOLOR);
  books = (card.book,);

  CheckFilterVersion();
  if(!load("book.current_index"))
    book.current_index=("default","default");
  SetBookIndex(book.current_index);

  if(!load("book.page"))
    book.page=0;
  if(book.page > book_last_page(card.book))
    book.page=book_last_page(card.book);
  SetBookPage(book.page);

  booster.box=create_cardbox(screen.width/2,screen.height/2,obj=obj+1,"Open booster");
  set_attr(booster.box,"compact",1);
  set_attr(booster.box,"ontop",Z_BOOSTER);

  search.box=create_cardbox(screen.width/2,screen.height/2,obj=obj+1,"Deck search box");
  set_attr(search.box,"compact",1);
  set_attr(search.box,"ontop",Z_SETASIDE-1);

  select.box=create_cardbox(screen.width/2,screen.height/2,obj=obj+1,"Card select box");
  set_attr(select.box,"compact",1);

  drag.box=create_cardbox(screen.width/2,screen.height/2,obj=obj+1,"Card drag box");
  set_attr(drag.box,"tiny",1);
  set_attr(drag.box,"ontop",1);

  deck.box=create_listbox(screen.width-w(sum(DECKBOX_SIZE)+4),h(135),obj=obj+1,"Current Deck",100,("#","Name of the card",""),DECKBOX_SIZE,34,(1,0,1));
  set_attr(deck.box,"ontop",Z_DLIST);
  raise(deck.box);
  
  undo_buffer=(,);
  undo.pos=-1;

  if(!load("info.x") || !load("info.y"))
  {
    info.x=0;
    info.y=0;
  }
  if(info.x<0)
   info.x=0;
  if(info.y<0)
   info.y=0;
  if(info.x + (card.width * 100 / toint(game_option("table card size"))) > screen.width)
   info.x = screen.width - (card.width * 100 / toint(game_option("table card size")));
  if(info.y + (card.height * 100 / toint(game_option("table card size"))) > screen.height)
   info.y = screen.height - (card.height * 100 / toint(game_option("table card size")));
  info.box=create_cardbox(info.x,info.y,obj=obj+1,"Info");
  set_attr(info.box,"draggable",1);
  set_attr(info.box,"ontop",Z_ZOOM);
  raise(info.box);
  info.current=NULL;
  if(!load("info.persistent"))
    info.persistent=0;

  menu.object=(obj=obj+1);

  TABLES_X=(screen.width - w(40))/ (w(10)+image_width(table.image));
  TABLES_Y=(screen.height - h(300)) / (h(10)+image_height(table.image));

  table.object=array(TABLES_X);
  table.number=array(TABLES_X);
  obj=obj+1;

  for(y)(TABLES_X)
  {
    table.object[y]=seq(obj,obj+TABLES_Y-1);
    table.number[y]=array(TABLES_Y);
    obj=obj+TABLES_Y;
  }

  sounds.flip_coin      = load_sound("flip_coin.ogg");
  sounds.roll_dice      = load_sound("roll_dice.ogg");
  sounds.launch         = load_sound("launch.ogg");
  sounds.start          = load_sound("start.ogg");
  sounds.shuffle        = load_sound("shuffle.ogg");
  sounds.card_drop      = load_sound("card_drop.ogg");
  sounds.card_pickup    = load_sound("card_pickup.ogg");
  sounds.single_token   = load_sound("single_token.ogg");
  sounds.multiple_token = load_sound("multiple_token.ogg");
  sounds.notify         = load_sound("notify.ogg");
  
  if(isfunction("InitializeHook"))
    InitializeHook();
  
  PlaySound(sounds.launch);
  
  InitializeScoreSystem();
}

#
# InitializeConnection() - Check the variables and try out servers to connect.
#
def InitializeConnection
{
  push(s);
  s=(server.name,);
  if(server.name==server.name_default && server.name_backup!=NULL)
  {
    s=s+server.name_backup;
  }

  for(n)(s)
  {
    if(server==NULL)
    {
      if(server.name=="none") 
      {
        message(msg.box,"Working offline");
        mode="offline";
      } 
      else
      {
        message(msg.box,"Connecting to "+n+" port "+port); 

        server=net_connect(n,port);

        if(server==NULL)
        {
          message(msg.box,"Connection failed");
          message(msg.box,"Working offline");
          mode="offline";
        }
        else
        {
          server.name=n;
          net_send(server,("RegisterPlayer",(username,VERSION,database.cards,GAME,password{username},SYSTEM,eval("ser"+"ial"))));
          if(TORRENT_VERSION)
             net_send(server,("TorrentVersion",(TORRENT_VERSION,)));
        } 
      }
    }
  }

  s=pop();
}

#
# SaveAll() - Save all user variables.
#
def SaveAll
{
  if(deck.name != NULL)
    save("deck.name");
  if(decks != NULL)
    save("decks");
  if(deck.groups != NULL)
    save("deck.groups");
  if(price.default != NULL)
    save("price.default");
  save("options");
  if(history != NULL)
  {
    push(history);
    if(length(history))
    {
      history=index(history,seq(0,min(length(history)-1,20)));
      save("history");
    }
    history=pop();
  }
  save("bind");
  save("bindk");
  book.page=book_page(card.book);
  save("book.page");
  book.filter=select("last(#)!=NULL",book.filter);
  save("book.filter");
  book.index=select("last(#)!=NULL",book.index);
  save("book.index");
  save("book.filter_version");
  save("book.my_filters");
  if(book.index{book.current_index}==NULL)
    book.current_index=("default","default");
  save("book.current_index");
  save("info.x");
  save("info.y");
  save("info.persistent");
  SaveBookState();
  save("logs");
}



#
# _InitializeGame() - Initialize game variables.
#
def _InitializeGame
{
  player.marker_color=DEFAULT_MARKER_COLOR;
  active=array(players);
  hand=array(players);
  deck.objects=array(players);
  deck.class=(,);
  card.group=(,);
  search.source=NULL;
  for(p)(MAX_PLAYERS)
    message(score.object[p],"");

  if(players <= 2)
  {
    table.width=BASE_TABLE_WIDTH;
    table.height=BASE_TABLE_HEIGHT;
    card.xstep=card.design.width;
    card.ystep=card.design.height;
    set_cardsize("table",toint(game_option("table card size")));
  }
  else
  {
    table.width=BASE_TABLE_WIDTH / ((players + 1) / 2);
    table.height=BASE_TABLE_HEIGHT;
    card.xstep=card.design.width / ((players + 1) / 2);
    card.ystep=card.design.height;
    set_cardsize("table",toint(game_option("table card size")) / ((players + 1) / 2));
  }

  InitializeLocationTables();

  if(isfunction("InitializeGame"))
    InitializeGame();
}

#
# _EndGame() - Game over. Close connections.
#
def _EndGame
{
  if(isfunction("EndGame"))
    EndGame(NULL);
  if (con != server.meta)
  {
    net_send(con,("OK",NULL));
    net_close(con);
  }
  ClearScores();
#  if (mode != "chat")
#    SetMode("chat");
}

#
#  Alert(message) - Display message box.
#
def Alert
{
  raise(alert.box);
  del_all_texts(alert.box);
  add_text(alert.box,ARG);
  ShowPanel("alert");
}

#
#  AlertOff() - Hide previously displayed message.
#
def AlertOff
{
  HidePanel("alert");
}

#
#  ShowHelp() - Show help text.
#
def ShowHelp
{
  if(mode=="offline")
  {
    Msg("{hr}");
    Msg(L("{orange}{center}{sz20}No help available in offline mode."));
  }
  else
  {
    Msg("{hr}");
    Msg(L("{orange}{center}{sz20}Right click an object for menu!"));
    push(M);
    push(m);
    push(n);
    push(l);
    push(w);
    push(ok);

    w=MAX_MESSAGE/3;
    n=0;
    M="";

    for(c)(sort(HELP{mode} + HELP{"any"}))
    {
       ok=(c[1][2]==NULL);
       if(!ok)
         ok=(count(username,c[1][2]) != 0);

      if(ok)
      {
        m="";
        m=m+"{yellow}/"+c[0];
        for(a)(split(c[1][0],","))
        {
          m=m+" <"+a+">";
        }
        m=m+"{white} - "+L(c[1][1]);
        l=text_width(0,12,m);
      
        M=M+m;
        if(n % 3==2)
        {
          Msg(M);
          M="";
        }
        else
          M=M+" "*((w-l)/text_width(0,12," "));

        n=n+1;
      }
    }

    if(M != "")
      Msg(M);

    ok=pop();
    w=pop();
    l=pop();
    n=pop();
    m=pop();
    M=pop();
  }
}

#
# Receive(e,d) - Network event ('e','d') received.
#
def Receive
{
  if(ARG != NULL)
  {
    if(options.debug)
      println("Received: "+tostr(ARG));

    push(command);
    push(parameter);
    command=ARG[0];
    parameter=ARG[1];
    if(function{command} != NULL)
    {
      if(flag.logging)
      {
        if((mode=="play" || mode=="watch") && ARG[0]!="Null" && con==server && server!=server.meta)
        {
          logs{log.name}=logs{log.name}+(ARG,);
        }
      }
      call(function{command},parameter);
    }
    else
    {
      Msg("{red}UNKNOWN PACKET "+command+"("+tostr(parameter)+") RECEIVED");
      Msg("{red}Have you updated your client lately?");
    }
    parameter=pop();
    command=pop();
  }
}

#
# Send(event) - Send network protocol message to the server.
#
def Send
{
  if(mode!="" && mode !="offline")
  {
    if(net_isopen(server))
      net_send(server,ARG);
    else
      Msg("{red}Connection is already closed.");
  }
}

#
# SendMeta(event) - Send network protocol message to the meta server.
#
def SendMeta
{
  if(mode!="" && mode !="offline")
  {
    if(server.meta == NULL)
      Msg("{red}Connection is already closed.");
    elseif(net_isopen(server.meta))
      net_send(server.meta,ARG);
    else
      Msg("{red}Connection is already closed.");
  }
}

#
# Torrent(version,file,data) - Reveive the latest torrent file.
#
def Torrent
{
  push(f);
  f=HOME+"/.gccg/"+GAMEDIR+"/"+ARG[1];
  write_file_raw(f,hexdecode(ARG[2]));
  Msg("Received a torrent file version "+ARG[0]+" and saved to "+f);
  f=pop();
}

#
# SetMe(number) - Set my player number.
#
def SetMe
{
  me=ARG;
}

#
# SetMyName(name) - Set my name.
#
def SetMyName
{
  username=ARG;
  message(name.box,username);
}

#
# SetHandSize(size percentage) - Set hand size with respect to the default size.
#
def SetHandSize
{
  set_cardsize("hand",(ARG*toint(game_option("hand card size"))) / 100);
}

#
# RefreshCurrentDeck() - Update collection and current deck if selected.
#
def RefreshCurrentDeck
{
  if(deck.name!=NULL && has_entry(deck.name,decks))
  {
    push(b);
    for(b)(books)
      book_set_deck(b,decks{deck.name});
    cards_missing=listbox_set_deck(deck.box,decks{deck.name},card.book);
    b=pop();
  }
}

#
# SetCardbook(entries) - Update entries (# of cards,for sale,my price) at my card book.
#
def SetCardbook
{
  book_set_entry(card.book,ARG);
  if(deck.name!=NULL && has_entry(deck.name,decks))
  {
    push(b);
    for(b)(books)
      book_set_deck(b,decks{deck.name});
    cards_missing=listbox_set_deck(deck.box,decks{deck.name},card.book); 
    forall("book_refresh{#}=1",keys(ARG));
    b=pop();
  }
}

#
# MergeDeck(deck name) - Add content of the another deck to the current deck.
#
def MergeDeck
{
  Msg("Adding cards from "+ARG+" to the current deck...");
  for(p)(decks{ARG}) 
  {
    if(!has_entry(p[0],decks{deck.name}))
      decks{deck.name}{p[0]}=(,);
    Msg("  adding "+length(p[1])+" cards to "+p[0]);
    decks{deck.name}{p[0]}=decks{deck.name}{p[0]}+p[1];
  }
  RefreshCurrentDeck();
}

#
# SelectDeck(deck name) - Called when player selects his deck.
#
def SelectDeck
{
  if(has_entry(NULL,decks))
    decks=del_entry(NULL,decks);

  if(ARG != NULL)
  {
    if(has_entry(ARG,decks))
    {
      if(decks{ARG}==NULL)
      {
        Msg("{red}Your deck '"+ARG+"' is corrupted for some reason.");
        Msg("{red}This is probably a bug in Gccg unless you have edited decks manually.");
        Msg("{red}You should report this bug, if you can remember what you did just before this happened.");
        Msg("{red}I deleted the corrupted deck '"+ARG+"'.");
        DeleteDeck(ARG);
      }
      else
      {
        deck.name=ARG;
        Msg("Deck '"+deck.name+"' selected.");
        RefreshCurrentDeck();
        RefreshBookForDeck(deck.name);
        listbox_scroll(deck.box,-(listbox_scroll(deck.box,0)));
        if(isfunction("clear_msgbox"))
          clear_msgbox(deckname.box);
        else
        {
          message(deckname.box,"");
          message(deckname.box,"");
        }
        message(deckname.box,"Deck: {white}"+deck.name);
        undo_buffer=(,);
        undo.pos=-1;
      }
    }
  }
}

#
# DeleteDeck(name) - Remove the deck from the collection.
#
def DeleteDeck
{
  if(has_entry(ARG,decks))
  {
#   remove group reference if applicable
    g=GroupOf(ARG);
    if(length(g)>0)
      deck.groups{g}=deck.groups{g}-(ARG,);
      
    decks=del_entry(ARG,decks);
    for(g)(books)
      book_set_deck(g,NewDeck());
    cards_missing=listbox_set_deck(deck.box,NewDeck(),card.book);
    set_attr(deck.box,"visible",0);
    deck.name=NULL;
    undo_buffer=(,);
    undo.pos=-1;
    if(isfunction("clear_msgbox"))
      clear_msgbox(deckname.box);
    else
    {
      message(deckname.box,"");
      message(deckname.box,"");
    }
    message(deckname.box,"{red}No Deck Selected");
  }
}

#
# BookSetPrice(card number,price,[object number of book]) - set my price for a card and update it on server.
#
def BookSetPrice
{
  push(e);
  if(length(ARG)==2)
    ARG=ARG+(card.book,);
  
  if(ARG[1] >= 0.0)
  {
    e=book_entry(ARG[2],ARG[0]);
    e[3]=ARG[1];
    book_set_entry(ARG[2],((ARG[0],e),));
    SendMeta("SetPrice",(ARG[0],ARG[1]));
  }
  e=pop();
}

#
# BookChangeForsale(card number,difference,[object number of book]) - decrease or increase number of cards for sale.
#
def BookChangeForsale
{
  push(e);
  if(length(ARG)==2)
    ARG=ARG+(card.book,);
  
  e=book_entry(ARG[2],ARG[0]);
  e[4]=e[4]+ARG[1];
  book_set_entry(ARG[2],((ARG[0],e),));
  SendMeta("SetForsale",(ARG[0],e[4]));
  e=pop();
}

#
# Say(message) - Say given message.
#
def Say
{
  if(mode!="offline" && ARG!="")
  {
    SetAwayOff();
    Send("Say",ARG);
  }
}

#
# ProductLookup(name) - Search for a product name defined by user supplied string.
#
def ProductLookup
{
  push(n);
  n=NULL;
  if(has_entry(ARG,products))
    n=ARG;
  else 
  {
    for(p)(products)
    {
      if(uc(p[0])==uc(ARG))
        n=p[0];
      if(uc(join(p[1][2]," "))==uc(ARG))
        n=p[0];
    }
  }
  return(n);
  if(n==NULL && right(ARG,7)!="booster")
    return(ProductLookup(ARG+" booster"));    
  n=pop();
}

#
# PlayerName(player number) - Convert chat room player number to name.
#
def PlayerName
{
  if(has_entry(ARG,room.players))
    return(room.players{ARG}[0]);
  else
    return("");
}

#
# MakeLegalityCheck(ruleset) - Perform client-side legality check for the current deck.
#
def MakeLegalityCheck
{
  if(has_entry(deck.name,decks))
  {
    push(l);
    deck_rulecheck.errors=(,);
    deck_rulecheck.errors{ARG}=(,);
    deck_rulecheck.system=ARG;
    LegalityCheckRuleset(ARG,decks{deck.name});

    if(length(deck_rulecheck.errors{ARG})==0)
        Msg("{green}The deck is legal "+ARG+" deck.");
    else
    {
      for(m)(deck_rulecheck.errors{ARG})
        Msg("{orange}Failed check for "+ARG+": {white}"+m);
    }

    l=pop();
  }
}

#
# LoadAllRules() - Search all rules for this game and append them to 'deck_rules' variable.
#
def LoadAllRules
{
  push(r);

  r=(,);
  for(f)(rules())
  {
    deck_rules=(,);
    execute(f);
    for(k)(keys(deck_rules))
      r{k}=deck_rules{k};
  }
  deck_rules=r;

  r=pop();
}

#
# LoadAllScripts() - Search all game specific extension scripts and execute all command-scripts.
#
def LoadAllScripts
{
  for(s)(scripts())
  {
    if(right(s,8)==".command" || right(s,8)==".include")
      execute(s);
    else if(right(s,5)==".menu")
      LoadMenu(s);
  }
}

#
# LoadMenu(script file) - Append menus found from the script file to the menu.
#
def LoadMenu
{
  push(menu);

  menu=(,);
  execute(ARG);

  if(menu!=(,))
  {
    for(e)(menu)
    {
      if(!has_entry(e[0],EXTRA_MENU))
        EXTRA_MENU{e[0]}=(,);
       EXTRA_MENU{e[0]}=EXTRA_MENU{e[0]} + e[1];
    }
  }

  menu=pop();
}

#
# Mode() - Return current client mode ("sealed",etc.) or "" if none.
#
def Mode
{
  push(n);
  n=split(username,"-");

  if(length(n)==2)
    return(n[1]);
  else
    return("");
  n=pop();
}

#
# SelectCard(list of cards, expression,card source) - Select a card and evaluate
#   expression denoting the selected card with #. If card source is
#   not null, the selected card can be transferred with shortcut keys.
#
def SelectCard
{
  del_cardbox_all_recenter(select.box);
  set_attr(select.box,"visible",1);
  set_attr(select.box,"ontop",55);
  put_cardbox_recenter(select.box,ARG[0]);
  raise(select.box);
  select.expression=ARG[1];
  select.source=ARG[2];
}

#
# ObjW(object number) - Return the width of the object.
#
def ObjW
{
  return((object_data(ARG))[2]);
}

#
# ObjH(object number) - Return the height of the object.
#
def ObjH
{
  return((object_data(ARG))[3]);
}

#
# AllCounters(object number) - Return a map of counter numbers to their amount for an object.
#
def AllCounters
{
  push(c);
  if(ARG)
    return((object_data(ARG))[6]);
  c=pop();
}

#
# Counters(object number,index) - Get counters of given color index for an object.
#
def Counters
{
  return((AllCounters(ARG[0])){ARG[1]});
}

#
# TARGETTING AND ATTACHING
# ========================

#
# ParentObject(object number) - Return an object where the given
#   object is attached to or NULL if none.
#
def ParentObject
{
  push(o);

  o=object_data(ARG);
  if(o[4])
    return(o[4]);

  o=pop();
}

#
# Attachments(object number) - Return list of attached objects.
#
def Attachments
{
  push(o);

  o=object_data(ARG);
  return(o[5]);

  o=pop();
}

#
# NextTarget() - Return next target in the targeting
#   queue and remove it from the queue. Return value is a list 
#   (object number, card number, xoffset, yoffset, xsuboffset,ysuboffset, options)
#   or NULL if no targets found.
#
def NextTarget
{
  if(length(targeting_queue)>0)
  {
    push(c);
    push(q);

    c=last(targeting_queue);
    q=select('(card_data(#))[2]==c[0] && ParentObject(#)==NULL',inplay(me));
    targeting_queue=head(targeting_queue);

    if(length(q)>0)
      return((last(q),)+c);
    else if(length(targeting_queue)>0)
      return(NextTarget());

    q=pop();
    c=pop();
  }
}

#
# Positions(object numbers) - Return list of coordinates having center points of objects.
#
def Positions
{
  return(apply('center_of',ARG));
}

#
# ObjectAt(x,y) - Return an object number whose center point is at (x,y) or NULL if none.
#
def ObjectAt
{
  push(o);
  o=select('center_of(#)==ARG',objects());
  if(length(o))
    return(first(o));

  o=pop();
}

#
# IsVeryNear(pos,list of positions) - Return index if pos is near some point in the list
#   or NULL if it is not near any point.
#
def IsVeryNear
{
  push(i);
  push(xy);
  for(i)(length(ARG[1]))
  {
    if(dist(ARG[0],ARG[1][i]) < 25)
      return(i);
  }
  xy=pop();
  i=pop();
}

#
# NextFreeAttachPos(object number,xoffset,yoffset,xsuboffset,ysuboffset) - Find next free position
#   among attachments having given offsets.
#
def NextFreeAttachPos
{
  push(xy);
  push(i);
  push(p);
  p=Positions(Attachments(ARG[0]));
  xy=center_of(ARG[0]);
  i=0;
  xy[0]=xy[0]+ARG[1];
  xy[1]=xy[1]+ARG[2];

  while(IsVeryNear((xy[0]+i*ARG[3],xy[1]+i*ARG[4]),p)!=NULL)
    i=i+1;

  return(i);

  p=pop();
  i=pop();
  xy=pop();
}

#
# LowerAttachments(object number,xoffset,yoffset,xsuboffset,ysuboffset,index) - Scan through
#   attachments of object starting from index and lower each attachment found.
#
def LowerAttachments
{
  push(xy);
  push(i);
  push(j);
  push(p);
  push(o);

  p=Positions(Attachments(ARG[0]));
  xy=center_of(ARG[0]);

  i=ARG[5];
  xy[0]=xy[0]+ARG[1];
  xy[1]=xy[1]+ARG[2];

  while(i<=length(p))
  {
    j=IsVeryNear((xy[0]+i*ARG[3],xy[1]+i*ARG[4]),p);
    if(j!=NULL)
      Send("Lower",ObjectAt(p[j]));
    i=i+1;
  }

  o=pop();
  p=pop();
  j=pop();
  i=pop();
  xy=pop();
}

#
# TargetingOptions() - Return the list of targetting (category,group) pairs defined for this game.
#
def TargetingOptions
{
  push(o);
  o=(,);
  for(t)(rules.coordinate)
  {
    if(t[1][0][0][0]=="TargetCard")
      o=o+(t[0],);
  }
  return(o);
  o=pop();
}

#
# ManualTarget(object number, targeting rule) - Apply targeting manually.
#
def ManualTarget
{
  push(t);
  push(findspace.card);
  push(findspace.options);

  detach(ARG[0]);
  raise(ARG[0]);

  t=(select("(#)[0]==ARG[1]",rules.coordinate))[0][1];
  
  findspace.options=t[1];
  findspace.card=card(ARG[0]);
  TargetCard((0,0)+tail(t[0][0]));

  findspace.options=pop();
  findspace.card=pop();
  t=pop();
}

#
# COMMANDS
# ========

#
# SlashCommand(string) - Analyze and execute chat /-command.
#
def SlashCommand
{
  push(c);
  
  c=split(ARG," ");
  if(first(c[0])=="/")
  {
    c[0]=right(c[0],length(c[0])-1);
    if(isfunction(username+ucfirst(mode)+"Command"+ucfirst(c[0])))
      call(username+ucfirst(mode)+"Command"+ucfirst(c[0]),tail(c));
    else if(isfunction(ucfirst(mode)+"Command"+ucfirst(c[0])))
      call(ucfirst(mode)+"Command"+ucfirst(c[0]),tail(c));
    else if(isfunction("Command"+ucfirst(c[0])))
      call("Command"+ucfirst(c[0]),tail(c));
    else
    {
      if(count(first(c),keys(HELP{"chat"})))
        SendMeta("Command","/"+join(c," "));
      else
        Send("Command","/"+join(c," "));
    }
  }
  c=pop();
}

#
# CommandMe() - Implementation of /me command.
#
def CommandMe
{
  if(join(ARG," ") != "")
    Send("Action",join(ARG," "));
}
HELP{"any"}{"me"}=("text","emote",NULL,
"Send an emote string to the server, which replies it as an action made by you.");

#
# ChatCommandAway() - Implementation of /away command.
#
def ChatCommandAway
{
  push(m);
  m=join(ARG," ");
  if(m=="")
  {
    if(IsAway())
      SetAwayOff();
    else
      Msg("{red}You are not away.");
  }
  else
  {
    if(!IsAway())
      SetAwayOn(m);
    else
      Msg("{red}You are already away.");
  }
  m=pop();
}
HELP{"chat"}{"away"}=("text","toggle away status",NULL,
"Marks you as away from the keyboard with the given text as an explantion. Without any arguments, removes away status.");

#
# ChatCommandPm(name) - Implementation of /pm command.
#
def ChatCommandPm
{
  if(!length(ARG))
  {
    if(pm_name != NULL)
      EndPMSession();
    else
      Msg("{red}No session active.");
  }
  else if(ARG[0]==username)
    Msg("{red}You can't PM yourself!");
  else if(has_entry(ARG[0],avatar.object))
  {
    pm_name = ARG[0];
    MsgChat("{hr}");
    MsgChat("{orange}Hover over this box to whisper to "+ARG[0]);
    if(!get_attr(chat_msg.box,"visible"))
      Msg("Please press {yellow}F6{reset} to open the chat window.");
  }
  else
    Msg("{red}No such user online.");
}

def EndPMSession
{
  pm_name = NULL;
  MsgChat("{orange}PM session closed.");
}

HELP{"chat"}{"pm"}=("name","start private chat",NULL,
"If {yellow}[name]{white} is online, start a chat session. Any message you enter while hovering the mouse over the chat box in the lower right will be a whisper directed to that user. You can end a session by typing {yellow}/pm{white} with no arguments, watching a game, or sending a message after the target signs off.");

#
# CommandRefresh() - Implementation of /refresh command.
#
def CommandRefresh
{
  Msg("Sending a collection refresh request.");
  BookFullRefresh();
}
HELP{"any"}{"refresh"}=("","refresh collection",NULL,
"Ask full refresh of the collection status from server. Normally the collection state is stored on disk cache and may be not accurate if you have been offline.");

#
# CommandClearcache() - Implementation of /clearcache command.
#
def CommandClearcache
{
  Msg("Cleaning out old book files.");
  book.cache=(,);
  save("book.cache");
  book.filter=(,);
  book.index=(,);
  book.my_filters=(,);
  save("book.my_filters");
  book.history=(,);
  save("book.history");
  
  CheckFilterVersion();
  SetBookIndex("default","default");
  
  save("book.filter");
  save("book.index");
}
HELP{"any"}{"clearcache"}=("","clear out book variables",NULL,
"Remove all cached variables dealing with the cardbook. In case of new cards being added to the game, you may need to clear cache before the cards are recognized.");

def CommandReconnect
{
  push(c);
  if(server == NULL)
    c=1;
  elseif(!net_isopen(server))
    c=1;
  if(c)
  {
    server = NULL;
#   no effect if already in chat mode
    SetMode("chat");
    
    forall('DelRoomPlayer(#[0])',room.players);
    forall('DelRoomTable(#[0])',room.tables);
    InitializeConnection();
    
    if(server != NULL)
    {
      server.meta = server;
      sleep(1);
      Send("RefreshChatRoom",NULL);
    }
  }
  else
    Msg("Connection is still open. Cannot reconnect.");
  c=pop();
}

HELP{"any"}{"reconnect"}=("","reconnect to server",NULL,
"If you have lost connection to the meta server, this will attempt to put you back in the chatroom without having to close and reopen the program.");

def CommandDisconnect
{
  if(server!=NULL)
  {
    net_close(server);
    Msg("{red}Closed connection.");
  }
}

HELP{"any"}{"disconnect"}=("","disconnect to server",NULL,
"Close the connection to your table or meta server without having to quit the program.");

def OfflineCommandNick
{
  push(n);
  n=ARG;
  if(ValidUsername(n))
  {
    username=n;
    save("username");
    Msg("Name changed to "+n+".");
  }
  else
    Msg("{red}Invalid username. Names are limited to 10 characters long, and can contain letters, numbers, and _ .");
  
  n=pop();
}

HELP{"offline"}{"nick"}=("new name","change your name",NULL,
"Use this command to change your name, in case the first name you tried was unavailable. Legal usernames can be up to 10 characters long and can contain letters, numbers, and the underscore _.");

#
# CommandWho() - Implementation of /who command.
#
def CommandWho
{
  push(m);
  push(p);
  Msg("{orange}Users online:");
  for(p)(room.players)
  {
    m=p[1][0]+"@"+p[1][1];
    if(p[1][2] >= 0)
      m=m+" at table "+p[1][2];
    Msg(m);
  }
  Msg("Total: "+length(room.players)+" players.");
  p=pop();
  m=pop();
}

HELP{"chat"}{"who"}=("","show players online",NULL,
"Show a list of all players and their ip-addresses, who are currently connected to the meta server.");

#
# CommandTables() - Implementation of /tables command.
#
def CommandTables
{
  push(m);
  Msg("{orange}Tables available:");
  for(t)(room.tables)
  {
    Msg("Table "+t[0]+": "+t[1][0]+" at port "+t[1][1]+", "+t[1][5]+" players, bet $"+format("%.2f",t[1][4])+".");
    if(length(t[1]) >= 11)
      Msg("  Info: "+t[1][10]);
    if(length(t[1]) >= 10)
      Msg("  Rules: "+join(t[1][9],", "));
    m="";
    for(p)(t[1][2])
    {
      m=m+" "+room.players{p}[0];
    }
    if(m!="")
      Msg("  Players:"+m);
  }
  m=pop();
}

HELP{"chat"}{"tables"}=("","show table info",NULL,
"Show a list of game servers available. The list contains IP-addresses, ports and game parameters (number of players, bet) of each game server.");

#
# ChatCommandLeavetable() - Implementation of /leavetable command
#
def ChatCommandLeavetable
  Send("LeaveTableToChat", NULL);

HELP{"chat"}{"leavetable"}=("","leave table",NULL,
"Leave the current table you are sitting on, straight to the chat area.");

#
# ChatCommandGive(player,amount) - Implementation of /give command.
#
def ChatCommandGive
{
  if(length(ARG)==2 && toreal(ARG[1])>0)
    Send("Give",join(ARG," "));
  else if(length(ARG)<2)
    Msg("{red}You have to give something. Use {yellow}/give NAME MONEY{red} or {yellow}/give NAME CARD{red}.");
  else
  {
    push(n);
    push(i);
    n=join(tail(ARG)," ");
    if(first(n)=="'" && last(n)=="'")
      n=substr(n,1,length(n)-2);

    i=images(n);
    if(length(i)==0)
      i=fuzzy_images(n);

    if(length(i)<=0)
      Msg("{red}No such card: "+n);
    else
    {
      i=select("(book_entry(card.book,#))[0]",i);
      if(length(i)==0)
        Msg("{red}You don't have that card.");
      else if(length(i)==1)
        Send("GiveCard",(ARG[0],i[0]));
      else
      {
        Msg("{orange}Card name is not unique. Please specify one of the following:");
        Msg(join(forall('canonical_name(#)',i),"        "));
      }
    }

    i=pop();
    n=pop();
  }
}

HELP{"chat"}{"give"}=("player,what","give money or card",NULL,
"If {yellow}what{white} is a number, you give that amount of money to the other {yellow}player{white}. The other player must be online and the amount must be greater than zero. If it is a card name, you give a card instead. Other player does not need to be online.");

#
# PlayCommandLose(options) - Implementation of /lose command.
#
def PlayCommandLose
    Send("DeclareResult",("lose",join(ARG," ")));

HELP{"play"}{"lose"}=("options","declare loss",NULL,
"Declare yourself as a loser of the game. If someone has already declared the result, new declaration overrides it. Optional arguments {yellow}options{white} are game specific.");

#
# PlayCommandDraw(options) - Implementation of /draw command.
#
def PlayCommandDraw
    Send("DeclareResult",("draw",join(ARG," ")));

HELP{"play"}{"draw"}=("options","declare draw",NULL,
"Declare the result of the game to be a draw. If someone has already declared the result, new declaration overrides it. Optional arguments {yellow}options{white} are game specific.");

#
# PlayCommandWin(options) - Implementation of /win command.
#
def PlayCommandWin
    Send("DeclareResult",("win",join(ARG," ")));

HELP{"play"}{"win"}=("options","declare win",NULL,
"Declare yourself as a winner of the game. If someone has already declared the result, new declaration overrides it. Optional arguments {yellow}options{white} are game specific.");

#
# PlayCommandUndecided(options) - Implementation of /undecided command.
#
def PlayCommandUndecided
    Send("DeclareResult",("undecided",join(ARG," ")));

HELP{"play"}{"undecided"}=("","declare undefined result",NULL,
"Declare that the game is not played to the final result. If someone has already declared the result, new declaration overrides it.");

#
# PlayCommandOk() - Implementation of /ok command.
#
def PlayCommandOk
    Send("AcceptResult",NULL);

HELP{"play"}{"ok"}=("","accept result",NULL,
"Give your acceptance to the declared result. After all players have accepted the declared result, the game ends and meta server will update all game depended statistics accordingly.");

#
# CommandQuit() - Implementation of /quit command.
#
def CommandQuit
{
  if(mode=="watch")
  {
    Msg("Leaving the game.");
    SetMode("chat");
  }
  else
    quit();
}

HELP{"any"}{"quit"}=("","leave",NULL,
"If you are watching or playing, leave the game and return to the chat mode. Otherwise, save decks and other client-side data and close the server connection. After that, quit.");

#
# CommandPasswd() - Implementation of /passwd command.
#
def CommandPasswd
{
  if(find('-',username))
    Msg("{red}You cannot change your password in special mode.");
  else
  {
    push(p);
    p=join(ARG," ");
    if(p=="") 
      p=GeneratePassword();
    if(server.meta!=NULL)
    {
      SendMeta("Password",(password{username},p));
    }
    password{username}=p;
    password{username+"-sealed"}=p;
    save("password");
    Msg("Password changed locally.");
    p=pop();
  }
}

HELP{"chat"}{"passwd"}=("[newpwd]","change password",NULL,
"This command changes your password locally and also on server if connected. If you don't give one, it will generate new random password automatically.");

#
# ChatCommandNewdeck(name,of,the,deck) - Implementation of /newdeck command.
#
def ChatCommandNewdeck
    EditCreateDeck(join(ARG," "));

#
# WatchCommandNewdeck(name,of,the,deck) - Implementation of /newdeck command.
#
def WatchCommandNewdeck
    ChatCommandNewdeck(ARG);

#
# OfflineCommandNewdeck(name,of,the,deck) - Implementation of /newdeck command.
#
def OfflineCommandNewdeck
    ChatCommandNewdeck(ARG);

HELP{"chat"}{"newdeck"}=("deckname","create new deck",NULL,
"Create an empty deck with the given {yellow}deckname{white} and select it as the current deck. Opens up the deck editing list automatically. The deck is saved automatically after the editing list is closed");

#
# ChatCommandErasedeck() - Implementation of /erasedeck command.
#
def CommandErasedeck
{
  if(deck.name != NULL)
  {
    decks{deck.name}=NewDeck();
    deck.part="deck";
    RefreshCurrentDeck();
  }
}

HELP{"any"}{"erasedeck"}=("","erase deck contents",NULL,
"Remove all cards from the current decklist, leaving only an empty deck shell so you can start over.");

def CommandDeletedeck
  DeleteDeck(deck.name);

HELP{"any"}{"deletedeck"}=("","delete a deck entry",NULL,
"Delete the current deck entirely, including its entry in your list of decks.");

#
# CommandHelp(topic) - Implementation of /help command.
#
def CommandHelp
{
  push(m);
  push(i);
  m=NULL;

  if(length(ARG)==1)
  {
    push(c);
    c=ARG[0];
    if(left(c,1)=="/")
      c=substr(c,1);

    if(has_entry(c,HELP{"chat"}))
      m="chat";       
    else if(has_entry(c,HELP{"play"}))
      m="play";       
    else if(has_entry(c,HELP{"any"}))
      m="any";       

    if(m != NULL)
    {
      push(s);
      s="{orange}"+L("Synopsis:")+" {white}/"+c;
      for(a)(split(HELP{m}{c}[0],","))
      {
        if(a=="..." || left(a,1)=="[")
          s=s+" {yellow}"+a+"{white}";
        else
          s=s+" {yellow}<"+a+">{white}";
      }
      Msg(s+" - "+L(HELP{m}{c}[1])+" ("+L(ucfirst(m)+" mode")+")");
      for(m)(split(HELP{m}{c}[3],"\n"))
        Msg(L(m));
      s=pop();
    }
    c=pop();
  }

  if(m==NULL && length(ARG) > 0 && length(i=fuzzy_images(join(ARG," "))) > 0)
  {
     if(length(join(ARG," "))>=3)
     {
       for(c)(i)
       {
         push(card.number);
         card.number=c;
         KeyControlKeyH();
         card.number=pop();
       }
     }
     else
     {
       push(card.number);
       card.number=first(i);
       KeyControlKeyH();
       card.number=pop();
     }
     m="";
  }

  if(m==NULL)
  {
    Msg("{orange}Help is available for the following commands (ask help without / in the command name):");
    for(k)(keys(HELP)-("",))
    {
      m="";
      Msg("{green}"+ucfirst(k)+" mode:");
      for(c)(keys(HELP{k}))
        m=m+"/"+c+" ";
      Msg(m);
    }
  }

  i=pop();
  m=pop();
}

HELP{"any"}{"help"}=("topic","show help on topic",NULL,
"Show information about the given {yellow}topic{white}. If there are no such topic, then all card names are checked against and if a match is found, then the card data of the mathed card is shown. Without arguments, show the list of available topics.");

#
# CommandSave() - Implementation of /save command.
#
def CommandSave
{
  if(mode=="play")
  {
    SaveAll();
    Send("Command","/savegame");
  }
  else
  {
    SaveAll();
    Send("Command","/save");
  }
}

HELP{"chat"}{"save"}=("","save data",NULL,
"This command saves all client-side data to the directory ~/.gccg/Game/. It also sends an advise to the server to save all important data. On the play mode, this command is alias to {yellow}/savegame{white}.");

#
# ChatCommandCopydeck() - Implementation of /copydeck command.
#
def ChatCommandCopydeck
{
  if(deck.name != NULL && has_entry(deck.name,decks) && length(ARG)>=1)
  {
    decks{join(ARG," ")}=decks{deck.name};
    SelectDeck(join(ARG," "));
  }
}

HELP{"chat"}{"copydeck"}=("name","copy deck to new name",NULL,
"Make an exact copy of the current deck if selected and name it to {yellow}name{white}. Selects the copy as the current deck. If there are no deck selected, this command does nothing.");

#
# ChatCommandRenamedeck(new name) - Implementation of renamedeck command.
#
def ChatCommandRenamedeck
{
  if(deck.name != NULL && has_entry(deck.name,decks) && length(ARG)>=1)
  {
    push(n);
    n=join(ARG," ");
    if(has_entry(n,decks))
      Msg("{red}You already have a deck with that name.");
    else
    {
#     update group reference if applicable
      g=GroupOf(deck.name);
      if(length(g)>0)
        deck.groups{g}=(deck.groups{g}-(deck.name,))+(join(ARG," "),);
      
      decks{join(ARG," ")}=decks{deck.name};
      decks=del_entry(deck.name,decks);
      SelectDeck(join(ARG," "));
    }
    n=pop();
  }
}

HELP{"chat"}{"renamedeck"}=("name","rename deck",NULL,
"Give new {yellow}name{white} to the current deck if selected. If there is no deck selected, this command does nothing.");

#
# CommandPage() - Implementation of /page command.
#
def CommandPage
{
  ARG=toint(ARG[0]);
  if(ARG > 0 && ARG < book_last_page(card.book)+2)
    SetBookPage(ARG-1);
  else
    Msg("{red}Invalid page number.");
}

HELP{"any"}{"page"}=("page number","go to a page number",NULL,
"Flips immediately to the specified page number in the card book.");

#
# CommandFind() - Implementation of /find command.
#
def CommandFind
{

   push(i);
   push(c);
   push(p);

   if(length(ARG)>=1)
   {
     i=fuzzy_images(join(ARG," "));

     if(i==(,))
     {
       Msg("{red}No card matching '"+join(ARG," ")+"' found.");
     }
     else
     {
       c=select("book_pageof(card.book,#)!=-1",i);

       if(c==(,))
       {
         SetBookIndex("default","default");
         c=select("book_pageof(card.book,#)!=-1",i);
       }

       c=sort_fn("book_pageof(card.book,#)",c);
       p=select("book_pageof(card.book,#) > book_page(card.book)",c);

       if(p==(,))
         p=first(c);
       else
         p=first(p);

       SetBookPage(book_pageof(card.book,p));
       book_set_slot(card.book,p);

       raise(card.book);
       set_attr(card.book,"visible",1);
     }
   }
   p=pop();
   c=pop();
   i=pop();
}

HELP{"any"}{"find"}=("card_name","search for a card",NULL,
"Find a card having a name {yellow}card_name{white}. If exact name was not found, then search for cards with the name containing a text {yellow}card_name{white}. If found either way, show the collection if not already visible. Then turn to page containing the card found. If already in such page, search for the next page containing the card qualifying the search criteria.");

#
# CommandSets() - Implementation of /sets command.
#
def CommandSets
{
  if(length(ARG)>0)
  {
    push(c);
    c=images(join(ARG," "));
    if(c==(,))
    {
      c=fuzzy_images(join(ARG," "));
      if(length(c))
        c=images(name(c[0]));
    }
    if(length(c)==1)
      Msg("{gold}"+name(c[0])+"{white} only appears in "+set_of(c[0])+".");
    elseif(length(c))
      Msg("{gold}"+name(c[0])+"{white} appears in: "+join(forall('set_of(#)',c),", ")+".");
    else
      Msg("{red}Unrecognized card name.")
      
    c=pop();
  
  }
}
HELP{"any"}{"sets"}=("card_name","find a card's sets",NULL,
"Print a list of card sets in which {yellow}card_name{white} appears. If the card_name string appears in more than one possible card, it uses the first matching name.");

#
# ChatCommandRd() - Implementation of /rd command in chat mode.
#
def ChatCommandRd
{
  if(deck.name != NULL)
  {
    push(d);
    for(p)(keys(decks{deck.name}))
      decks{deck.name}{p}=sort(decks{deck.name}{p});
    d=sort(flatten(values(decks{deck.name})));
    d=sort(forall('(count(#,d),#)',unique(d)));
    SendMeta("RegisterDeck",("default",d,decks{deck.name}));
    d=pop();
  }
}

#
# ChatCommandRd2() - Implementation of /rd2 command in chat mode.
#
def ChatCommandRd2
{
  if(deck.name != NULL)
  {
    push(d);
    for(p)(keys(decks{deck.name}))
      decks{deck.name}{p}=sort(decks{deck.name}{p});
    d=sort(flatten(values(decks{deck.name})));
    d=sort(forall('(count(#,d),#)',unique(d)));
    SendMeta("RegisterDeck",("alternative",d,decks{deck.name}));
    d=pop();
  }
}

#
# ChatCommandUploaddeck() - Implementation of /uploaddeck command in chat mode.
#
def ChatCommandUploaddeck
{
  push(deck.name);
  ARG=join(ARG," ");
  
  if(ARG=="0")  
    SendMeta("RegisterDeck",("download",(,),(,)));
  else if(length(ARG) > 0)
  {
    if(has_entry(ARG,decks))
    {
      deck.name=ARG;
      ARG="";
    }
    else
      Msg("{red}You don't have a deck with that name.");
  }
  if(length(ARG)==0)
  {
    if(deck.name == NULL)
      Msg("{red}No deck selected.");
    else
    {
      push(d);
      for(p)(keys(decks{deck.name}))
        decks{deck.name}{p}=sort(decks{deck.name}{p});
      d=sort(flatten(values(decks{deck.name})));
      d=sort(forall('(count(#,d),#)',unique(d)));
      SendMeta("RegisterDeck",("download",d,decks{deck.name}));
      d=pop();
    }
  }
  
  deck.name=pop();
}

def WatchCommandRd
  ChatCommandRd();

def WatchCommandRd2
  ChatCommandRd2();

def WatchCommandUploaddeck
  ChatCommandUploaddeck();

HELP{"chat"}{"rd"}=("","register your tournament deck",NULL,
"Send the content of the current deck to the meta server for registration. The meta server stores a copy of the deck. After you have registered your deck, game servers check your game decks against the registered deck. Then reports are generated wether the game deck is identical to the registered deck and/or wether the combined parts of the game deck contains the same cards as the registered one. NOTE: The game servers do not report anything if the deck is not registered. So, it is up to the player to observe that an opponent haven't change his deck during tournament event. See also {yellow}/help ro{white}.");

HELP{"chat"}{"rd2"}=("","register your 2nd tournament deck",NULL,
"This registers the second deck for the tournement (if needed). See also {yellow}/help rd{white}.");

HELP{"chat"}{"uploaddeck"}=("[deck name]","upload a deck for review",NULL,
"This uploads your deck to the server, just like {yellow}/rd{white}. The main difference is that using this allows other players to retrieve your decklist using {yellow}/downloaddeck{reset}. If {yellow}0{reset} is provided as an optional argument, takes down your uploaded deck. Otherwise, if a deck name is provided as argument, upload that deck instead of the currently selected one.");

HELP{"chat"}{"downloaddeck"}=("user","download a deck",NULL,
"If {yellow}user{reset} has uploaded a deck for review, this will retrieve it from the server and import it as a new decklist.");

#
# CommandUnset() - Implementation of /unset command.
#
def CommandUnset
{
  if(length(ARG)==1)
  {
    options=del_entry(ARG[0],options);
    Msg("Option {green}"+ARG[0]+"{white} unset.");
    Send("Set",(ARG[0],NULL));
  }
}

HELP{"chat"}{"unset"}=("var","nullify settings",NULL,
"This command removes the current setting of {yellow}var{white}.");

#
# CommandSet() - Implementation of /set command.
#
def CommandSet
{
  push(a);
  if(length(ARG)==0)
  {
    Msg("{orange}Settings:");
    forall('b=#; Msg(b[0]+"="+tostr(b[1]))',options);
  }
  elseif(length(ARG)>=2)
  {
    a=join(tail(ARG)," ");
    if(tostr(toint(a))==a)
      a=toint(a);
    else if(a=="NULL")
      a=NULL;
    options{ARG[0]}=a;
    Msg("Setting option {green}"+ARG[0]+"{white}="+tostr(a));
    Send("Set",(ARG[0],a));
    
#   Some settings have immediate effect
    if(ARG[0]=="avatar" && a!="sleep")
    {
      avatar{username}=a;
      save("avatar");
    }    
    if(ARG[0]=="input")
    {
      if(a=="top")
        CreatePanel("input",0,0);
      else
        CreatePanel("input",0,screen.height-h(16));
    }
  }
  a=pop();
  redraw(card.book);
}

HELP{"chat"}{"set"}=("var,value","change settings",NULL,
"Without arguments, this command lists all options currently set. "
+"Otherwise it can be used to fine tune operating parameters of the client or the server. "
+"All settings are offered to the server. If the server accepts the setting, it will be stored there as well. "
+"In any case, client-side option is set to {yellow}value{white}.\n"
+"The list of client-side options:\n"
+"  {green}nosound {yellow}<s>{white} - if set to 'yes', all sounds are disabled\n"
+"  {green}noalert {yellow}<s>{white} - if set to 'yes', visual alerts are disabled\n"
+"  {green}log {yellow}<s>{white} - if set to 'yes', print messages to stdout.\n"
+"  {green}trade_limit {yellow}<n>{white} - if you own more than {yellow}n{white} copies of the given card, consider these extra cards as tradeable (default 4)\n"
+"  {green}price {yellow}'higher'/'lower'/'same'/'default'{white} - when selling first card or pressing enter, choose price according to this setting (default 'higher')\n"
+"  {green}input {yellow}<s>{white} - if set to 'top', the input bar for text will be at the top of the screen instead of the bottom\n"
+"The list of server-side options:\n"
+"  {green}avatar {yellow}<image>{white} - choose an image representing you (see graphics/avatar)\n"
+"  {green}email {yellow}<s>{white} - set your email address shown by /whois command to {yellow}s{white}\n"
+"  {green}plan {yellow}<s>{white} - set additional information in /whois output to {yellow}s{white}\n"
+"  {green}realname {yellow}<s>{white} - set your real name shown by /whois command to {yellow}s{white}\n");

#
# CommandLoadimages() - Implementation of /loadimages command.
#
def CommandLoadimages
{
  push(p);
  Msg("Loading card images...");

  set_attr(card.book,"visible",1);
  raise(card.book);

  p=book_page(card.book);
  for(i)(book_last_page(card.book)+1)
    SetBookPage(i);
  SetBookPage(p);

  Msg("Done");
  p=pop();
}

HELP{"any"}{"loadimages"}=("","load all card images",NULL,
"Normally all card images are loaded or generated on demand. This may cause unwanted delays when turning pages of the collection. This command loads all images at once.");

#
# CommandEval(code expression) - Evaluate and broadcast code.
#
def CommandEval
{
  push(m);
  m=join(ARG," ");
  E=eval(m);
  Send("Say",tostr(E));
  m=pop();
}

HELP{"any"}{"eval"}=("exp","evaluate an expression",NULL,
"This command takes an expression {yellow}exp{white} and evaluates it using gccg-script engine. The resulting value of the expression is stored to the variable {yellow}E{white} and sent as a message. The expression may contain more than one statement, in which case all but the last one needs to be followed by a semicolon.\n"
+"If you don't want to broadcast the result, use {yellow}/seval{reset} or {yellow}/neval{reset} instead.");

#
# CommandSeval(code expression) - Evaluate code, with output displayed only to self instead of as a public message.
#
def CommandSeval
{
  E=eval(join(ARG," "));
  Msg(tostr(E));
}

HELP{"any"}{"seval"}=("exp","evaluate an expression",NULL,
"This command takes an expression {yellow}exp{white} and evaluates it using gccg-script engine. The resulting value of the expression is stored to the variable {yellow}E{white} and displayed on the screen. The expression may contain more than one statement, in which case all but the last one needs to be followed by a semicolon.\n"
+"To suppress the output, use {yellow}/neval{reset}; to broadcast it to other players, use {yellow}/eval{white} instead.");

#
# CommandNeval(code expression) - Evaluate code, with no output.
#
def CommandNeval
  E=eval(join(ARG," "));

HELP{"any"}{"neval"}=("exp","evaluate an expression",NULL,
"This command takes an expression {yellow}exp{white} and evaluates it using gccg-script engine. The resulting value of the expression is stored to the variable {yellow}E{white}. The expression may contain more than one statement, in which case all but the last one needs to be followed by a semicolon.\n"
+"To see the output or show it to other players, use {yellow}/eval{reset} or {yellow}/seval{white} instead.");

#
# CommandBind(text) - Implementation of /bind command.
#
def CommandBind
{
  if(length(ARG) < 1)
  {
    if(bind != NULL)
    {
      Msg("{orange}Current line bindings:{white}");
      for(b)(bind)
        Msg(b[0]+": "+b[1]);
      Msg("{orange}Current key stroke bindings:{white}");
      for(b)(bindk)
        Msg(b[0]+": "+b[1]);
    }
  }
  else
  {
    bind_next=join(ARG," ");
    Msg("Press a key combination where to bind...");
  }
}

HELP{"any"}{"bind"}=("text","create macro and bind to key",NULL,
"Without any arguments, show a listing of all bindings. Otherwise, wait for a key press. After that, bind the given {yellow}text{white} to the key pressed. When the key with a binding is pressed, current input line is stored temporarily, the bound text is then put to the input line and return-key is pressed automatically. After that the content of the old input line is restored. See also {orange}/help bindk{white} and {orange}/help unbind{white}.");

#
# CommandBindk(text) - Implementation of /bindk command.
#
def CommandBindk
{
  if(length(ARG) < 1)
  {
    CommandBind();
  }
  else
  {
    bindk_next=join(ARG," ");
    Msg("Press a key combination where to bind...");
  }
}

HELP{"any"}{"bindk"}=("text","bind key stroke to key",NULL,
"Without any arguments, show a listing of all key stroke bindings. Otherwise, wait for a key press. After that, bind the given {yellow}text{white} to the key pressed. When the key with a binding is pressed, the bound text is appended to the input line as single key press. See also {orange}/help bind{white} and {orange}/help unbind{white}.");

#
# CommandUnbind() - Implementation of /unbind command.
#
def CommandUnbind
{
  Msg("Press a key combination to unbind...");
  unbind_next=1;
}

HELP{"any"}{"unbind"}=("","remove macro binding",NULL,
"Waits for a key press. If the key pressed has a binding (see. /bind), remove the binding.");

#
# PlayCommandLegal() - Implementation of /legal command.
#
def PlayCommandLegal
{
  Send("LegalityCheck",NULL);
}

HELP{"play"}{"legal"}=("","ask detailed legality of the deck",NULL,
"This command asks the game server to report more detailed information on the legality of the current play deck. The deck is checked against all game formats defined and the report of violations against each format is generated.");

#
# ChatCommandBuy() - Implementation of /buy command.
#
def ChatCommandBuy
{
  push(p);
  push(n);
  if(length(ARG)>0)
  {
    if(tostr(toint(ARG[0]))==ARG[0])
    {
      n=toint(ARG[0]);
      p=ProductLookup(join(tail(ARG)," "));
    }
    else
    {
      n=1;
      p=ProductLookup(join(ARG," "));
    }

    if(p==NULL)
      Msg("{red}Unknown product '"+join(ARG," ")+"'.");
    else
    {
      booster.manual_buy=1;
      Send("Buy",(n,p));
    }
  }
  n=pop();
  p=pop();
}

HELP{"chat"}{"buy"}=("n,product","buy one or more boosters",NULL,
"This command buys one or more products, which can be listed using {yellow}/products{white} command. An optional argument {yellow}n{white} determines the number of products to buy. Default is one. A product can be given as an abbreviation instead of the full set name. The set name may be followed by an optional product type specifier, which defaults to 'booster' if not given. The product names are also case insensitive.");

#
# ChatCommandGo() - Implementation of /go command.
#
def ChatCommandGo
{
  push(t);
  if(length(ARG)!=1)
    Msg("{red}You must give a single table number as argument.");
  else
  {
    t=toint(ARG[0]);
    if(tostr(t)!=ARG[0] || count(t,keys(room.tables))==0)
      Msg("{red}Invalid table number.");
    else
    {
      Send("JoinTable",t);
      Msg("You enter to the table "+t+".");
    }
  }
  t=pop();
}

HELP{"chat"}{"go"}=("table","sit down",NULL,
"This command allows you to sit down to the {yellow}table{white} given as a table number. You can check available tables using {yellow}/tables{white} command.");

#
# ChatCommandJoin() - Implementation of /join command.
#
def ChatCommandJoin
{
  if(length(ARG)!=0)
    Msg("{red}No arguments required.");
  else if(!has_entry(me,room.players))
    Msg("{red}Waiting for server chat room update...");
  else if(room.players{me}[2]==-1)
    Msg("{red}Sit down first.");
  else
  {
    Msg("Play/watch status toggled.");
    Send("ToggleJoinGame",NULL);
  }
}

HELP{"chat"}{"join"}=("","toggle play/watch status",NULL,
"Toggle your play/watch status. If you are sitting on table without the ongoing game, you will join to the game. If the number of players is sufficient, the game begins. If you join to the game that has already started, you will watch the game. This command also cancels 'ready to play' status, if already joined, but the game has not yet started.");

#
# WatchCommandInplay() - Implementation of /inplay command in watch mode.
#
def WatchCommandInplay
{
  push(c);
  push(m);
  push(n);
  Msg("{orange}Cards on table:");
  for(p)(players)
  {
    c=sort(name(card(inplay(p))));
    m="";
    while(length(c))
    {
      if(m!="")
        m=m+", ";
      n=count(first(c),c);
      if(n > 1)
        m=m+n+"x ";
      m=m+first(c);
      c=right(c,length(c)-n);
    }
    Msg("{green}"+player.name{p}+":{white} "+m);
  }
  n=pop();
  m=pop();
  c=pop();
}

#
# PlayCommandInplay() - Implementation of /inplay command in play mode.
#
def PlayCommandInplay
  WatchCommandInplay();

HELP{"play"}{"inplay"}=("","list cards on table",NULL,
"List all cards on table sorted by the owner of the card.");
HELP{"watch"}{"inplay"}=HELP{"play"}{"inplay"};

#
# ChatCommandSu() - Implementation of /su command.
#
def ChatCommandSu
{
  if(length(ARG)==1)
  {
    if(!ValidUsername(ARG[0]))
      Msg("{red}Invalid username.");
    else if(!has_entry(ARG[0],password))
      Msg("{red}You don't have a password.");
    else
    {
      if(get_attr(card.book,"visible"))
        set_attr(card.book,"visible",0);
      ClearCardBook();
      Send("ReRegisterPlayer",(ARG[0],VERSION,database.cards,GAME,password{ARG[0]},SYSTEM,eval("ser"+"ial")));
    }
  }
}

HELP{"chat"}{"su"}=("user","change user",NULL,
"This command closes current session and begins new one with a player account {yellow}user{white}. You must have already registered the account.");

#
# ChatCommandSealed() - Implementation of /sealed command.
#
def ChatCommandSealed
{
  if(length(ARG)==0)
  {
     if(right(username,7)=="-sealed")
     {
       Send("Sealed",("sealed","off",NULL,(,)));
     }
     else
     {
       Send("Sealed",("sealed","on",NULL,(,)));
     }
     if(get_attr(card.book,"visible"))
       set_attr(card.book,"visible",0);
     ClearCardBook();
  }
  else if(length(ARG)==1)
  {
    if(ARG[0]=="end")
    {
      Send("Sealed",("sealed","end",NULL,(,)));
    }
    else if(right(username,7)!="-sealed")
    {
      n=toreal(ARG[0]);
      password{username+"-sealed"}=password{username};
      save("password");
      Send("Sealed",("sealed","start",n,(,)));
    }
    for(b)(books)
    {
      if(get_attr(b,"visible"))
        set_attr(b,"visible",0);
    }
    ClearCardBook();
  }
  else
    Msg("{red}Invalid arguments.");
}

HELP{"chat"}{"sealed"}=("args","play sealed deck",NULL,
"The sealed deck game is based on alter egos of players. To initiate an sealed deck event, you must first transfer an amount of money to the sealed deck alter ego of your player character. This is accomplished by the command {yellow}/sealed <n>{white}, where {yellow}<n>{white} is the amount of money to start with. Tha cards and money already owned by the sealed deck alter ego, is not lost. The money is added to instead. The command also switches to the sealed deck character immediately. If you want to switch between your normal character and the sealed deck character, you can say {yellow}/sealed{white} without any arguments. To transfer all cards and money back to your main character, say {yellow}/sealed end{white}.");

#
# ChatCommandDraft() - Implementation of /draft command.
#
def ChatCommandDraft
{
  if(length(ARG)==0)
  {
     if(right(username,6)=="-draft")
     {
       Send("Sealed",("draft","off",NULL,(,)));
     }
     else
     {
       Send("Sealed",("draft","on",NULL,(,)));
     }
     if(get_attr(card.book,"visible"))
       set_attr(card.book,"visible",0);
     ClearCardBook();
  }
  else if(length(ARG)==1)
  {
    if(ARG[0]=="end")
    {
      Send("Sealed",("draft","end",NULL,(,)));
    }
    else if(right(username,7)!="-draft")
    {
      n=toreal(ARG[0]);
      password{username+"-draft"}=password{username};
      save("password");
      Send("Sealed",("draft","start",n,(,)));
    }
    for(b)(books)
    {
      if(get_attr(b,"visible"))
        set_attr(b,"visible",0);
    }
    ClearCardBook();
  }
  else
    Msg("{red}Invalid arguments.");
}

HELP{"chat"}{"draft"}=("args","play draft deck",NULL,
"The draft game is based on alter egos of players. To initiate a draft, you must first transfer an amount of money to the draft alter ego of your player character. This is accomplished by the command {yellow}/draft <n>{white}, where {yellow}<n>{white} is the amount of money to start with. Tha cards and money already owned by the draft alter ego, is not lost. The money is added to instead. The command also switches to the draft character immediately. If you want to switch between your normal character and the draft character, you can say {yellow}/draft{white} without any arguments. To transfer all cards and money back to your main character, say {yellow}/draft end{white}.");

#
# CommandNewuser() - Implementation of /newuser command.
#
def CommandNewuser
{
  if(username!="")
    Msg("{red}You are already chosen your initial user account. Use {yellow}/su <your_name>{red} instead.");
  else
  {
    username=join(ARG," ");
    if(!ValidUsername(username))
    {
      Msg("{red}Invalid username. Must be 2..10 letters alphanumeric characters.");
      username="";
    }
    else
    {
      Msg("{green}{sz20}Your user name is now {yellow}"+username+"{green}.");
      Msg("{green}{sz20}Please quit (Ctrl+Q or /quit) and restart the game.");
      save("username");
    }
  }
}

HELP{"chat"}{"default"}=("r,p","set default price by rarity",NULL,
"When selling a card first time without any competing offer, the price of the card is set to the default value. Each rarity has it's own default price, which is set when you sell the first card having the rarity in question. At that time you set the initial default value using number pad and enter. After that you can set the price {yellow}p{white} as default for rarity {yellow}r{white} using this command. Without arguments, this command lists current default prices by rarity. ");

#
# ChatCommandDefault() - Implementation of /default command.
#
def ChatCommandDefault
{
  if(length(ARG)==0)
  {
    push(m);
    m="";
    for(p)(price.default)
      m=m+"  "+p[0]+" - $"+format("%.2f",p[1]);
    Msg("{orange}Default prices by rarity:");
    Msg(m);
    m=pop();
  }
  else if(length(ARG)==2)
  {
    push(r);
    push(p);
    r=uc(ARG[0]);
    p=toreal(format("%.2f",toreal(ARG[1])));
    if(p < 0.0)
      Msg("{red}Cannot use negative price.");
    else
    {
      price.default{r}=p;
      ChatCommandDefault((,));
      Msg("Default price for "+r+" set to $"+format("%.2f",p));
    }
    p=pop();
    r=pop();
  }
  else
    Msg("{red}Invalid arguments.");
}

HELP{"any"}{"select"}=("exp","select cards to display",NULL,
"You can refine your collection view by applying subsequent selects. Each select expression checks every card from the current display and drops those cards not matching the filter expression {yellow}exp{white}. The filter expression is one of the following:\n  {yellow}<e1>{green} rel {yellow}<e2>{white} - comparison where {green}rel{white} is {yellow}={white}, {yellow}>{white}, {yellow}<{white}, {yellow}!={white}, {yellow}<={white} or {yellow}>={white}\n  {yellow}<e1>{green} op {yellow}<e2>{white} - mathematical expression where {green}op{white} is {yellow}+{white}, {yellow}-{white}, {yellow}*{white}, or {yellow}/{white}\n  {green}({yellow}e{green}){white} - parenthesis alters precedence\n  {yellow}<e1>{green} has {yellow}<e2>{white} - true if {yellow}e2{white} is a substring of {yellow}e1{white} (comparison case independent)\n  {green}not {yellow}<e>{white} - negate expression {yellow}e{white}\n  {yellow}<e1>{green} and {yellow}<e2>{white} - true if both expressions are true\n  {yellow}<e1>{green} or {yellow}<e2>{white} - true if either expressions is true\n  {yellow}<attr>{white} - "

+join(forall('"{green}"+#+"{white}"',head(attributes())),", ")+" or {green}"+last(attributes())

+"\n  {yellow}<n>{white} - an integer"
+"\n  {green}\"{yellow}<str>{green}\"{white} - a string"
+"\n  {green}name{white} - a card name"
+"\n  {green}set{white} - an abbrevation of the set"
+"\n  {green}text{white} - card text"
+"\n  {green}have{white} - number of copies you own"
+"\n  {green}want{white} - number of copies you want"
+"\n  {green}sell{white} - number of copies you have for sale"
+"\n  {green}deck{white} - number of copies in the current deck"
+"\n  {green}seller{white} - name of the seller with lowest price"
+"\n  {green}price{white} - price of the card"
+"\n  {green}myprice{white} - price of the card set by me"
+"\n  {green}pwant({yellow}player{green}){white} - wanted by {yellow}player{white} (must use {cyan}/want {yellow}player{white} first)"
+"\n  {green}phave({yellow}player{green}){white} - sold by {yellow}player{white} (must use {cyan}/have {yellow}player{white}) first)"
+"\n"
);

#
# CommandSelect() - Implementation of /select command.
#
def CommandSelect
{
  if (length(ARG) == 0)
    SetBookIndex('default','default');
  else {
    push(f);
    f=String2Filter(join(ARG," "));
    if(f==NULL)
      Msg("{red}Invalid filter expression.");
    else
      RefineFilter(f);
    f=pop();
  }
}

HELP{"any"}{"sort"}=("[n],k1,k2,...","sort display",NULL,
"Sort the collection view according to one or more sort keys {yellow}k1{white}, {yellow}k2{white}, etc. Each key can be: a card attribute, {green}age{white} as age of the set, {green}name{white} as name of the card, or {green}set{white} as name of the set.\n"+
"The valid card attributes are "+

join(forall('"{green}"+#+"{white}"',head(attributes())),", ")+" and {green}"+last(attributes())

+"{white}.\nBy default, the value of the key {yellow}k1{white} is taken as subtitles for the display. You can discard all subtitles by giving an optional argument {yellow}n{white} with value {green}0{white}. A positive value {yellow}n{white} adds more levels to the subtitle resolution.\n"+
"You can also put a {yellow}#{white} character in front of a sort key to treat values as numbers instead of text (for example, a value of {yellow}9{white} will come earlier than {yellow}10{white}), or a {yellow}-{white} sign to sort in reverse order. See also {orange}/help select{white} and {orange}/help display{white}.");

#
# CommandSort() - Implementation of /sort command.
#
def CommandSort
{
  push(s);
  s=NULL;
  if(tostr(toint(first(ARG)))==first(ARG))
  {
    push(t);
    t=toint(first(ARG));
    if(t < 0 || t >= length(ARG))
       Msg("{red}Invalid title depth.");
    else
      s=(t,)+String2Sorting(join(tail(ARG)," "));
    t=pop();
  }
  else
    s=String2Sorting(join(ARG," "));

  if(s==NULL)
    Msg("{red}Invalid sorting expression.");
  else
    SetBookIndex(CurrentFilter(),s);
  s=pop();
}

HELP{"any"}{"display"}=("name","name current display",NULL,
"When you have filtered and sorted your own custom display, you can save it for later use with this command. The name of the new custom display appears in the display selection list. If you want to destroy this display later, you can choose \"Destroy this display\" from the collection menu while the display is selected. See also {orange}/help select{white} and {orange}/help sort{white}.");

#
# CommandDisplay() - Implementation of /display command.
#
def CommandDisplay
{
  push(n);
  n=join(ARG," ");
  if(n!="")
  {
    book.my_filters=book.my_filters+(((n,)+(CurrentFilter(),CurrentSorting())+(book.filter{CurrentFilter()}==NULL,)),);
    Msg("Current index stored as display '"+n+"'.");
  }
  n=pop();
}

#
#  PLAY MODE
#  =========

#
# Owner(object number) - return player number of the owner of the object or NULL.
#
def Owner
{
  if(ARG!=NULL)
  {
    push(p);
    push(i);
    if(ARG==search.box)
      return(Owner(search.source));
    else if(find(ARG,hand)!=NULL)
      return(find(ARG,hand));
    else if(find(ARG,active)!=NULL)
      return(find(ARG,active));
    else if(count(ARG,inplay()))
      return(first(card_data(ARG)));
    else
    {
      for(p)(players)
      {
        for(i)(deck.objects[p])
        {
          if(i[1]==ARG)
            return(p);
        }
      }
    }
    i=pop();
    p=pop();
  }
}

#
# DeckName(internal name) - Return human readable version of a deck name.
#
def DeckName
{
  if(has_entry(ARG[2],deck_name))
    return(deck_name{ARG[2]});
  else
    return(ARG[2]);
}

#
# MyDeck(deck name) - Return object number of the deck.
#
def MyDeck
{
  return(deck.objects[me]{ARG});
}

#
#  CreateDeck(object num,owner player,name,(x,y)) - Create a deck.
#
def CreateDeck
{
  del_object(ARG[0]);

  create_deck(ARG[3][0]-card.deck.width/2,ARG[3][1]-card.deck.height/2,ARG[0],ARG[2]);
  set_textsize(ARG[0],9);
  set_textfont(ARG[0],2);
  add_text(ARG[0],"{shadow}"+ucfirst(DeckName(left(ARG,3))));
  add_text(ARG[0],"{shadow}("+player.name{ARG[1]}+")");
  raise(ARG[0]);

  if(deck.objects[ARG[1]]==NULL)
    deck.objects[ARG[1]]=(,);

  deck.objects[ARG[1]]{ARG[2]}=ARG[0];
  deck.class{ARG[0]}=ARG[2];

  if(ARG[2]=="deck")
    deck=ARG[0];
  elseif(ARG[2]=="discard pile")
    discard=ARG[0];

  if(isfunction("CreateDeckHook"))
    call("CreateDeckHook",ARG);
}

#
# GameSetup(my player number,total players,list of player names) - Set
#   the number of players, my playernumber and list of player names.
#
def GameSetup
{
  me=ARG[0];
  players=ARG[1];
  player.name=ARG[2];
  player.icon=(,);
}

#
# Score(player, score structure) - Set the current score for player.
#
def Score
{
  score.raw[ARG[0]]=ARG[1];
  if(isfunction("ScoreHook"))
    ScoreHook(ARG[0],ARG[1]);
  SetScore(ARG[0],ScoreToText(ARG[1]));
}

#
#  CreateHand(object num,owner player,object name,(x,y)) - Create a hand.
#
def CreateHand
{
  del_object(ARG[0]);
  push(y);
  y=ARG[3][1]-10;
  if(ARG[1]==me)
    y=y-220;

  hand[ARG[1]]=create_hand(ARG[3][0]-10,y,ARG[0],ARG[2]);
  set_attr(hand[ARG[1]],"ontop",Z_HAND);
  raise(hand[ARG[1]]);

  if(ARG[1]!=me)
    set_attr(ARG[0],"tiny",1);
  else
  {
#   create vertical buffer space so "Revealed" message will show cleanly
    add_text(ARG[0]," ");
    add_text(ARG[0]," ");
  }

  y=pop();
}

#
#  CreateActive(object num,owner player,name) - Create active set.
#
def CreateActive
{
  push(x);
  push(y);

  del_object(ARG[0]);

  if(ARG[1]==me)
  {
    x=screen.width/2;
    y=screen.height/2-card.height;
  }
  else
  {
    x=screen.width/2;
    y=screen.height/2-card.height-ARG[1]*card.height/5;
  }

  active[ARG[1]]=create_cardbox(x,y,ARG[0],ARG[2]);
  set_attr(ARG[0],"compact",1);
  set_fgcolor(ARG[0],(0,200,4));
  set_attr(ARG[0],"highlight",1);
  set_attr(ARG[0],"ontop",Z_SETASIDE);
  raise(ARG[0]);
  y=pop();
  x=pop();
}

#
#  CreatePlayerIcon(object num,player name,(x,y)) - Create player icon.
#
def CreatePlayerIcon
{
  push(x);
  push(y);
  push(i);

  x=first(table2screen(ARG[2]));
  y=last(table2screen(ARG[2]));
  del_object(ARG[0]);
  player.icon{ARG[1]}=ARG[0];

  if(mode=="playback")
  {
    LoadAvatar("goldskull");
    create_image(x - 16,y - 16,ARG[0],avatar.image{"goldskull"},ARG[1]);
  }
  else
    create_image(x - 16,y - 16,ARG[0],avatar.image{avatar.name{ARG[1]}},ARG[1]);

  set_attr(ARG[0],"clickable",1);
  set_attr(ARG[0],"draggable",1);
  set_attr(ARG[0],"ontop",Z_MBOX);
  add_text(ARG[0],"{font4}{sz10}{shadow}"+ARG[1]);
  set_textalign(ARG[0],0);
  set_textvalign(ARG[0],2);
  set_textmargin(ARG[0],0);
  raise(ARG[0]);

  i=pop();
  y=pop();
  x=pop();
}

#
# ReplaceTable(object,card) - Replace card on table with new card image.
#
def ReplaceTable
{
  push(c);
  c=card(ARG[0]);
  change_card(ARG);
  if(isfunction("ReplaceTableHook"))
    call("ReplaceTableHook",(ARG[0],ARG[1],c));
  c=pop();
}

#
# Msg(s) - Print message without time stamp.
#
def Msg
{
  message(msg.box,"{reset}"+ARG);
}

#
# MsgChat(s) - Print message without time stamp in watch mode chat box.
#
def MsgChat
{
  message(chat_msg.box,"{reset}{sz9}"+ARG);
}

#
# Message(s) - Print a string s as a message.
#
def Message
{
  push(m);
  push(c);
  m=NULL;

  if(typeof(ARG)=="string")
    m=L(ARG);
#  m=ARG;

  elseif(typeof(ARG)=="list")
  {
    if(length(ARG)>1 && length(ARG)<=3)
      m=L(ARG);
#    m=ARG;
  }

  if(m==NULL)
    Msg("{red}Server sent invalid message "+tostr(ARG)+".");
  else
  {
    m=split(m,"#");
    if(length(m)==3)
    {
      c=toint(m[1]);
      if(ValidCardNumber(c))
        m=m[0]+canonical_name(c)+m[2];
      else
        m=join(m,"#");
    }
    else
      m=join(m,"#");

    if(isfunction("MessageHook"))
      m=MessageHook(m);

    if(con==server.meta)
    {
      to_msg = 0;
      hilight = 0;

      if(pm_name != NULL)
      {
        if(find("{red}No player '"+pm_name+"'",m)==0 || left(m,30)=="{red}Invalid command /whisper ")
          EndPMSession();
      }
      
      if(left(m,6)=="{blue}")
      {
        to_msg = 1;
        if(find(username+" receives",m)==6)
          hilight=1;
      }
      elseif(left(m,23)=="{gold}* you whisper to ")
      {
        to_msg = 1;
        hilight = 1;
      }
      elseif(left(m,6)=="{gold}" && find("whispers:",m))
      {
        to_msg = 1;
        hilight = 2;
      }
      elseif(mode=="chat")
      {
        to_msg = 1;
        
        if(find(uc((split(username,"-"))[0]),uc(m))!=NULL)
        {
          if(substr(m,8,length(username))!=username || left(m,8)=="Welcome ")
            hilight = 2;
          elseif(find(": ",m))
            if(find((split(m,": "))[1],forall("(#)[1][0]",room.players))!=NULL)
              hilight = 1;
        }
      }
      else
      {
        hilight = 1;
      }
      
      if(to_msg)
        Msg(left(time(),5)+" "+m+"{reset}");
      if(hilight)
        MsgChat(left(time(),5)+" "+m+"{reset}");
      if(hilight == 2)
        InitVisualAlert();
    }
    else
      Msg(left(time(),5)+" "+m+"{reset}");
  }

  if(m!=NULL && options{"log"}=="yes")
    println(date()+" "+time()+" "+m);

  c=pop();
  m=pop();
}

#
# PutDeckTop(object number,card number(s),[real cards]) - Put one or more cards to the top of the deck.
#
def PutDeckTop
{
  PlaySound(sounds.card_pickup);
  
  if(deck_content{ARG[0]}==NULL)
    deck_content{ARG[0]}=(,);

  if(length(ARG[1])==-1)
  {
    if(length(ARG)>=3)
      deck_content{ARG[0]}=deck_content{ARG[0]}+(ARG[2],);
    else
      deck_content{ARG[0]}=deck_content{ARG[0]}+(ARG[1],);
  }
  else
  {
    if(length(ARG)>=3)
      deck_content{ARG[0]}=deck_content{ARG[0]}+ARG[2];
    else
      deck_content{ARG[0]}=deck_content{ARG[0]}+ARG[1];
  }

  put_deck_top(ARG[0],ARG[1]);
  if(search.source==ARG[0])
    ClearSearchbox();

  if(isfunction("PutDeckHook"))
    call("PutDeckHook",(ARG[0],deck.class{ARG[0]},ARG[1]));
}

#
#  PutDeckBottom(object number,card number(s),[real cards]) - Put
#     card(s) to the bottom of the deck.
#
def PutDeckBottom
{
  PlaySound(sounds.card_pickup);
  
  if(deck_content{ARG[0]}==NULL)
    deck_content{ARG[0]}=(,);

  if(length(ARG[1])==-1)
  {
    if(length(ARG)>=3)
      deck_content{ARG[0]}=(ARG[2],)+deck_content{ARG[0]};
    else
      deck_content{ARG[0]}=(ARG[1],)+deck_content{ARG[0]};
  }
  else
  {
    if(length(ARG)>=3)
      deck_content{ARG[0]}=ARG[2]+deck_content{ARG[0]};
    else
      deck_content{ARG[0]}=ARG[1]+deck_content{ARG[0]};
  }

  put_deck_bottom(ARG[0],ARG[1]);
  if(search.source==ARG[0])
    ClearSearchbox();

  if(isfunction("PutDeckHook"))
    call("PutDeckHook",(ARG[0],deck.class{ARG[0]},ARG[1]));
}

#
#  PutHand(player number, card[, card 2...]) - Put cards to a player's hand.
#
def PutHand
{
  push(c);
  PlaySound(sounds.card_pickup);
  for(c)(tail(ARG))
    put_hand(hand[ARG[0]],c);
  c=pop();
}

#
#  PutActive(player number, card[, card 2...]) - Put a card to the player's active set.
#
def PutActive
{
  PlaySound(sounds.card_pickup);
  put_cardbox_recenter(active[ARG[0]],tail(ARG));
}

#
# PutTable(object number,x,y,orientation,card number,player,real card number) - Put
#   a card owned by player using object number to the table
#   centered at (x,y) using the given orientation. Real card number can be
#   different than card number, if card is placed face down.
#
def PutTable
{
# calling PlayCardSound (and thus card_sound) on an unknown card CRASHES gccg, so don't do it
  if(name(ARG[4]) != NULL && options.game{"PutTableHook"}!="off")
	PlayCardSound(ARG[4],ARG[6]);
  
  put_inplay(ARG[0],ARG[1],ARG[2],ARG[3],ARG[6],ARG[5]);
  if(ARG[6]!=ARG[4])
    change_card(ARG[0],ARG[4]);

# in use cases where a card is given to us automatically, we have no control over coordinates
# so don't reserve a group stack for it
  if(ARG[5]==me && awaiting_card)
  {
    PutCardInGroup(ARG[6],ARG[0],ARG[1],ARG[2]);
    awaiting_card=0;
  }
  if(options.game{"PutTableHook"}!="off" && isfunction("PutTableHook"))
    PutTableHook(ARG);
  if(lottery.started)
  {
    push(c);
    push(n);
    c=ARG[6];
    if(c)
    {
       Say("It is "+lottery{c}[0]+"!!!");
       Send("DelMarker",(lottery{c}[2],0,1));
       Send("Transfer", (1, ("table", ARG[0]), ("deck.top",discard)));
       lottery{c}[1]=lottery{c}[1]-1;
       Say("There are "+lottery{c}[1]+" lottery tickets left for "+lottery{c}[0]);
       if(lottery{c}[1]<=0)
       {
         Say("ELIMINATED!");
         Send("Transfer", (1, ("table", lottery{c}[2]), ("out.of.play",)));
       }
    }
    n=pop();
    c=pop();
  }
}

#
#  DelDeckTop(object number) - Remove top card of the deck.
#
def DelDeckTop
{
  if(isfunction("DelDeckHook"))
    call("DelDeckHook",(ARG,deck.class{ARG},last(deck_content{ARG}),length(deck_content{ARG})-1));
  del_deck_top(ARG);
  deck_content{ARG}=head(deck_content{ARG});
}

#
#  DelDeckBottom(object number) - Remove bottom card of the deck.
#
def DelDeckBottom
{
  if(isfunction("DelDeckHook"))
    call("DelDeckHook",(ARG,deck.class{ARG},first(deck_content{ARG}),length(deck_content{ARG})-1));
  del_deck_bottom(ARG);
  deck_content{ARG}=tail(deck_content{ARG});
}

#
# DelActive(player,i) - Delete card from the active set.
#
def DelActive
{
  del_cardbox_recenter(active[ARG[0]],ARG[1]);
}

#
# DelDeck(object number,i) - Remove the card at position i from the deck.
#
def DelDeck
{
  if(isfunction("DelDeckHook"))
    call("DelDeckHook",(ARG[0],deck.class{ARG[0]},deck_content{ARG[0]}[ARG[1]],ARG[1]));
  del_deck(ARG[0],ARG[1]);
  deck_content{ARG[0]}=index(deck_content{ARG[0]},seq(0,length(deck_content{ARG[0]})-1) - (ARG[1],));
}

#
# DelHand(player number,i) - Remove the card at position i
#   from the player's hand.
#
def DelHand
{
  del_hand(hand[ARG[0]],ARG[1]);
}

#
# Raise(object number) - Raise an object.
#
def Raise
{
  raise(ARG);
}

#
# Lower(object number) - Lower an object.
#
def Lower
{
  lower(ARG);
}

#
# MoveObject(n,x,y) - Move object number 'n' to (x,y).
#
def MoveObject
{
  if(object_type(ARG[0])=="cardinplay")
    move_object(ARG);
  else
  {
    push(x);
    push(y);
    push(w);
    push(h);
    w=object_data(ARG[0]);
    h=w[3];
    w=w[2];
    x=table2screen(ARG[1],ARG[2]);
    y=x[1];
    x=x[0];
    move_object(ARG[0],x-w/2,y-h/2);
    h=pop();
    w=pop();
    y=pop();
    x=pop();
  }
}

#
# _StartGame() - Initialize a game.
#
def _StartGame
{
  targeting_queue=(,);
  deck_content=(,);
  if(players > 1)
    PlaySound(sounds.start);
  StartGame();
  flag.playing=1;
  awaiting_card=0;
  options.game=(,);
}

#
# DelTable(object number) - Remove a card with 'object number' from the table.
#
def DelTable
{
  push(c);
  c=card_data(ARG);
  if(typeof(c)=="list")
  {
    if(c[0]==me)
      DelCardInGroup(ARG);
  }
  del_object(ARG);

  if(isfunction("DelTableHook"))
    call("DelTableHook",ARG);

  c=pop();
}

#
# DeckDelTable(object number) - Remove a pile with 'object number' from the table.
#
def DeckDelTable
{
  push(o);
  o=find(ARG,flatten(deck.objects));
  if(o>0 && o%2)
    set_attr(ARG,"visible",0);
  o=pop();
}

#
# Rotate(object number, [object number 2, etc.,] orientation degrees) - Rotate an object.
#
def Rotate
{
  push(c);
  if(last(ARG)==90)
    for(c)(head(ARG))
      tap(c);
  if(last(ARG)==0)
    for(c)(head(ARG))
      untap(c);
  if(last(ARG)==180)
    for(c)(head(ARG))
      invert(c);
  if(last(ARG)==270)
    for(c)(head(ARG))
      tap_left(c);
  c=pop();
}

#
# SetActive(player number, card list) - Set content of the active set.
#
def SetActive
{
  repeat(length(cardbox(active[ARG[0]])),"del_cardbox_recenter(active[ARG[0]],0)");
  forall("put_cardbox_recenter(active[ARG[0]],#)",ARG[1]);
}

#
# SetHand(player number, card list) - Set hand content.
#
def SetHand
{
  push(e);
  e=0;

  if(!get_attr(hand[ARG[0]],"tiny"))
  {
# if the hand started out face-down and expanded, you've willfully asked for it to be that way
# so don't shrink even if it remains face-down afterwards (probably because of a shuffle)
    for(c)(hand(hand[ARG[0]]))
    {
      if(card_back(c)==c)
       e=1;
    }
  }
  repeat(length(hand(hand[ARG[0]])),"del_hand(hand[ARG[0]],0)");
  forall("put_hand(hand[ARG[0]],#)",ARG[1]);
  if(ARG[0]!=me)
  {
    push(d);
    push(n);
# if someone else's hand contains face up cards, clearly it should be expanded so we can see them
    for(c)(ARG[1])
    {
      if(card_back(c)!=c)
       e=1;
    }

    d=object_data(hand[ARG[0]]);

    if(!e)
    {
      set_attr(hand[ARG[0]],"tiny",1);
      n=object_data(hand[ARG[0]]);
      if(d[0] > screen.width/2 && d[0]+(d[2]-n[2])+n[2] < screen.width)
        move_object(hand[ARG[0]],d[0]+(d[2]-n[2]),d[1]);
    }
    else
    {
      set_attr(hand[ARG[0]],"tiny",0);
      n=object_data(hand[ARG[0]]);
      if(n[0]+n[2] > screen.width)
         move_object(hand[ARG[0]],d[0]-(n[2]-d[2]),d[1]);
    }
    n=pop();
    d=pop();
  }
  e=pop();
}

#
#  SetDeck(object number, card list, [identity of cards]) - Set deck content.
#
def SetDeck
{
  if(isfunction("clear_deck"))
    clear_deck(ARG[0]);
  else
    repeat(length(deck(ARG[0])),"del_deck_top(ARG[0])");

  
  if(length(ARG)>=3)
    deck_content{ARG[0]}=ARG[2];
  else
    deck_content{ARG[0]}=ARG[1];
    
  put_deck_top(ARG[0],ARG[1]);
  
  if(isfunction("PutDeckHook"))
    call("PutDeckHook",(ARG[0],deck.class{ARG[0]},ARG[1]));
}

#
#  SetDeckTop(object number,card number) - Change the top card of a deck.
#
def SetDeckTop
{
  del_deck_top(ARG[0]);
  put_deck_top(ARG[0],ARG[1]);
  deck_content{ARG}=head(deck_content{ARG})+(ARG[1],);
}

#
#  TryTransferTo(e) - Check the object under cursor and send transfer request to destination 'e' if the object was recognized.
#
def TryTransferTo
{
  push(d);
  push(s);

  d=ARG;
  s=NULL;

  if(isfunction("TryTransferHook"))
    d=call("TryTransferHook",d);

  if(d[0]!="table" && object.type=="card")
  {
    s=("table",object.number);
  }
  elseif(object.type=="hand")
  {
    s=("hand",Owner(object.number),hand.card_index);
  }
  elseif(object.type=="deck")
  {
    ClearSearchbox();
    s=("deck.top",object.number);
  }
  elseif(object.type=="bottomdeck")
  {
    ClearSearchbox();
    s=("deck.bottom",object.number);
  }
  elseif(object.type=="cardbox" && count(object.number,active))
  {
    s=("active",Owner(object.number),cardbox.card_index);
  }
  elseif(d[0]!="active" && object.number==active[me])
  {
    s=("active",me,cardbox.card_index);
  }
  elseif(d[0]!="search.box" && cardbox.card_index >=0 && object.number==search.box)
  {
    s=("deck",search.source,cardbox.card_index);
    del_cardbox_recenter(search.box,cardbox.card_index);
  }
  else if(object.number==select.box && select.source!=NULL)
  {
    s=first(forall(select.source,card.number));
    del_cardbox_all_recenter(select.box);
    set_attr(select.box,"visible",0);
    if(isfunction("PlayFromSelectionHook"))
      call("PlayFromSelectionHook",NULL);
  }

  if(s!=NULL)
  {
    if(IMMOBILE_CARDS==NULL)
      IMMOBILE_CARDS=(,);

    if(find(card.number,IMMOBILE_CARDS)==NULL)
    {
      if(transfer.options!=(,))
        Send("Transfer",(1,s,d,transfer.options));
      else
        Send("Transfer",(1,s,d));
    }
  }

  transfer.options=(,);

  s=pop();
  d=pop();
}

#
# SearchDeck(L) - Set search box content to 'L'.
#
def SearchDeck
{
  raise(search.box);
  del_cardbox_all_recenter(search.box);
  put_cardbox_recenter(search.box,ARG);
}

#
# ClearSearchbox() - Clear content of the search box.
#
def ClearSearchbox
{
  del_cardbox_all_recenter(search.box);
  search.source=NULL;
}

#
# AddMarker(object number,marker type,[count]) - Add a marker to the object.
#
def AddMarker
{
  if(length(ARG)>=3)
  {
    if(ARG[2]>0)
    {
      PlaySound(sounds.multiple_token);
      repeat(toint(ARG[2]),'add_marker(ARG[0],ARG[1])');
    }
  }
  else
  {
    PlaySound(sounds.single_token);
    add_marker(ARG);
  }

  if(isfunction("AddMarkerHook"))
    call("AddMarkerHook",ARG); 
}

#
# DelMarker(object number,marker type,[count]) - Delete a marker from the object.
#
def DelMarker
{
  if(length(ARG)>=3)
  {
    if(ARG[2]>0)
    {
      PlaySound(sounds.multiple_token);
      repeat(toint(ARG[2]),'del_marker(ARG[0],ARG[1])');
    }
  }
  else
  {
    PlaySound(sounds.single_token);
    del_marker(ARG);
  }

  if(isfunction("DelMarkerHook"))
    call("DelMarkerHook",ARG); 
}

#
# Attach(src object number, target object number) - Attach an object
#   to another.
#
def Attach
{
  attach(ARG);
}

#
# Detach(object number) - Detach an object.
#
def Detach
{
  detach(ARG);
}

#
# Play(card number,face down?) - call appropriate functions to play a card.
#
def Play
{
  push(s);
  push(found);

  found=0;

# cards with no alphanumeric characters in name need a special exemption to avoid an infinite loop
  if(length(tofnc(name(ARG[0]))) > 0 && isfunction("Play"+tofnc(name(ARG[0]))))
    call("Play"+tofnc(name(ARG[0])),ARG);
  else
  {
     if(ARG[1]==0)
     {
       for(a)(game.data{"play"})
       {
         s=card_attr(a,ARG[0]);
         if(s!=NULL && s!="" && isfunction("Play"+tofnc(s))) 
         {
           call("Play"+tofnc(s),ARG);
           found=1;
         }
       }
     }

    if(!found)
      PlayCard(ARG);
  }

  found=pop();
  s=pop();
}

#
# PlayCard(card number,face down?) - Default handler for playing card on table.
#
def PlayCard
{
  push(a);

  if(isvar("rules.category"))
    a=FindSpace(ARG[0],0,ARG[1]);
  else
    a=(BASE_TABLE_WIDTH/2+random(seq(-20,20)),random(seq(-20,20)));

  Send("Transfer",(1,("play",ARG[0],ARG[1]),("table",a[0]+card.width*50/w(100),a[1]+card.height*50/h(100),0,ARG[1])));

  awaiting_card=1;
  a=pop();
}

#
# IsStayTapped(object) - Return 1 if object has stay-tapped flag set.
#
def IsStayTapped
{
  return(has_text(ARG,STRING_KEEP_TAPPED));
}

#
# IsStayUntapped(object) - Return 1 if object has stay-untapped flag set.
#
def IsStayUntapped
{
  return(has_text(ARG,STRING_KEEP_UNTAPPED));
}


#
# SetStayTapped() - Set stay-tapped flag for card under the mouse.
#
def SetStayTapped
{
  if(object.type=="card")
  {
    if(!IsStayTapped(object.number))
    {
      if(!tapped(object.number))
        MouseMiddleClick();
      add_text(object.number,STRING_KEEP_TAPPED);
    }
  }
}

#
# UnsetStayTapped() - Clear stay-tapped flag for card under the mouse.
#
def UnsetStayTapped
{
  if(IsStayTapped(object.number))
  {
    if(object.type=="card")
      del_text(object.number,STRING_KEEP_TAPPED);
  }
}

#
# SetStayUntapped() - Set stay-untapped flag for card under the mouse.
#
def SetStayUntapped
{
  if(object.type=="card")
  {
    if(!IsStayUntapped(object.number))
    {
      if(tapped(object.number))
        MouseMiddleClick();
      add_text(object.number,STRING_KEEP_UNTAPPED);
    }
  }
}

#
# UnsetStayUntapped() - Clear stay-untapped flag for card under the mouse.
#
def UnsetStayUntapped
{
  if(IsStayUntapped(object.number))
  {
    if(object.type=="card")
      del_text(object.number,STRING_KEEP_UNTAPPED);
  }
}

#
# Special(function, args) - Handle game specific special commands.
#
def Special
{
  if(isfunction("SpecialEvent"+first(ARG)))
    call("SpecialEvent"+first(ARG),tail(ARG));
}

#
# ClearGame() - Clear table, remove aside, hand, deck and avatar objects.
#
def ClearGame
{
  del_object(select("#>=10000",objects()));
  card.group=(,);
}

#
# Bid(results) - Handle bidding results (dictionary mapping player numbers to bids).
#
def Bid
{
  if(isfunction("BidHook"))
    call("BidHook",ARG);
}

#
# SetOption(option,value) - Set option during a game.
#
def SetOption
{
  options.game{ARG[0]}=ARG[1];
}

#
# Flash(object number) - Flash the object.
#
def Flash
{
  push(h);
  h=get_attr(ARG,"highlight");
  if(h<5)
  {
    push(c);
    set_attr(ARG,"highlight",5);
    c=set_fgcolor(ARG,HIGHLIGHT_COLOR);
    AddTimer(2,'if(is_object('+tostr(ARG)+')) { set_fgcolor('+tostr(ARG)+','+tostr(c)+'); set_attr('+tostr(ARG)+',"highlight",'+tostr(h)+');}');
    c=pop();
  }
  h=pop();
}

#
# HANDLING MODES
# ==============

#
# SetMode(mode) - Change current client mode "menu","chat","play" or "watch".
#
def SetMode
{
  if(mode!=ARG)
  {
    DelMenu();
    if(mode!="")
      call("Leave"+ucfirst(mode)+"Mode",NULL);
    
    if(has_entry(mode,mode_object))
      forall('if(object_data(#)!=NULL) set_attr(#,"visible",0);',mode_object{mode});
    mode=ARG;
    if(ARG!="")
      call("Start"+ucfirst(ARG)+"Mode",NULL);
      
    if(has_entry(mode,mode_object))
      forall('if(object_data(#)!=NULL) set_attr(#,"visible",1);',mode_object{mode});
  }
}

#
# StartChatMode() - Initialization of the chat mode.
#
def StartChatMode
{
  server.meta=server;
  room.players=(,);
  forall('c=TableCoord(#);del_object(TableObject(#));table.number[c[0]][c[1]]=NULL;',keys(room.tables));
  room.tables=(,);
  if(old.me != NULL)
    me=old.me;
  old.me=NULL;
  
  if(server != NULL)
  {
    Send("RefreshChatRoom",NULL);
    SetAwayOff();
  }
  if(LoadBookState())
    SetBookPage(book_page(card.book));
  else
    BookFullRefresh();

  MsgChat(" ");
  MsgChat("{hr}");
  MsgChat("my messages");
  MsgChat(" ");
}

#
# LeaveChatMode() - Cleaning operations when leaving chat mode.
#
def LeaveChatMode
{
  push(c);
  set_attr(deck.box,"visible",0);
  set_attr(card.book,"visible",0);
  set_attr(background.object,"visible",0);
  
  forall('c=TableCoord(#);del_object(TableObject(#));table.number[c[0]][c[1]]=NULL;',keys(room.tables));
  room.tables=(,);
  old.me=me;
  c=pop();
}

#
# ShowPlaymat() - Load play mode background and turn playmat visible.
#
def ShowPlaymat
{
  if(playmat.image==NULL)
  {
    playmat.image=load_image("playmat.png");
#    playmat.object=create_image(0,0,obj=obj+1,playmat.image,"playmat",0); 
playmat.object=create_image(0,(screen.height-image_height(playmat.image))/2,obj=obj+1,playmat.image,"playmat",0);

  }
  lower(playmat.object);
  set_attr(playmat.object,"visible",1);
  set_attr(playmat.object,"onbottom",1);
  set_fgcolor(input.box,BRCOLOR2);
  set_bgcolor(input.box,BGCOLOR2);
  set_textcolor(input.box,INCOLOR);

  if(isfunction("ShowPlaymatHook"))
    call("ShowPlaymatHook",NULL);
}

#
# HidePlaymat() - Hide play mode background.
#
def HidePlaymat
{
  set_attr(playmat.object,"visible",0);
  set_fgcolor(input.box,BRCOLOR);
  set_bgcolor(input.box,BGCOLOR);
  set_textcolor(input.box,INCOLOR);
  if(isfunction("HidePlaymatHook"))
    call("HidePlaymatHook",NULL);
}

#
# StartPlayMode() - Initialization of the play mode.
#
def StartPlayMode
{
  Msg("{hr}");
  Msg("GAME BEGINS");
  ShowPlaymat();
  if(input=="")
    set_attr(input.box,"visible",0);
  set_attr(chat_msg.box,"visible",0);
  
  set_attr(background.object,"visible",0);
  
}

#
# LeavePlayMode() - Cleaning operations when leaving play mode.
#
def LeavePlayMode
{
  ClearSearchbox();
  server=server.meta;
  flag.playing=0;
  del_object(select("#>=10000",objects()));
  set_attr(playmat.object,"visible",0);
  Msg("GAME ENDS");
  Msg("{hr}");
  HidePlaymat();
  set_attr(input.box,"visible",1);
  set_attr(chat_msg.box,"visible",1);
  set_attr(background.object,"visible",1);
}

#
# LeaveOfflineMode() - Nothing.
#
def LeaveOfflineMode
{
}

#
# StartWatchMode() - Initialization of the watch mode.
#
def StartWatchMode
{
  deck_content=(,);
  ShowPlaymat();
  raise(chat_msg.box);
  if(pm_name != NULL)
    EndPMSession();
  MsgChat(" ");
  MsgChat("{hr}");
  MsgChat("main chat: hover over this box to talk");
  MsgChat(" ");
}

#
# LeaveWatchMode() - Cleaning operations when leaving watch mode.
#
def LeaveWatchMode
{
  push(d);
  d=1;
  while(d!=NULL)
  {
    d=net_get();
    if(d!=NULL)
    {
      if(typeof(d[0])=="integer")
        Receive(toval(d[1]));
    }
  }
  if(server != server.meta)
    net_close(server);
  server=server.meta;
  del_object(select("#>=10000",objects()));
  HidePlaymat();
  set_attr(background.object,"visible",1);
  d=pop();
}

# META SERVER EVENTS
# ==================

#
# Null() - Null command for TCP/IP keepalive.
#
def Null
{}

#
# SetMoney(amount) - Set current amount of money.
#
def SetMoney
{
  money=ARG;
  message(money.box,"$"+format("%.2f",money));
}

#
# SetPrice(card number,(seller,price)) - Set price data for a card in card book.
#
def SetPrice
{
  book_set_entry(card.book,ARG);
}

#
# SetProducts(product list) - Set content of product list.
#
def SetProducts
{
  products=ARG;
  UpdatePanel("products");
}

#
# AddRoomPlayer(player number,data,avatar) - Add player to chat room.
#
def AddRoomPlayer
{
  room.players{ARG[0]}=ARG[1];
  SetAvatar(ARG[0],ARG[1][0],ARG[2],ARG[1][2]);
}  

#
# DelRoomPlayer(player number) - Delete player from chat room.
#
def DelRoomPlayer
{
  if(has_entry(ARG,room.players))
  {
    RemoveAvatar(room.players{ARG}[0]);
    room.players=del_entry(ARG,room.players);
  }
}

#
# FreeTablePos() - Return (x,y) pair of the first free table
#   position.
# 
def FreeTablePos
{
  push(x);
  push(y);
  y=0;
  while(y < TABLES_Y)
  {
    x=0;
    while(x < TABLES_X)
    {
      if(table.number[x][y]==NULL)
      {
        return(x,y);
        x=TABLES_X;
        y=TABLES_Y;
      }
      x=x+1;
    }
    y=y+1;
  }
  y=pop();
  x=pop();
}

#
# Table() - Return number of table where i am sitting or -1.
#
def Table
{
  return(room.players{me}[2]);
}

#
# TableCoord(table number) - Convert table number to (x,y) pair describing position of the table.
#
def TableCoord
{
  push(x);
  push(y);
  y=0;
  while(y < TABLES_Y)
  {
    x=0;
    while(x < TABLES_X)
    {
      if(table.number[x][y]==ARG)
      {
        return(x,y);
        x=TABLES_X;
        y=TABLES_Y;
      }
      x=x+1;
    }
    y=y+1;
  }
  y=pop();
  x=pop();
}

#
# TableNumber(object number) - Convert object number to table number.
#
def TableNumber
{
  push(x);
  push(y);
  y=0;
  while(y < TABLES_Y)
  {
    x=0;
    while(x < TABLES_X)
    {
      if(table.object[x][y]==ARG)
      {
        return(table.number[x][y]);
        x=TABLES_X;
        y=TABLES_Y;
      }
      x=x+1;
    }
    y=y+1;
  }
  y=pop();
  x=pop();
}

#
# TableObject(table number) - Convert table number to object number presenting the table.
#
def TableObject
{
  push(c);
  c=TableCoord(ARG);
  return(table.object[c[0]][c[1]]);
  c=pop();
}

#
# AddRoomTable(table number,data) - Add table to chat room.
#
def AddRoomTable
{
  if(mode!="watch" && mode!="play")
  {
    push(c);
    push(s);
    push(o);
    push(h);
    push(b);
    
    DelRoomTable(ARG[0]);
    c=FreeTablePos();
    o=table.object[c[0]][c[1]];

    DelRoomTable(ARG[0]);

    room.tables{ARG[0]}=ARG[1];
    table.number[c[0]][c[1]]=ARG[0];
    create_image((image_width(table.image)+w(10))*c[0]+w(20),(image_height(table.image)+h(10))*c[1]+h(270),o,table.image,"table");

    lower(o);
    set_attr(o,"clickable",1);
    set_attr(o,"onbottom",1);
    set_textcolor(o,TXCOLOR);
    set_textalign(o,1);

    if(TABLE_SHADOW)
      h="{shadow}";
    else
      h="";
      
    if(ARG[1][4] > 0)
      b="{red}$";
    else
      b="$";

#    if(ARG[1][5]==1)
#      h=h+"{orange}";
#    else if(ARG[1][5] > 2)
#      h=h+"{80,160,0}";
      

    add_text(o,h+"TABLE "+ARG[0]);
    add_text(o,h+"{sz10}"+ARG[1][5]+" players, "+b+format("%.2f",ARG[1][4]));
#    add_text(o,h+"{hr}");
    add_text(o,h+"{sz10}"+room.tables{ARG[0]}[10]);

    s=first(split(room.tables{ARG[0]}[0],"."));
    if(tostr(toint(s))==s)
      s=room.tables{ARG[0]}[0];
    add_text(o,h+"{sz8}"+s+":"+room.tables{ARG[0]}[1]);

    AvatarRecalcTable(ARG[0]);

    b=pop();
    h=pop();
    o=pop();
    s=pop();
    c=pop();
  }
}

#
# DelRoomTable(table number) - Delete table from chat room.
#
def DelRoomTable
{
  if(has_entry(ARG,room.tables))
  {
    push(c);
    for(p)(room.tables{ARG}[2])
      MoveAvatar(p,-1);
    room.tables=del_entry(ARG,room.tables);
    del_object(TableObject(ARG));
    c=TableCoord(ARG);
    table.number[c[0]][c[1]]=NULL;
    for(p)(room.players)
    {
      if(p[1][2]==ARG)
         room.players{p[0]}[2]=-1;
    }
    c=pop();
  }
}

#
# JoinTable(player number,table number) - Add player to the table.
#
def JoinTable
{
  if(mode=="chat" && has_entry(ARG[0],room.players) && has_entry(ARG[1],room.tables))
  {
    room.tables{ARG[1]}[2]=room.tables{ARG[1]}[2]+(ARG[0],);
    room.players{ARG[0]}[2]=ARG[1];
    MoveAvatar(ARG);
  }
}

#
# LeaveTable(player number,table number) - Delete player from the table.
#
def LeaveTable
{
  if(mode=="chat" && has_entry(ARG[0],room.players) && has_entry(ARG[1],room.tables))
  {
    room.tables{ARG[1]}[2]=room.tables{ARG[1]}[2]-(ARG[0],);
    room.players{ARG[0]}[2]=-1;
    AvatarRecalcTable(ARG[1]);
  }
}

#
# LeaveTableToChat(player number,table number) - Delete player from the table and move directly to chat room.
#
def LeaveTableToChat
{
  if(mode=="chat" && has_entry(ARG[0],room.players) && has_entry(ARG[1],room.tables))
  {
    LeaveTable(ARG);
    MoveAvatar(ARG[0],-1);
  }
}

#
# SetJoinGame(player,table,0 or 1) - Player joins (1) or leaves (0) the game at table.
#
def SetJoinGame
{
  if(mode=="chat" && has_entry(ARG[0],room.players) && has_entry(ARG[1],room.tables))
  {
    if(ARG[2])
      room.tables{ARG[1]}[6]=room.tables{ARG[1]}[6] + (ARG[0],);
    else
      room.tables{ARG[1]}[6]=room.tables{ARG[1]}[6] - (ARG[0],);

    set_attr(avatar.object{PlayerName(ARG[0])},"highlight",ARG[2]);
  }
}

#
# ConnectServer(server,port,cookie) - Connect to the game server.
#
def ConnectServer
{
  if(server==server.meta)
  {
    if(left(ARG[0],4)=="127.")
      ARG[0] = server.name;
    Msg("Connecting to the game server "+ARG[0]+" at port "+ARG[1]);
    server=net_connect(ARG[0],ARG[1]);
    if(server==NULL)
    {
      Msg("{red}Connection failed.");
      server=server.meta;
    }
    else
    {
      push(ok);
      push(e);
      ok=1;
      while(ok)
      {
        e=net_get();
        if(e!=NULL)
        {
          if(e[0]=="close")
          {
            Msg("{red}Connection closed. Either game is closing soon or not yet begun.");
            server=server.meta;
            ok=0;
          }
          else if(e[0]==server && left(e[1],9)=='("Message')
          {
            Send("RegisterPlayer",(username,VERSION,database.cards,GAME,ARG[2],SYSTEM,eval("ser"+"ial")));
            con=e[0];
            Receive(toval(e[1]));
            ok=0;
          }
          else
          {
            con=e[0];
            Receive(toval(e[1]));
          }
        }
      }
      e=pop();
      ok=pop();
    }
  }
}

#
# AddCard(card number) - Add a card to my collection.
#
def AddCard
{
  AddCards((ARG,));
}

#
# AddCards(list of card numbers) - Add cards to my collection.
#
def AddCards
{
  push(e);
  for(c)(ARG)
  {
    e=book_entry(card.book,c);
    e[0]=e[0]+1;
    if(e[4] < 0)
      e[4]=e[4]+1;
    book_set_entry(card.book,((c,e),));
  }
  if(deck.name!=NULL && has_entry(deck.name,decks))
    cards_missing=listbox_set_deck(deck.box,decks{deck.name},card.book); 
  e=pop();
}

#
# Buy(list of received cards) - Called when booster/starter bought.
#
  def Buy
  {
    if(booster.manual_buy)
    {
      push(m);
      push(r);
      m="{orange}You got:{white}";
      for(c)(ARG)
      {
        r=first(card_attr("rarity",c));
        if(isdict(rarity.display) && has_entry(r,rarity.display))
          m=m+rarity.display{r};
        m=m+" "+name(c)+"{white},";
      }
      Msg(left(m,length(m)-1)+".");
      r=pop();
      m=pop();
    }
    else
    {
      del_cardbox_all_recenter(booster.box);
      booster=ARG;
      if(booster.open_at_once)
        booster.visible=ARG;
      else
        booster.visible=card_back(ARG);
      raise(booster.box);
      put_cardbox_recenter(booster.box,booster.visible);
    }
    Alert("Adding cards to my collection");

    AddCards(ARG);

    if(deck.name!=NULL && has_entry(deck.name,decks))
      cards_missing=listbox_set_deck(deck.box,decks{deck.name},card.book);

    AlertOff();
  }

#
# Quit() - Called when metaserver closes connection.
#
def Quit
{
  SetMode("");
  net_close(server);
  Msg("{blue}Connection closed to meta server");
}

#
# WantList(user name,list of wanted cards) - Receive want list from server.
#
def WantList
{
  push(w);
  push(e);
  push(l);
  push(m);
  push(u);

  if(typeof(options{"trade_limit"})=="integer")
    l=options{"trade_limit"};
  else
    l=999999;
  
  playerwant{ARG[0]} = ARG[1];

  m="";
  u=(,);
  for(s)(sets())
  {
    w=select("set_of(#)==s",ARG[1]);
    if(length(w))
    {
      m=m+"  {blue}"+s+":{white} ";
      for(i)(w)
      {
        if(i!=first(w))
          m=m+", ";
        e=book_entry(card.book,i);
        if(e[4]>0 || e[0]>l)
          m=m+"{green}";

        m=m+name(i)+" ("+Attr("rarity",i)+") "+e[0];

        if(!book_refresh{i})
        {
          u=u+(i,);
          m=m+"*";
        }
        m=m+"{white}";
      }
      m=m+"\n";
    }
  }

  Msg("{orange}"+ARG[0]+" wants:");

  if(length(m)==0)
    Msg("  nothing you can give");
  else
    Msg(m);

  if(length(u))
  {
    RefreshBook(u);
    Msg("  {sz10}cards denoted by * not necessarily up to date, update request sent");
  }

  u=pop();
  m=pop();
  l=pop();
  e=pop();
  w=pop();
}

#
# HaveList(user name,list of cards for sale) - Receive have list from server.
#
def HaveList
{
  push(w);
  push(e);
  push(c);
  push(m);

  playerhave{ARG[0]} = ARG[1];

  m="";
  for(s)(sets())
  {
    w=select("set_of(#)==s",ARG[1]);
    c=(,);
    forall('e=book_entry(card.book,#); if(e[4] < 0) c=c+(#,);',w);
    if(length(c))
    {
      m=m+"  {blue}"+s+":{white} ";
      m=m+join(forall('name(#)+" ("+Attr("rarity",#)+")"',c),", ")+"\n";
    }
  }

  Msg("{orange}"+ARG[0]+" has:");
  if(length(m)==0)
    Msg("  nothing you want");
  else
    Msg(m);

  m=pop();
  c=pop();
  e=pop();
  w=pop();
}

#
# SetPassword(user,password) - Set and save password for user.
#
def SetPassword
{
  Msg("{blue}Password for "+ARG[0]+" received.");
  password{ARG[0]}=ARG[1];
  save("password");
}

#
# RestoreDeck(deck name or id, deck content) - Retrieve the registered deck.
#
def RestoreDeck
{
  push(n);
  n=ARG[0];
  if(n=="default")
  {
    if(deck.name == NULL)
      Msg("{red}You must create an empty deck or select a deck to overwrite before restoring.");
      
    n=deck.name;
  }
  if(n != NULL)
  {
    if(ARG[1] == NULL)
      Msg("{red}No data available. Maybe you tried to restore a deck without registering one first?");
    else
    {
      decks{n}=ARG[1];
      Msg("Received the '"+n+"' deck.");
      SelectDeck(n);
    }
  }

  n=pop();
}

#
# DECK EDITOR
# ===========

#
# EditCardname() - return name of the card under mouse on the deck list or NULL if none.
#
def EditCardname
{
  push(n);
  if(object.name=="Current Deck" && listbox.index >= 0)
  {
    n=listbox_entry(deck.box,listbox.index);
    if(n[0]!="")
    {
      n=n[1];
      if(length(split(n," {right}{red}")) > 1)
      {
        n=split(n," {right}{red}");
        n=n[0];
      }
# Backward compatibility
      else if(length(split(n," {red}")) > 1)
      {
        n=split(n," {red}");
        n=n[0];
      }
      return(n);
    }
  }
  n=pop();
}

#
# EditCardNumber() - Return (random) card number in deck editor under mouse or NULL if none.
#
def EditCardNumber
{
  push(n);
  push(p);
  if(object.name=="Current Deck" && listbox.index >= 0)
  {
    n=EditCardname();
    p=EditNearestPartname();
    if(n!=NULL && p!=NULL)
      return(random(select("canonical_name(#)==n",decks{deck.name}{p})));
  }
  p=pop();
  n=pop();
}

#
# EditPartname() - Return name of the deck part title under mouse or NULL if none.
#
  def EditPartname
  {
    push(n);
    if(object.name=="Current Deck" && listbox.index >= 0)
    {
      n=listbox_entry(deck.box,listbox.index);
      n=n[1];
      if(left(n,2)=="  ")
      {
        n=split(n," (");
        n=substr(n[0],2);
        return(lc(n));
      }
    }
    n=pop();
  }

#
# EditNearestPartname() - Return name of the deck part above current line.
#
  def EditNearestPartname
  {
    push(n);
    push(i);
    if(object.name=="Current Deck" && listbox.index >= 0)
    {
      return("deck");
      i=listbox.index;
      while(i >= 0)
      {
        n=listbox_entry(deck.box,i);
        n=n[1];
        if(left(n,2)=="  ")
        {
          n=split(n," (");
          n=substr(n[0],2);
          return(lc(n));
          i=-1;
        }
        i=i-1;
      }
    }
    i=pop();
    n=pop();
  }

#
# FindCards(count,card name) - Find several card images, preferably images of owned cards.
#
def FindCards
{
  push(c);
  c=flatten(forall("b=book_entry(card.book,#);copy(#,b[0])",images(ARG[1])));
  c=c+repeat(ARG[0],"random(images(ARG[1]))");
  return(left(c,ARG[0]));
  c=pop();
}

#
# EditCountCards(part name,canonical name or number) - Count number of cards in the part of the current deck.
#
def EditCountCards
{
  push(d);
  push(n);
  return(0);
  n=ARG[1];
  if(typeof(n)=="integer")
    n=canonical_name(n);
  if(has_entry(ARG[0],decks{deck.name}))
    return(count(n,canonical_name(decks{deck.name}{ARG[0]})));
  n=pop();
  d=pop();
}

#
# AddToDeck(deck name,deck part,card name,count) - Add card(s) to the deck in the deck collection.
# Return ID of most recent card added.
#
def AddToDeck
{
  push(d);
  push(c);
  d=select("canonical_name(#)==ARG[2]",decks{ARG[0]}{ARG[1]});
  c=FindCards(length(d)+ARG[3],ARG[2]);
  decks{ARG[0]}{ARG[1]}=decks{ARG[0]}{ARG[1]} - d + c;
  return(last(c));
  c=pop();
  d=pop();
}

def CommandAddpart
{
  if(!has_entry(deck.name,decks) || deck.name==NULL)
    Msg("{red}You must have a deck selected.");
  if (ARG != NULL)
    AddDeckPart(join(ARG," "));
}

def CommandDelpart
{
  if(!has_entry(deck.name,decks) || deck.name==NULL)
    Msg("{red}You must have a deck selected.");
  if (ARG != NULL)
    RemoveDeckPart(join(ARG," "));
}

#
# AddDeckPart(part name) - Add deck part with the given name to the current deck.
#
def AddDeckPart
{
  if(deck.name!=NULL)
  {
    if(has_entry(lc(ARG),decks{deck.name}))
      Msg("{red}"+ucfirst(lc(ARG)+" already added.");
    else
    {
      decks{deck.name}{lc(ARG)}=(,);
      RefreshCurrentDeck();
    }
  }
}

#
# CheckDeckPart(part name) - If given deck part already exists, return 1. Otherwise, create it and return 0.
# If no deck is selected, return NULL.
#
def CheckDeckPart
{
  if(deck.name==NULL)
    return(NULL);
  else if(has_entry(lc(ARG),decks{deck.name}))
    return(1);
  else
  {
    decks{deck.name}{lc(ARG)}=(,);
    return(0);
  }
}

#
# RemoveDeckPart(part name) - Remove named part from the current deck if it exists.
#
def RemoveDeckPart
{
  if(deck.name!=NULL)
  {
    if(!has_entry(lc(ARG),decks{deck.name}))
      Msg("{red}The deck has no "+lc(ARG)+".");
    else
    {
      decks{deck.name}=del_entry(lc(ARG),decks{deck.name});
      RefreshCurrentDeck();
      if(lc(ARG)==deck.part)
      {
        deck.part="deck";
        undo_buffer=(,);
        undo.pos=-1;
      }
    }
  }
}

#
# EditAdd(deck part,card name or number) - Add a card to the current deck.
#
def EditAdd
{
  push(o);
  push(cn);
  
  if(!has_entry(deck.name,decks) || deck.name==NULL)
    Msg("{red}You must have a deck selected.");
  else
  {
    if(typeof(ARG[1])=="string")
      cn=first(FindCards(1,ARG[1]));
    else
      cn=ARG[1];
    deck.addpart=ARG[0];
    
    o=1;
    if(isfunction("EditAddHook"))
      o=EditAddHook(ARG);
    
    if(o)
    {
      if(!has_entry(deck.addpart,decks{deck.name}))
        Msg("{red}Cannot add to deck: no such deck part as "+tostr(deck.addpart)+".");
      else if(cn==NULL)
        Msg("{red}No such card.");
      else if(canonical_name(cn)==NULL)
        Msg("{red}No such card.");  
      else
      {
        decks{deck.name}{deck.addpart}=decks{deck.name}{deck.addpart} + (cn,);

        if(undo.pos<0)
        {
          undo_buffer=((cn,1,"",deck.addpart),);
          undo.pos=0;
        }
        else if(undo_buffer[undo.pos][0]==cn && undo_buffer[undo.pos][2]=="" && undo_buffer[undo.pos][3]==deck.addpart)
          undo_buffer[undo.pos][1]=undo_buffer[undo.pos][1] + 1;
        else if(undo_buffer[undo.pos][0]==cn && undo_buffer[undo.pos][2]==deck.addpart && undo_buffer[undo.pos][3]=="")
          undo_buffer[undo.pos][1]=undo_buffer[undo.pos][1] - 1;
        else
        {
          undo.pos=undo.pos+1;
          undo_buffer=left(undo_buffer,undo.pos)+((cn,1,"",deck.addpart),);
        }
        RefreshCurrentDeck();
      }
    }
  }
  cn=pop();
  o=pop();
}

#
# EditDel(deck part,canonical name or number) - Delete a card from the
#   current deck, return 1 if successful.
#
def EditDel
{
  push(d);
  if(!has_entry(deck.name,decks) || deck.name==NULL)
    Msg("{red}You must have a deck selected.");
  else if(!has_entry(ARG[0],decks{deck.name}))
    Msg("{red}No such deck part as "+tostr(ARG[0])+".");
  else
  {
    if(typeof(ARG[1])=="string")
      d=select("canonical_name(#)==ARG[1]",decks{deck.name}{ARG[0]});
    else if(typeof(ARG[1])=="integer")
      d=select("#==ARG[1]",decks{deck.name}{ARG[0]});
    else
      Msg("{red}Bad card name argument.");
    if(length(d)>0)
    {
      decks{deck.name}{ARG[0]}=decks{deck.name}{ARG[0]}-d+tail(d);
      
      if(undo.pos<0)
      {
        undo_buffer=((d[0],1,ARG[0],""),);
        undo.pos=0;
      }
      else if(undo_buffer[undo.pos][0]==d[0] && undo_buffer[undo.pos][2]==ARG[0] && undo_buffer[undo.pos][3]=="")
        undo_buffer[undo.pos][1]=undo_buffer[undo.pos][1] + 1;
      else if(undo_buffer[undo.pos][0]==d[0] && undo_buffer[undo.pos][2]=="" && undo_buffer[undo.pos][3]==ARG[0])
        undo_buffer[undo.pos][1]=undo_buffer[undo.pos][1] - 1;
      else
      {
        undo.pos=undo.pos+1;
        undo_buffer=left(undo_buffer,undo.pos)+((d[0],1,ARG[0],""),);
      }
      
      if(length(d)==1)
        Msg("Note: removed the last "+name(d[0])+" from the "+ARG[0]+".");
      RefreshCurrentDeck();
      return(1);
    }
  }
  d=pop();
}

#
# EditMove(from part, to part, canonical name or number) - Move a card from one deck part to another.
#
def EditMove
{
  push(d);
  if(!has_entry(deck.name,decks) || deck.name==NULL)
    Msg("{red}You must have a deck selected.");
  else if(!has_entry(ARG[0],decks{deck.name}))
    Msg("{red}No such deck part as "+tostr(ARG[0])+".");
  else if(!has_entry(ARG[1],decks{deck.name}))
    Msg("{red}No such deck part as "+tostr(ARG[1])+".");
  else if(ARG[0]==ARG[1])
    Msg("{red}Why?");
  else
  {
    if(typeof(ARG[2])=="string")
      d=select("canonical_name(#)==ARG[2]",decks{deck.name}{ARG[0]});
    else if(typeof(ARG[2])=="integer")
      d=select("#==ARG[2]",decks{deck.name}{ARG[0]});
    else
      Msg("{red}Bad card name argument.");
    if(length(d)>0)
    {
      decks{deck.name}{ARG[0]}=decks{deck.name}{ARG[0]}-d+tail(d);
      decks{deck.name}{ARG[1]}=decks{deck.name}{ARG[1]}+(d[0],);
      
      if(undo.pos<0)
      {
        undo_buffer=((d[0],1,ARG[0],ARG[1]),);
        undo.pos=0;
      }
      else if(undo_buffer[undo.pos][0]==d[0] && undo_buffer[undo.pos][2]==ARG[0] && undo_buffer[undo.pos][3]==ARG[1])
        undo_buffer[undo.pos][1]=undo_buffer[undo.pos][1] + 1;
      else if(undo_buffer[undo.pos][0]==d[0] && undo_buffer[undo.pos][2]==ARG[1] && undo_buffer[undo.pos][3]==ARG[0])
        undo_buffer[undo.pos][1]=undo_buffer[undo.pos][1] - 1;
      else
      {
        undo.pos=undo.pos+1;
        undo_buffer=left(undo_buffer,undo.pos)+((d[0],1,ARG[0],ARG[1]),);
      }
            
      if(length(d)==1)
        Msg("Note: moved the last "+name(d[0])+" out of the "+ARG[0]+".");
      RefreshCurrentDeck();
      return(1);
    }
  }
  d=pop();
}

#
# EditCreateDeck(deck name) - Create a new deck and select it as current deck.
#
def EditCreateDeck
{
  if(ARG=="")
    Msg("{red}You must give a valid deck name.");
  else if(has_entry(ARG,decks))
    Msg("{red}You already have a deck with that name.");
  else
  {
    decks{ARG}=NewDeck();
    deck.part="deck";
    SelectDeck(ARG);
    set_attr(deck.box,"visible",1);
  }
}

#
# CreateEmptyDeck() - Create a new unnamed deck and display help about deckbuilding.
#
def CreateEmptyDeck
{
  if(has_entry("{blue}New Deck{white}",decks))
  {
    SelectDeck("{blue}New Deck{white}");
    Msg("You already have an untitled deck which would be destroyed if you created a new one.");
    Msg("If you still want to add a new deck, type {yellow}/renamedeck [newname]{white} first, or use {yellow}/newdeck [deckname]{white} to create a new named deck.");
  }
  else
  {
    decks{"{blue}New Deck{white}"}=NewDeck();
    deck.part="deck";
    SelectDeck("{blue}New Deck{white}");
    set_attr(deck.box,"visible",1);
    Msg("{sz20}{yellow}Deckbuilding Help");
    Msg("To give your new deck a name, type {yellow}/renamedeck [deckname]{white}. To create another deck without bringing up this help, type {yellow}/newdeck [deckname]{white}.");
    Msg("You can open the list of cards with {yellow}Ctrl+B{white} if you haven't already, then scroll through it with the mouse wheel or with {yellow}PgUp{white} and {yellow}PgDn{white} keys.");
    Msg("You can also go directly to the next page that has a particular card you want, by typing {yellow}/find [cardname]{white}.");
    Msg("Clicking on a card with the mouse wheel (or using {yellow}Ctrl+A{white}) adds a copy to the deck; left-clicking removes a copy. Right-clicking offers these options and more.");
  }
}

#
# ChatCommandAddgroup(name) - Create the named deck group.
#
def CommandAddgroup
{
  if(length(ARG)>0)
  {
    gn = join(ARG," ");
    if(has_entry(gn,deck.groups))
      Msg("{red}You already have that deck group.");
    else
    {
      deck.groups{gn}=(,);
      Msg("Deck group '"+gn+"' added.");
    }
  }
  else
    Msg("{red}Please specify a name for the deck grouping.");
}

#
# ChatCommandDelgroup(name) - Remove a deck group. Any decks therein will still exist, ungrouped.
#
def ChatCommandDelgroup
{
  if(length(ARG)<1)
    Msg("{red}Please specify which group you want to delete.");
  else
  {
    gn = join(ARG," ");
    if(has_entry(gn,deck.groups))
    {
      deck.groups=del_entry(gn,deck.groups);
      Msg("Deck group '"+gn+"' removed.");
    }
    else
      Msg("{red}You don't have that deck group.");
  }
}

#
# GroupOf(deck name) - Return group containing the given deck name.
# Return empty string if deck is not in a group.
#
def GroupOf
{
  return("");
  push(g);
  for(g)(keys(deck.groups))
    if(find(ARG,deck.groups{g}) != NULL)
      return(g);
  g=pop();
}

#
# AddDeckToGroup(group name) - Put the current deck in the specified group.
#
def AddDeckToGroup
{
  if(deck.name==NULL)
    Msg("{red}No deck selected.");
  else if(!has_entry(ARG,deck.groups))
    Msg("{red}No such group.");
  else
  {
    RemoveDeckFromGroup(1);
    deck.groups{ARG}=deck.groups{ARG}+(deck.name,);
    Msg("Deck '"+deck.name+"' added to group '"+ARG+"'.");
  }
}

#
# RemoveDeckFromGroup(silent?) - Take the current deck out of whatever group it's in.
#
def RemoveDeckFromGroup
{
  if(deck.name==NULL)
    Msg("{red}No deck selected.");
  else
  {
    push(g);
    g=GroupOf(deck.name);
    if(length(g)>0)
    {
      deck.groups{g}=deck.groups{g}-(deck.name,);
      if(!ARG)
        Msg("Deck '"+deck.name+"' removed from the group '"+g+"'.");
    }
    g=pop();
  }
}

def WatchCommandAddgroup
{
  ChatCommandAddgroup(ARG);
}

def WatchCommandDelgroup
{
  ChatCommandDelgroup(ARG);
}

def OfflineCommandAddgroup
{
  ChatCommandAddgroup(ARG);
}

def OfflineCommandDelgroup
{
  ChatCommandDelgroup(ARG);
}

HELP{"chat"}{"addgroup"}=("groupname","Add a new deck group",NULL,
"Create a deck group with the given name. You can use deck groups to help organize similar decks.");
HELP{"chat"}{"delgroup"}=("groupname","Remove a deck group",NULL,
"If there is a deck group with the given name, remove it. Any decks you have in that group will not be deleted, but they will reappear in the main deck selection menu.");
HELP{"chat"}{"addpart"}=("part name","Add a new section to a deck",NULL,
"Add a section for organizing the current deck, such as {yellow}sideboard{white}. If this section has the same name as one of the piles used in a game, the cards in that section will start the game in that pile.");
HELP{"chat"}{"delpart"}=("part name","Remove a section from a deck",NULL,
"If the current deck has a section with the given name, remove that section and all cards in it.");

#
# TEXT INPUT AND EDIT
# ===================

#
# InitializeInputSystem() - Load old history and clear input variables.
#
def InitializeInputSystem
{
  if(!load("history"))
    history=(,);
  history.pos=-1;
  input="";
}

#
# AddHistory(string) - Add a string to the input history and reset history position.
#
def AddHistory
{
  if(ARG != first(history))
    history=(strreplace(ARG,"{|}",""),)+history;
  history.pos=-1;
}

#
# ScrollHistory(dir) - Scroll the input history down if dir is 1 or up if -1.
#   Return value of the history line at the new position.
#
def ScrollHistory
{
  if(history.pos>=0 && history.pos<length(history))
    history[history.pos]=strreplace(input,"{|}","");

  if(ARG==-1)
  {
    if(history.pos+1 >= length(history))
    {
      beep();
      if(history==(,))
        return("");
      else
        return(last(history)+"{|}");
    }
    else
    {
      if(history.pos==-1 && input!="")
      {
        AddHistory(input);
        history.pos=0;
      }
      history.pos=history.pos+1;
      return(history[history.pos]+"{|}");
    }
  }
  else
  {
    if(history.pos==-1)
    {
      if(input=="")
      {
        beep();
        return("");
      }
      else
      {
        AddHistory(input);
        return("");
      }
    }
    else
    {
      history.pos=history.pos-1;
      if(history.pos>=0)
        return(history[history.pos]+"{|}");
      else
        return("");
    }
  }
  set_attr(input.box,"visible",1);
}

#
# Input(string) - Append a string to current command line input at the
#   current cursor position.
#
def Input
{
  if(isfunction("AddInputHook"))
  {
    push(i);
    i=InputSplit(input);
    input=AddInputHook(join(i[0],""),join(i[1],""),ARG);
    i=pop();
  }
  else
  {
    input=InputSplit(input);
    input=join(input[0],"")+ARG+"{|}"+join(input[1],"");
  }
  message(input.box,input);
  if(mode=="play")
    set_attr(input.box,"visible",1);
}

#
# DelCursor() - Remove the cursor from the input line.
#
def DelCursor
{
  input=strreplace(input,"{|}","");
}

#
# InputNewline() - Clear current input line and append it to the history.
#   Returns the line before clear and converts {lb} and
#   {rb} tags to { and }.
#
def InputNewline
{
  DelCursor();
  return(strreplace(strreplace(input,"{lb}","{"),"{rb}","}"));
  AddHistory(input);
  input="";
  message(input.box,input);
  if(mode=="play")
    set_attr(input.box,"visible",0);
}

#
# SplitToWords(string) - Split an input string to the pieces.
#   Each member of the return list is either a single letter or a tag.
#
def SplitToWords
{
  push(i);
  push(r);
  push(t);

  i=0;
  r=(,);
  t="";

  while(i<length(ARG))
  {
    if(substr(ARG,i,1)=="{")
    {
      t=t+"{";
    }
    else if(substr(ARG,i,1)=="}" && t!="")
    {
      t=t+"}";
      r=r+(t,);
      t="";
    }
    else
    {
      if(t!="")
        t=t+substr(ARG,i,1);
      else
        r=r+(substr(ARG,i,1),);
    }
    i=i+1;
  }

  if(t!="")
    r=r+split(t,"");

  return(r);

  t=pop();
  r=pop();
  i=pop();
}

#
# InputSplit() - Handles prehandling of the input line when editing.
#   Return a pair where the first component is the input line
#   before the cursor and the second component after the cursor. Each
#   component is splitted list of the input, i.e. mixed list of
#   characters and tags.
#
def InputSplit
{
  push(i);
  push(p);
  if(input=="")
    return(("",),("",));
  else
  {
    i=SplitToWords(input);
    p=find("{|}",i);
    if(p==NULL)
      return(i,(,));
    else
      return(left(i,p),right(i,length(i)-p-1));
  }
  p=pop();
  i=pop();
}

#
# InputKeyBackspace() - Input line editor handler for key Backspace.
#
def InputKeyBackspace
{
  if(input=="{|}")
  {
    input="";
    message(input.box,input);
    if(mode=="play")
      set_attr(input.box,"visible",0);
  }
  else if(input != "")
  {
    input=InputSplit(input);
    input=join(head(input[0]),"") + "{|}" + join(input[1],"");
    message(input.box,input);
  }
}

#
# InputKeyDelete() - Input line editor handler for key Delete.
#
def InputKeyDelete
{
  if(input != "")
  {
    input=InputSplit(input);
    input=join(input[0],"") + "{|}" + join(tail(input[1]),"");
    message(input.box,input);
  }
}

#
# InputKeyLeft() - Input line editor handler for key Left.
#
def InputKeyLeft
{
  if(input!="")
  {
    input=InputSplit(input);
    if(last(input[0])==NULL)
      input="{|}" + join(input[1],"");
    else
      input=join(head(input[0]),"") + "{|}" + last(input[0]) + join(input[1],"");

    message(input.box,input);
  }
}

#
# InputKeyRight() - Input line editor handler for key Right.
#
def InputKeyRight
{
  if(input!="")
  {
    input=InputSplit(input);
    if(first(input[1])==NULL)
      input=join(input[0],"") + "{|}";
    else
      input=join(input[0],"") + first(input[1]) + "{|}" + join(tail(input[1]),"");
    message(input.box,input);
  }
}

#
# InputKeyHome() - Input line editor handler for key Home.
#
def InputKeyHome
{
  if(input!="")
  {
    DelCursor();
    input="{|}"+input;
    message(input.box,input);
  }
}

#
# InputKeyEnd() - Input line editor handler for key End.
#
def InputKeyEnd
{
  if(input!="")
  {
    DelCursor();
    input=input+"{|}";
    message(input.box,input);
  }
}

#
# KEYBOARD ACTIONS
# ================

#
# KeyModifierDown(mod) - Called when "shift", "control" or "alt" is pressed down.
#
def KeyModifierDown
{
  modifier=modifier+ARG+" ";
  if(find("shift",modifier) && info.persistent==0)
  {
    push(c);
    c=CheckForCard();
    if(c!=NULL)
    {
      if(find("ctrl",modifier) && length(Attr("flipid",c)))
        c=toint(Attr("flipid",c));
      replace_cardbox(info.box,c);
      info.current=c;
    }
    c=pop();
  }
}

#
# KeyModifierUp(mod) - Called when "shift", "control" or "alt" is released.
#
def KeyModifierUp
{
  modifier=strreplace(modifier," "+ARG,"");
  if(ARG=="shift" && info.persistent==0)
  {
	del_cardbox(info.box,0);
	info.current=NULL;
  }
  else if(ARG=="ctrl" && find("shift",modifier))
  {
     c=CheckForCard();
     if(c!=NULL)
     {
       replace_cardbox(info.box,c);
       info.current=c;
     }
  }
}

#
# CheckForCard() - Return a card number, if mouse points to card name
#   (deck listing, etc.) or card image. Otherwise NULL.
#
def CheckForCard
{
  if(card.number!=NULL)
  {
    if(card_back(card.number)==card.number && object.type=="card")
    {
      push(c);
      c=card_data(object.number);
      return(c[3]);
      c=pop();
    }
    else
      return(card.number);
  }
  else if(object.name=="Current Deck" && listbox.index >= 0)
  {
    push(e);
    e=listbox_entry(deck.box,listbox.index);
# Backward compatibility
    if(find("{right}{red}",e[1])!=NULL)
      e=split(e[1]," {right}{red}");
    else
      e=split(e[1]," {red}");

    if(length(e))
    {
      push(i);
      i=images(e[0]);
      if(length(i))
      {
        return(random(select('count(#,decks{deck.name}{EditNearestPartname()}) > 0',i)));
      }
      i=pop();
    }
    e=pop();
  }
}

#
# PressKey(key code,key ascii) - Handle keypress, return 0 if not undefined key.
#
def PressKey
{
  push(k);
  push(m);
  push(f);
  push(ok);

  f=join(ucfirst(split(ARG[0]," ")));
  if(left(f,3)!="Key")
    f="Key"+f;
  if(length(f)>=3)
  {
    if(substr(f,length(f)-3,1)=="[" && right(f,1)=="]")
      f=left(f,length(f)-3)+substr(f,length(f)-2,1);
  }
  if(right(f,1)=="+")
    f=left(f,length(f)-1)+"Plus";
  if(right(f,1)=="-")
    f=left(f,length(f)-1)+"Minus";

  ok=0;
  
# Check for /bind

  if(bind_next!=NULL && typeof(bind_next)=="string")
  {
    if(has_entry(f,bind) || has_entry(f,bindk))
      Msg("{red}Already bound, try another key.");
    else
    {
      bind{f}=bind_next;
      bind_next=NULL;
      if(isfunction(f))
         Msg("Bound. Overriding function "+f+".");
      else
         Msg("Bound to "+f+".");
    }
    ok=1;
  }

# Check for /bindk

  else if(bindk_next!=NULL && typeof(bindk_next)=="string")
  {
    if(has_entry(f,bind) || has_entry(f,bindk))
      Msg("{red}Already bound, try another key.");
    else
    {
      bindk{f}=bindk_next;
      bindk_next=NULL;
      if(isfunction(f))
         Msg("Bound. Overriding function "+f+".");
      else
         Msg("Bound to "+f+".");
    }
    ok=1;
  }

# Check for /unbind

  else if(unbind_next != NULL)
  {
    unbind_next=NULL;
    if(has_entry(f,bind))
    {
      bind=del_entry(f,bind);
      Msg(f+" unbound.");
    }
    else if(has_entry(f,bindk))
    {
      bindk=del_entry(f,bindk);
      Msg(f+" unbound.");
    }
    else
      Msg("{red}"+f+" not bound.");
    ok=1;
  }

# Handle key press normally

  if(!ok)
  {
    push(n);
    push(t);

    if(object.name!="" && object.name!=NULL && (object.type=="card" || object.type=="deck" || object.type=="hand"))
      n=tofnc(object.name);
    else
      n="";

    if(object.type!="" && object.type!=NULL)
      t=tofnc(object.type);
    else
      t="";

    ok=1;
    if(has_entry(f,bind))
    {
      push(input);
      input="";
      Input(bind{f});
      KeyReturn();
      input=pop();
      message(input.box,input);
# Grab or toss timer for default phases.
      if(mode=="play" && has_entry(f,game.bindings))
      {
         if(game.bindings.opponent_timer==NULL)
           GrabTimer();
         else if(has_entry(f,game.bindings.opponent_timer))
           Send("PassTimer",NULL);
         else
           GrabTimer();
      }
    }
    else if(has_entry(f,bindk))
    {
      Input(bindk{f});
    }
    else if(isfunction(ucfirst(mode)+n+f))
      call(ucfirst(mode)+n+f,NULL);
    else if(isfunction(ucfirst(mode)+t+f))
      call(ucfirst(mode)+t+f,NULL);
    else if(isfunction(ucfirst(mode)+f))
      call(ucfirst(mode)+f,NULL);
    else if(isfunction(f))
      call(f,NULL);
    else if(ARG[1]=="{")
      Input("{lb}");
    else if(ARG[1]=="}")
      Input("{rb}");
    else if(ARG[1]!="")
      Input(ARG[1]);
    else
      ok=0;
    t=pop();
    n=pop();
  }

  return(ok);

  ok=pop();
  f=pop();
  m=pop();
  k=pop();
}

#
# PriceDelta(prc) - Search for suitable price increase/decrease step
#   according to the current price prc.
#
def PriceDelta
{
  if(ARG < 1.0)
    return(0.01);
  else if(ARG < 10.0)
    return(0.1);
  else if(ARG < 100.0)
    return(1.0);
  else if(ARG < 1000.0)
    return(10.0);
  else
    return(100.0);
}

#
# KeyReturn() - Handler for key Return.
#
def KeyReturn
{
  DelCursor();
  if((mode=="chat" || mode=="watch") && (isreal(input) || input=="") && card.number && count(object.number,books))
    HandlePriceInput();
  else
  {
    push(done);
    done=0;

    if(isfunction("InputHook"))
       done=InputHook(input);

    if(done)
      InputNewline();
    else
    {
      push(i);

      i=InputNewline();

      if(left(i,1)=="/")
        SlashCommand(i);
      else if(length(i))
      {
        if(object.number==chat_msg.box)
        {
          if(pm_name != NULL)
            net_send(server.meta,("Command","/whisper "+pm_name+" "+i));
          else
            net_send(server.meta,("Say",i));
        }
        else
          Say(i);
      }
      msgbox_scroll(msg.box,msgbox_scroll(msg.box,0));
      i=pop();
    }

    done=pop();
  }
}

#
# KeyTab() - Autocomplete names or commands.
#
def KeyTab
{
  if(mode!="")
  {
    push(p);
    push(n);
    push(b);
    push(a);
    push(word);
    push(nw);

    if(p=find("{|}",input))
    {
      b=split(left(input,p)," ",1);
      a=substr(input,p+3);
    }
    else 
    {
      b=split(input," ",1);
      a="";
    }
    
    if(last(b)==" ")
    {
      nw=1;
      b=head(b);
      word=last(b);
    }
    else
    {
      nw=0;
      word=last(b);
    }
    b=join(head(b));
    if(word==NULL) word="";
    
    if(first(word)=="/")
#   Command autocompletion
    {
      p=unique(sort(forall("'/'+(#)[0]",HELP{"any"}+HELP{mode})));
      
      if(tab.type != "command")
      {
        tab.last_initial = "/";
        tab.last_item = first(p);
        tab.type = "command";
      }
    }
    else
#   Player autocompletion
    {
      p=sort(forall("(#)[1][0]",room.players));

      if(tab.type != "player")
      {
        tab.last_initial = "";
        tab.last_item = first(p);
        tab.type = "player";
      }
    }
    
    if(word=="" || word==" ")
    {
      if(b=="" && tab.type=="player" && left(a,1) != ":")
        a=": {|}"+a;
      else
        a="{|}"+a;
      
      input=b+word+tab.last_item+a;
      Input("");
    }
    else if(nw)
    {
      p=select("find(lc(tab.last_initial),lc(#))==0",p);
      
      if(length(p))
      {
        if(last(word)==":" && tab.type=="player")
        {
          nw = ":";
          word=left(word,length(word)-1);
        }
        else
          nw="";
        
        if((n=find(lc(word),lc(p)))!=NULL)
        {
          tab.last_item=p[(n+1)%length(p)];
          input=b+tab.last_item+nw+" {|}"+a;
          Input("");
        }
        else
        {
          input=b+word+nw+" "+tab.last_item+" {|}"+a;
          Input("");
        }
      }
    }
    else
    {
      p=select("find(lc(word),lc(#))==0",p);
      if(length(p))
      {
        if(b=="" && tab.type=="player")
          nw = ": {|}";
        else
          nw=" {|}";
        
        tab.last_item=first(p);
        tab.last_initial=word;
        input=b+tab.last_item+nw+a;
        Input("");
      }
    }

    word=pop();
    nw=pop();
    a=pop();
    b=pop();
    n=pop();
    p=pop();
  }
}

#
# KeyEnter() - Handler for key Enter.
#
def KeyEnter
  KeyReturn();

#
# KeyControlKeyReturn() - Handler for key Control+Return.
#
def KeyControlKeyReturn
{
  Msg(tostr(eval(InputNewline())));
}

#
# DefaultInitialPrice(card number) - Return default initial price for cards using 'price' setting.
#
def DefaultInitialPrice
{
  push(e);

  e=book_entry(card.book,ARG);
  if(has_entry("price",options))
  {
    if(options{"price"}=="default" && has_entry(Attr("rarity",ARG),price.default))
      return(price.default{Attr("rarity",ARG)});
    else if(options{"price"}=="lower")
    {
      push(p);
      p=e[1]-PriceDelta(e[1]);
      if(p < 0.01)
        p=0.01;
      return(p);
      p=pop();
    }
    else if(options{"price"}=="same")
      return(e[1]);
    else
      return(e[1]+PriceDelta(e[1]));
  }
  else
      return(e[1]);

  e=pop();
}

#
# HandlePriceInput() - Set price of a card.
#
def HandlePriceInput
{
  push(p);
  push(e);
  push(r);
  if(card.number && count(object.number,books))
  {
    e=book_entry(object.number,card.number);
    r=Attr("rarity",card.number);
    p=toreal(format("%.2f",toreal(join(split(input,","),"."))));

    if(input=="")
    {
      if(e[4] > 0 && e[2]!=username)
      {
        push(p);
        p=DefaultInitialPrice(card.number);
        if(p < 0.0)
          p=0.0;
        BookSetPrice(card.number,p);
        p=pop();
      }
    }   
    else if(e[4]==0 && !has_entry(r,price.default))
    {
      Msg("{green}Default price for every {yellow}"+r+"{green} card set to {yellow}$"+format("%.2f",p)+"{green}.");
      Msg("{green}You can later change this default using command {yellow}/default "+r+" "+format("%.2f",p)+"{green}.");
      Msg("{green}(see {yellow}/help default{green} for additional info)");
      price.default{r}=p;
      BookSetPrice(card.number,p);
    }
    else
      BookSetPrice(card.number,p);

    if(input != "")
    {
      AddHistory(input);
      input="";
    }
    message(input.box,input);
  }
  r=pop();
  e=pop();
  p=pop();
}

#
# ChatKeyControlKeyS() - Add a card for sale (or remove one from want list).
#
def ChatKeyControlKeyS
{
  push(b);
  push(r);
  if(card.number && count(object.number,books))
  {
    b=book_entry(object.number,card.number);
    r=Attr("rarity",card.number);

    if(b[4] < b[0] && Mode()=="")
    {
      if(b[4]==0)
      {
        if(b[3]>0.0)
          BookChangeForsale(card.number,1);
        else if(b[2]!="")
        {
          BookSetPrice(card.number,DefaultInitialPrice(card.number));
          BookChangeForsale(card.number,1);
        }
        else if(!has_entry(r,price.default))
        {
          Msg("{red}You must set default price for cards having rarity "+r+".");
          Msg("{red}Enter the price and press enter.");
        }
        else
        {
          BookSetPrice(card.number,price.default{r});
          BookChangeForsale(card.number,1);
        }
      }
      else
        BookChangeForsale(card.number,1);
    }
  }
  r=pop();
  b=pop();
}

def WatchKeyControlKeyS
  ChatKeyControlKeyS();

#
# ChatKeyControlKeyA() - Add a card to the deck.
#
def ChatKeyControlKeyA
{
  if(deck.name != NULL)
  {
    if(card.number!=NULL && card_back(card.number) != card.number && count(object.number,books))
    {
      if(deck.part==NULL)
        SelectDeckPart("deck");
      EditAdd(deck.part,card.number);
    }
    else if(object.name=="Current Deck" && EditCardname()!=NULL)
    {
      SelectDeckPart(EditNearestPartname());
      EditAdd(deck.part,EditCardname());
    }
  }
}

def WatchKeyControlKeyA
  ChatKeyControlKeyA();

def OfflineKeyControlKeyA
  ChatKeyControlKeyA();

#
# ChatKeyControlKeyW() - Add a card to want list (or remove a copy from sale).
#
def ChatKeyControlKeyW
{
  if(Mode()=="" && card.number && count(object.number,books))
    BookChangeForsale(card.number,-1);
}

def WatchKeyControlKeyW
  ChatKeyControlKeyW();

#
# ChatKeyControlKeyZ() - Undo the last change to the decklist (card add/remove).
# The undo buffer will be reset when choosing a different deck or deck part, and can't rewind past that.
#
def ChatKeyControlKeyZ
{
  push(brk);
  brk=1;
  while(undo.pos>=0 && brk)
  {
    if(undo_buffer[undo.pos][1]==0)
      undo.pos=undo.pos-1;
    else
      brk=0;
  }
  
  if(undo.pos<0)
    Msg("{orange}Nothing to undo.");
  else
  {
    if(undo_buffer[undo.pos][1]<0)
#   Somehow the undo action ended up with a negative number. Flip it around by swapping source and destination.
      undo_buffer[undo.pos] = (undo_buffer[undo.pos][0], -undo_buffer[undo.pos][1], undo_buffer[undo.pos][3], undo_buffer[undo.pos][2]);
    
#   Hey cool, I already have a dummy variable here. Might as well reuse it.
    brk=0;
    if(undo_buffer[undo.pos][2] != "" && has_entry(undo_buffer[undo.pos][2],decks{deck.name}))
    {
      brk = brk + 1;
      decks{deck.name}{undo_buffer[undo.pos][2]} = decks{deck.name}{undo_buffer[undo.pos][2]} + copy(undo_buffer[undo.pos][0],undo_buffer[undo.pos][1]);
    }
    if(undo_buffer[undo.pos][3] != "" && has_entry(undo_buffer[undo.pos][3],decks{deck.name}))
    {
      push(d);
      brk = brk + 2;
      d=select("#==undo_buffer[undo.pos][0]",decks{deck.name}{undo_buffer[undo.pos][3]});
      decks{deck.name}{undo_buffer[undo.pos][3]} = decks{deck.name}{undo_buffer[undo.pos][3]} - d + copy(undo_buffer[undo.pos][0],max(0,length(d)-undo_buffer[undo.pos][1]));
      d=pop();
    }
    
    if(brk==1)
      Msg("{orange}Undo:{white} Put "+tostr(undo_buffer[undo.pos][1])+"x {card"+undo_buffer[undo.pos][0]+"} back in the "+undo_buffer[undo.pos][2]);
    else if(brk==2)
      Msg("{orange}Undo:{white} Took "+tostr(undo_buffer[undo.pos][1])+"x {card"+undo_buffer[undo.pos][0]+"} out of the "+undo_buffer[undo.pos][3]);
    else if(brk==3)
      Msg("{orange}Undo:{white} Moved "+tostr(undo_buffer[undo.pos][1])+"x {card"+undo_buffer[undo.pos][0]+"} from "+undo_buffer[undo.pos][3]+" back to "+undo_buffer[undo.pos][2]);
    
    undo.pos=undo.pos-1;
    RefreshCurrentDeck();
  }
  brk=pop();
}

def WatchKeyControlKeyZ
  ChatKeyControlKeyZ();

def OfflineKeyControlKeyZ
  ChatKeyControlKeyZ();

#
# ChatKeyControlKeyY() - Redo an action from the undo buffer.
#
def ChatKeyControlKeyY
{
  push(brk);
  brk=1;
  while(undo.pos+2 <= length(undo_buffer) && brk)
  {
    if(undo_buffer[undo.pos+1][1]==0)
      undo.pos=undo.pos+1;
    else
      brk=0;
  }
  
  if(undo.pos+2>length(undo_buffer))
    Msg("{orange}Nothing to redo.");
  else
  {
    undo.pos=undo.pos+1;
    if(undo_buffer[undo.pos][1]<0)
#   Somehow the redo action ended up with a negative number. Flip it around by swapping source and destination.
      undo_buffer[undo.pos] = (undo_buffer[undo.pos][0], -undo_buffer[undo.pos][1], undo_buffer[undo.pos][3], undo_buffer[undo.pos][2]);
    
    brk=0;
    if(undo_buffer[undo.pos][3] != "" && has_entry(undo_buffer[undo.pos][3],decks{deck.name}))
    {
      brk = brk + 1;
      decks{deck.name}{undo_buffer[undo.pos][3]} = decks{deck.name}{undo_buffer[undo.pos][3]} + copy(undo_buffer[undo.pos][0],undo_buffer[undo.pos][1]);
    }
    if(undo_buffer[undo.pos][2] != "" && has_entry(undo_buffer[undo.pos][2],decks{deck.name}))
    {
      push(d);
      brk = brk + 2;
      d=select("#==undo_buffer[undo.pos][0]",decks{deck.name}{undo_buffer[undo.pos][2]});
      decks{deck.name}{undo_buffer[undo.pos][2]} = decks{deck.name}{undo_buffer[undo.pos][2]} - d + copy(undo_buffer[undo.pos][0],max(0,length(d)-undo_buffer[undo.pos][1]));
      d=pop();
    }
    
    if(brk==1)
      Msg("{orange}Redo:{white} Put "+tostr(undo_buffer[undo.pos][1])+"x {card"+undo_buffer[undo.pos][0]+"} back in the "+undo_buffer[undo.pos][3]);
    else if(brk==2)
      Msg("{orange}Redo:{white} Took "+tostr(undo_buffer[undo.pos][1])+"x {card"+undo_buffer[undo.pos][0]+"} out of the "+undo_buffer[undo.pos][2]);
    else if(brk==3)
      Msg("{orange}Redo:{white} Moved "+tostr(undo_buffer[undo.pos][1])+"x {card"+undo_buffer[undo.pos][0]+"} from "+undo_buffer[undo.pos][2]+" back to "+undo_buffer[undo.pos][3]);
    
    RefreshCurrentDeck();
  }
  brk=pop();
}

def WatchKeyControlKeyY
  ChatKeyControlKeyY();

def OfflineKeyControlKeyY
  ChatKeyControlKeyY();

#
# KeyBackspace() - Handler for key Backspace.
#
def KeyBackspace
  InputKeyBackspace();

#
# KeyHome() - Handler for key Home.
#
def KeyHome
  InputKeyHome();

#
# KeyEnd() - Handler for key End.
#
def KeyEnd
  InputKeyEnd();

#
# KeyDelete() - Handler for key Delete.
#
def KeyDelete
  InputKeyDelete();

#
# KeyLeft() - Handler for key Left.
#
def KeyLeft
  InputKeyLeft();

#
# KeyRight() - Handler for key Right.
#
def KeyRight
  InputKeyRight();

#
# KeyUp() - Handler for key Up.
#
def KeyUp
{
  input=ScrollHistory(-1);
  message(input.box,input);
}

#
# KeyDown() - Handler for key Down.
#
def KeyDown
{
  input=ScrollHistory(1);
  message(input.box,input);
}

#
# KeyF12() - Handler for key F12.
#
def KeyF12
{
  println("----------------------");
  dump();
  println("----------------------");
}

#
# KeyF11() - Handler for key F11.
#
def KeyF11
{
  vardump();
  Msg("Variables dumped.");
}

#
# KeyF10() - Handler for key F10.
#
def KeyF10
{
  execute("common.include");
  execute("client.functions");
  execute(GAMEDIR+".include");
  LoadAllRules();
  LoadAllScripts();
  InitializeLocationTables();
  for(f)(OtherDeckFormats())
    execute(f+".format");
  execute("init");
  execute("init."+GAMEDIR);
  Msg("Function definitions updated");
  println("----------------------");
  println("Function definitions updated");
}

#
# KeyF5() - Handler for key F5.
#
def KeyF5
{
	if(info.persistent==1)
	{
		del_cardbox(info.box,0);
		info.current=NULL;
		info.persistent=0;
		Msg("Persistent infozoom is {yellow}disabled{white}.");
	}
	else
	{
		info.persistent=1;
		MouseMove("shift");
		Msg("Persistent infozoom is {yellow}enabled{white}.");
	}	
}

#
# KeyF6() - Handler for key F6 (switch chat box on/off)
#
def KeyF6
{
	set_attr(chat_msg.box,"visible",!get_attr(chat_msg.box,"visible"));
}

#
# KeyEscape() - Handler for key Escape.
#
def KeyEscape
{
  push(o);
  o=(,);

  if(search.source != NULL) o=o+(search.box,);
  if(length(booster)>0) o=o+(booster.box,);
  if(length(cardbox(select.box))) o=o+(select.box,);
  if(get_attr(products.box,"visible")) o=o+(products.box,);

  o=o+select('get_attr(#,"visible")==1 && (object_type(#)=="menu" || object_type(#)=="cardbook" || object_type(#)=="listbox")',objects());

  if(isfunction("KeyEscapeHook"))
    o=KeyEscapeHook(o);

  o=last(select("count(#,o)",objects()));

  if(o==search.box) 
    ClearSearchbox();
  else if(o==menu) 
    DelMenu();
  elseif(o==booster.box)
  {
    del_cardbox_all_recenter(booster.box);
    booster=(,);
  }
  elseif(o==select.box)
  {
    del_cardbox_all_recenter(select.box);
  }
  elseif(o==deck.box)
  {
    save("decks");
    save("deck.groups");
    save("deck.name");
    set_attr(deck.box,"visible",0);
  }
  elseif(o==products.box)
    HidePanel("products");
  else if(o!=NULL)
    set_attr(o,"visible",0);

  o=pop();
}

#
# KeyF1() - Handler for key F1.
#
def KeyF1
{
  ShowHelp();
  Msg(L("Note: Use {yellow}Page Up{white} and/or {yellow}Page Down{white} keys or mouse wheel to scroll these messages."));
}

#
# KeyPageUp() - Handler for key PageUp.
#
def KeyPageUp
{
  if(object.name=="Current Deck")
    listbox_scroll(deck.box,-5);
  else if(get_attr(card.book,"visible"))
  {
    push(p);
    p=book_page(card.book);
    p=p-1;
    if(p < 0)
	  p=book_last_page(card.book);
    SetBookPage(p);
    p=pop();
  }
  else if(object.number==chat_msg.box)
    msgbox_scroll(chat_msg.box,-7);
  else
    msgbox_scroll(msg.box,-7);
}

#
# KeyPageDown() - Handler for key PageDown.
#
def KeyPageDown
{
  if(object.name=="Current Deck")
    listbox_scroll(deck.box,5);
  else if(get_attr(card.book,"visible"))
  {
    push(p);
    p=book_page(card.book);
    p=p+1;
    if(p > book_last_page(card.book))
	  p=0;
    SetBookPage(p);
    p=pop();
  }
  else if(object.number==chat_msg.box)
    msgbox_scroll(chat_msg.box,7);
  else
    msgbox_scroll(msg.box,7);
}

#
# KeyControlKeyPageUp() - Scroll to previous section in card book.
#
def KeyControlKeyPageUp
{
  if(get_attr(card.book,"visible") && length(book_titles(card.book)))
  {
    push(p);
    push(t);
    p=book_page(card.book);
    t=select("(#)[1]<p",book_titles(card.book));
    if(t==(,))
    {
      book_set_slot(card.book,(last(book_titles(card.book)))[0]);
      SetBookPage((last(book_titles(card.book)))[1]);
    }
    else
    {
      book_set_slot(card.book,(last(t))[0]);
      SetBookPage((last(t))[1]);
    }
    t=pop();
    p=pop();
  }
}

#
# KeyControlKeyPageDown() - Scroll to next section in card book.
#
def KeyControlKeyPageDown
{
  if(get_attr(card.book,"visible") && length(book_titles(card.book)))
  {
    push(p);
    push(t);
    p=book_page(card.book);
    t=select("(#)[1]>p",book_titles(card.book));
    if(t==(,))
    {
      book_set_slot(card.book,(first(book_titles(card.book)))[0]);
      SetBookPage(0);
    }
    else
    {
      book_set_slot(card.book,(first(t))[0]);
      SetBookPage((first(t))[1]);
    }
    t=pop();
    p=pop();
  }
}

#
# KeyControlKeyB() - Show/hide card book.
#
def KeyControlKeyB
{
  set_attr(card.book,"visible",!get_attr(card.book,"visible"));
  raise(card.book);
  if(get_attr(card.book,"visible"))
    SetBookPage(book_page(card.book));
}

#
# KeyControlKeyP() - Show/hide list of products.
#
def KeyControlKeyP
{
  TogglePanel("products");
  set_attr(products.box,"ontop",Z_PRODUCTMENU);
  raise(products.box);
}

#
# ChatKeyControlKeyE() - Show/hide deck list.
#
def ChatKeyControlKeyE
{
  if(get_attr(deck.box,"visible"))
    set_attr(deck.box,"visible",0);
  else if(deck.name==NULL || !has_entry(deck.name,decks))
      ChooseDeckMenu("");
  else
  {
    cards_missing=listbox_set_deck(deck.box,decks{deck.name},card.book);
    raise(deck.box);
    set_attr(deck.box,"visible",1);
    RefreshBookForDeck(deck.name);
  }
}

def WatchKeyControlKeyE
  ChatKeyControlKeyE();

def OfflineKeyControlKeyE
  ChatKeyControlKeyE();

#
# ChatKeyControlKeyD() - Show deck selection menu.
#
def ChatKeyControlKeyD
{
  ChooseDeckMenu("");
}

def WatchKeyControlKeyD
  ChatKeyControlKeyD();

def OfflineKeyControlKeyD
  ChatKeyControlKeyD();

#
# ChatKeyControlKeyI() - Show deck import menu.
#
def ChatKeyControlKeyI
{
  ImportDeckMenu();
}

def WatchKeyControlKeyI
  ChatKeyControlKeyI();

def OfflineKeyControlKeyI
  ChatKeyControlKeyI();

#
# ChatKeyControlKeyX() - Export current deck as a text file.
#
def ChatKeyControlKeyX
{
  if(deck.name != NULL && has_entry(deck.name,decks))
    ExportToFile(decks{deck.name},strreplace(deck.name,".","_"),DEFAULT_EXPORT_FORMAT);
}

def WatchKeyControlKeyX
  ChatKeyControlKeyX();

def OfflineKeyControlKeyX
  ChatKeyControlKeyX();

#
# KeyControlKeyH() - Show information about an object.
#
def KeyControlKeyH
{
  push(c);
  c=CheckForCard();
  if(c==NULL)
  {
    if(object.number)
      Msg("This is "+object_name(object.number)+".");
  }
  else
  {
    if(card_back(c) != c)
    {
      push(b);
      push(s);
      push(f);
      Msg("{hr}");
      Msg("{sz20}{yellow}{card"+c+"}");
      Msg(text(c));
      s="";
      f=(,);
      for(b)((("set",set_of(c)),)+attrs(c))
      {
        if(left(b[0],4)=="flip")
          f=f+((substr(b[0],4),b[1]),);
        else if(b[1]!="")
          s=s+"{yellow}"+join(ucfirst(split(L(b[0]),"_"))," ")+":{white} "+L(b[1])+"  ";
      }
      s=s+"{yellow}Card ID: {white}"+c;
      Msg(s);
      if(length(f))
      {
        Msg("{orange}FLIP SIDE:");
        Msg("{sz16}{yellow}"+f{'name'});
        Msg(f{'text'});
        s="";
        for(b)(f)
        {
          if(b[0] != "name" && b[0] != "text" && b[1] != "")
            s=s+"{yellow}"+join(ucfirst(split(L(b[0]),"_"))," ")+":{white} "+L(b[1])+"  ";
        }
        Msg(s);
      }
      f=pop();
      s=pop();
      b=pop();
    }
    else
      Msg("This is "+object_name(object.number)+".");
  }

  c=pop();
}

#
# GrabTimer() - Helper function to grab timer for yourself.
#
def GrabTimer
{
  Send("GrabTimer",NULL);
}

#
# PlayKeyControlKeyTab() - Pass the timer to the next player.
#
def PlayKeyControlKeyTab
{
  Say("{orange}Passing timer...");
  Send("PassTimer",NULL);
}

#
# KEYBOARD ACTIONS (PLAY MODE)
# ============================

#
# PlayKeyDelete() - Move a card to discard pile.
#
def PlayKeyDelete
{
  if(input!="")
    InputKeyDelete();
  else
  {
    if(options{"discard_attached"}=="yes" && card.number!=NULL)
    {
      push(object.number);
      for(o)((object_data(object.number))[5])
      {
         object.number=o;
         PlayKeyDelete();
      }
      object.number=pop();
    }

    if(object.number)
    {
      if(Owner(object.number)==me || DELETE_TO_MINE)
        TryTransferTo("deck.top",discard);
      else
	TryTransferTo("deck.top",deck.objects[Owner(object.number)]{"opponent discard pile"});
    }
  }
}

#
# PlayKeyShiftKeyDelete() - Move a card (bottom card if used on a pile) to discard pile.
#
def PlayKeyShiftKeyDelete
{
  if(input!="")
    InputKeyDelete();
  else if (object.type=="deck")
  {
    object.type="bottomdeck";
    
    if(Owner(object.number)==me || DELETE_TO_MINE)
      TryTransferTo("deck.top",discard);
    else
      TryTransferTo("deck.top",deck.objects[Owner(object.number)]{"opponent discard pile"});
  }
  else
    PlayKeyDelete();
}

#
# PlayKeyInsert() - Move a card to hand.
#
def PlayKeyInsert
{
  TryTransferTo("hand",me);
}

#
# PlayKeyHome() - Move a card to top of deck.
#
def PlayKeyHome
{
  if(input!="")
    InputKeyHome();
  else
    TryTransferTo("deck.top",deck);
}

#
# PlayKeyEnd() - Set a card aside.
#
def PlayKeyEnd
{
  if(input!="")
    InputKeyEnd();
  else
    TryTransferTo("active",me);
}

#
# PlayKeyShiftKeyEnd() - Set a card aside (bottom card if used on a pile).
#
def PlayKeyShiftKeyEnd
{
  if(input!="")
    InputKeyEnd();
  else if (object.type=="deck")
  {
    object.type="bottomdeck";
    
    TryTransferTo("active",me);
  }
  else
    PlayKeyEnd();
}

#
# PlayKeyControlKeyS() - Shuffle a hand or pile of cards.
#
def PlayKeyControlKeyS
{
  ClearSearchbox();
  if(object.type=="deck" || object.type=="hand" || object.type=="cardbox")
    Send("ShuffleDeck",object.number);
  else
    Send("ShuffleDeck",deck);
}

#
# PlayKeyControlKeyL() - Look through a pile of cards.
#
def PlayKeyControlKeyL
{
  ClearSearchbox();
  if(object.type=="deck")
  {
    Send("SearchDeck",object.number);
    search.source=object.number;
  }
}

#
# PlayKeyControlKeyF() - Reveal or hide an object.
#
def PlayKeyControlKeyF
{
  if(object.number)
    Send("Flip",object.number);
  if(object.number == hand[me])
  {
    if(has_text(object.number,"{shadow}{orange}Revealed"))
    {
      set_fgcolor(object.number,COLORS{'ORANGE'});
      del_text(object.number,"{shadow}{orange}Revealed");
    }
    else
    {
      set_fgcolor(object.number,COLORS{'GREEN'});
      add_text(object.number,"{shadow}{orange}Revealed");
    }
  }
}

#
# PlayKeyControlKeyP() - Play a card.
#
def PlayKeyControlKeyP
{
  TryTransferTo("play",0);
}

#
# PlayKeyShiftControlKeyP() - Play a card face down.
#
def PlayKeyShiftControlKeyP
{
  TryTransferTo("play",1);
}

#
# PlayKeyControlKeyU() - Untap all cards.
#
def PlayKeyControlKeyU
{
  for(c)(inplay(me))
  {
    if(!IsStayTapped(c))
    {
      if(isfunction("UntapHook"))
      {
        if(call("UntapHook",c))
          Send("Rotate",(c,0));
      }
      else
        Send("Rotate",(c,0));
    }
  }
}

#
# PlayKeyAltKey0() - Select counter color 0 (default: red).
#
def PlayKeyAltKey0
{
  SetCounterColor(0,0);
}

#
# PlayKeyAltKey1() - Select counter color 1 (default: green).
#
def PlayKeyAltKey1
{
  SetCounterColor(1,0);
}

#
# PlayKeyAltKey2() - Select counter color 2 (default: blue).
#
def PlayKeyAltKey2
{
  SetCounterColor(2,0);
}

#
# PlayKeyAltKey3() - Select counter color 3 (default: yellow).
#
def PlayKeyAltKey3
{
  SetCounterColor(3,0);
}

#
# PlayKeyAltKey4() - Select counter color 4 (default: orange).
#
def PlayKeyAltKey4
{
  SetCounterColor(4,0);
}

#
# PlayKeyAltKey5() - Select counter color 5 (default: black).
#
def PlayKeyAltKey5
{
  SetCounterColor(5,0);
}

#
# PlayKeyAltKey6() - Select counter color 6 (default: white).
#
def PlayKeyAltKey6
{
  SetCounterColor(6,0);
}

#
# PlayKeyAltKey7() - Select counter color 7 (default: default "G" counters).
#
def PlayKeyAltKey7
{
  SetCounterColor(7,0);
}

#
# PlayKeyAltKey8() - Select counter color 8 (default: not initialized).
#
def PlayKeyAltKey8
{
  SetCounterColor(8,0);
}

#
# PlayKeyAltKey9() - Select counter color 9 (default: not initialized).
#
def PlayKeyAltKey9
{
  SetCounterColor(9,0);
}

#
# SetCounterColor(color, ignore map?) - Unified function for setting counter color.
#
def SetCounterColor
{
  push(c);
  push(cm);
  if (has_entry("countermap",options) && !ARG[1])
    cm=tostr(options{"countermap"});
  else
    cm="";
  c=ARG[0];
  if(length(cm) > c)
    c=toint(substr(cm,c,1));
  if(MARKER_COLOR[c] == NULL)
    c=DEFAULT_MARKER_COLOR;
    
  Msg(MARKER_COLOR[c]+" counters selected.");
  player.marker_color = c;
  cm=pop();
  c=pop();
}

#
# PlayKeyControlKeyA() - Put a marker on a card.
#
def PlayKeyControlKeyA
{
  if(object.number && object.type!="image")
    Send("AddMarker",(object.number,player.marker_color));      
}

#
# PlayKeyControlKeyD() - Remove a marker from a card.
#
def PlayKeyControlKeyD
{
  push(c);

  if(object.number)
  {
    c=(object_data(object.number))[6];
    if(c{player.marker_color}>0)
      Send("DelMarker",(object.number,player.marker_color));
    else
    {
      c=select("(#)[1]>0",c);
      if(length(c)>0)
        Send("DelMarker",(object.number,(first(c))[0]));
    }
  }

  c=pop();
}

#
# PlayKeyControlKeyT() - Touch an object.
#
def PlayKeyControlKeyT
{
  if(object.number)
  {
    push(i);
    i=-1;
    if(cardbox.card_index != NULL)
      i=cardbox.card_index;
    else if(hand.card_index != NULL)
      i=hand.card_index;
    
    if(object.name=="Deck search box")
      Send("Touch",(search.source,i));
    else
      Send("Touch",(object.number,i));
    i=pop();
  }
}

#
# PlayKeyControlKeyDelete() - Erase a card (move it out of play).
#
def PlayKeyControlKeyDelete
{
  TryTransferTo("out.of.play",);
}

#
# PlayKeyControlKeyHome() - Put a card to the bottom of the deck.
#
def PlayKeyControlKeyHome
{
  TryTransferTo("deck.bottom",deck);
}

#
# PlayKeyControlKeyE() - Declare end of turn.
#
def PlayKeyControlKeyE
{
  Say("{magenta}End of my turn");
  if(isfunction("EndOfTurnHook"))
    call("EndOfTurnHook",NULL);
  Send("PassTimer",NULL);
  Send("PlaySound","notify");
}

#
# KeyControlKeyR() - Roll dice.
#
def KeyControlKeyR
{
  Send("Roll","2d6");
}

#
# KeyControlKeyC() - Flip a coin.
#
def KeyControlKeyC
{
  Send("Roll","coin");
}

#
# PlayKeyAltKeyD() - Duplicate a card.
#
def PlayKeyAltKeyD
{
  push(c);
  c=CheckForCard();
  if(c!=NULL)
  {
    Send("Transfer", (1, ("out.of.play", card.number), ("play", 0)));
  }
  c=pop();
}

#
# MENUS
# =====

#
# Menu(name,entries) - Delete old menu and create new one. Entries are
#   given as triplets (menu text, short cut, code). Either 'code' is
#   executed or appropriate command (if shortcut starts with /) or
#   keyhandler is called.
# 
def Menu
{
  DelMenu();
  SaveMenuContext();
  menu=create_menu(mouse.x,mouse.y,menu.object,ARG[0],ARG[1]);
  set_attr(menu,"ontop",Z_MENU);
  raise(menu);
}

#
# Submenu(name,entries) - Create submenu (same as Menu() right now).
#
def Submenu
{
  Menu(ARG);
}

#
# DelMenu() - Remove current menu if shown.
#
def DelMenu
{
  if(menu)
    del_object(menu);
  menu=NULL;
}

#
# ChooseDeckMenu(group name) - Choose a deck. If group name is given, only show decks from that group.
#
def ChooseDeckMenu
{
  if(length(decks)>0)
  {
    if(length(ARG)>0)
    {
      if(!has_entry(ARG,deck.groups))
        Msg("{red}ERROR: No such group.");
      else if(!length(deck.groups{ARG}))
        Msg("{red}No decks in the group.");
      else
      {
        push(l);
        l=(("{blue}<back>","","ChooseDeckMenu('')"),);
        l=l+forall("(#,)",sort(deck.groups{ARG}));
        Menu("Choose a deck",l);
        l=pop();
      }
    }
    else
    {
      push(l);
      l=forall("('{green}'+#,'','ChooseDeckMenu(#)')",select("length(#)",keys(deck.groups)));
      l=l+forall("(#,)",select("!length(GroupOf(#))",keys(decks)));
      Menu("Choose a deck",l);
      l=pop();      
    }
  }
  else
    Msg("{red}No decks available.");
}

#
# ChooseGroupMenu() - Choose a group to put the current deck in.
#
def ChooseGroupMenu
{
  if(deck.name==NULL)
    Msg("No deck selected.");
  else if(!length(deck.groups))
    Msg("You have no deck groups. You can create one by typing {yellow}/addgroup [groupname]{white}.");
  else
  {
    push(l);
    l=forall("('{green}'+#,'','AddDeckToGroup(#)')",keys(deck.groups));
    l=l+(("{blue}New group...","","Msg('You can create a new group by typing {yellow}/addgroup [groupname]{white}.')"),);
    Menu("Choose a group",l);
    l=pop();
  }
}

#
# ImportDeckMenuEntry(prefix,filename) - Convert a deck filename to an menu entry.
#
def ImportDeckMenuEntry
{
  push(f);
  push(p);
  push(i);

  p=ARG[0];
  f=substr(ARG[1],length(ARG[0]));

  if(find(MyPath()+"import/",f)==0)
    return("{blue}My imports...","","ApplyImportDeck("+tostr(MyPath()+"import/")+")");
  else if(find(MyPath()+"export/",f)==0)
    return("{blue}My exports...","","ApplyImportDeck("+tostr(MyPath()+"export/")+")");
  else
  {
    if(p=="")
       p=DataPath("decks");
    if(find(p,f)==0)
       f=substr(f,length(p));
    i=find("/",f);

    if(i==NULL)
      return(f,"","ApplyImportDeck("+tostr(ARG[1])+")");
    else
      return("{blue}"+left(f,i)+"...","","ApplyImportDeck("+tostr(p+left(f,i)+"/")+")");
  }

  i=pop();
  p=pop();
  f=pop();
}

#
# ApplyImportDeck(path) - Handle menu selection for import deck
#   menu. Check if path ends with / and show a submenu. Otherwise import
#   the selected deck.
#
def ApplyImportDeck
{
  push(d);
  if(right(ARG,1)=="/")
    ImportDeckMenu(ARG);
  else
  {
    d=load_deck(ARG);
    if(d==NULL)
      Msg("{red}Unable to read a deck "+ARG+".");
    else
    {
      push(n);

      Msg("Importing "+ARG+"...");
      d=ImportDeck(d);
      if(typeof(d)=="string")
      {
        Msg("{red}Import failed: "+d+".");
        d=NULL;
        if(length(flatten(values(import.deck)))>0)
          d=import.deck;
      }
      else
        Msg("Deck '"+ARG+"' imported.");

      if(d!=NULL)
      {
        decks{"{blue}Imported Deck{white}"}=d;

        save("decks");
        SelectDeck("{blue}Imported Deck{white}");
        set_attr(deck.box,"visible",1);
        raise(deck.box);
      }

      n=pop();
    }
  }
  d=pop();
}

#
# ApplyImportDeckBack(path) - Handle backing up one level in import path.
#
def ApplyImportDeckBack
{
  push(p);
  push(i);
  p=join(tail(reverse(split(ARG,""))),"");
  i=find("/",p);
  p=join(reverse(split(substr(p,i),"")));
  if(p==MyPath() || p==DataPath("decks"))
    p=NULL;
  ImportDeckMenu(p);  
  i=pop();
  p=pop();
}

#
# ImportDeckMenu([path]) - Show deck import menu. If path is NULL,
#   show the top level. Otherwise the specified sublevel of decks.
#
def ImportDeckMenu
{
  push(p);
  push(d);

  if(ARG==NULL)
    p="";
  else
    p=ARG;

  d=decks();
  d=select("find(p,#)==0",d);
  d=unique(sort(forall("ImportDeckMenuEntry(p,#)",d)));
  if(p!="")
    d=(("{sz12}<back>","","ApplyImportDeckBack("+tostr(p)+")"),)+d;

  Menu("Import deck",d);

  d=pop();
  p=pop();
}

#
# ExportDeckMenu() - Export a deck.
#
def ExportDeckMenu
{
  Menu("Export deck as...",forall('(#+" format","","ExportToFile(decks{deck.name},deck.name,\""+#+"\")")',("Gccg",)+OtherDeckFormats()));
}

#
# GiveCardSubmenu(card number) - Generate menu for giving a card.
#
def GiveCardSubmenu
{
  push(m);
  push(t);
  m=(,);
  t=forall("(#)[1][0]",room.players) - (username,);
  for(p)(sort(t))
  {
    m=m+(("Give {blue}{card"+ARG+"}{black} to {green}"+p,"",'SendMeta("GiveCard",("'+p+'",'+tostr(ARG)+'))'),);
  }
  Submenu("Give {blue}{card"+ARG+"}",m);
  t=pop();
  m=pop();
}

#
# RegisterSubmenu() - Set registration menu.
#
def RegisterSubmenu
{
  push(m);
  push(d);
  m=(,);
  for(s)(sets())
  {
    d=set_data(s);
    m=m+(("Register "+d[0],"/register "+s,""),);
  }
  Submenu("Register Full Set",m);
  d=pop();
  m=pop();
}

#
# RegisterPlaysetSubmenu() - Set registration menu.
#
def RegisterPlaysetSubmenu
{
  push(m);
  push(d);
  m=(,);
  for(s)(sets())
  {
    d=set_data(s);
    m=m+(("Register "+d[0]+" playset","/registerplayset "+s,""),);
  }
  Submenu("Register Playset",m);
  d=pop();
  m=pop();
}

#
# CheckLegalitySubmenu() - Deck legality checking menu.
#
def CheckLegalitySubmenu
{
  push(m);
  m=(,);

  for(r)(keys(deck_rules))
    m=m+(("Check legality for "+r,"","MakeLegalityCheck("+tostr(r)+")"),);

  Submenu("Check Legality",m);

  m=pop();
}

#
# MergeDeckSubmenu() - Show merge deck options.
#
def MergeDeckSubmenu
{
  if(length(decks) > 0)
  {
    if(length(ARG)>0)
    {
      if(!has_entry(ARG,deck.groups))
        Msg("{red}ERROR: No such group.");
      else if(!length(deck.groups{ARG}))
        Msg("{red}No decks in the group.");
      else
      {
        push(l);
        l=(("{blue}<back>","","MergeDeckSubmenu('')"),);
        l=l+forall("(#,'','MergeDeck(#)')",sort(deck.groups{ARG}));
        Menu("Merge deck with...",l);
        l=pop();
      }
    }
    else
    {
      push(l);
      l=forall("('{green}'+#,'','MergeDeckSubmenu(#)')",select("length(#)",keys(deck.groups)));
      l=l+forall("(#,'','MergeDeck(#)')",select("!length(GroupOf(#))",keys(decks)));
      Menu("Merge deck with...",l);
      l=pop();      
    }
  }
  else
    Msg("{red}No decks available.");
}

#
# DisplaySubmenu() - Show display options menu.
#
def DisplaySubmenu
{
  push(m);

  m=(,);
  m=m+(("Default","","SetBookIndex('default','default')"),("{hr}","",""));
  if(length(book.my_filters))
  {
    for(f)(book.my_filters)
    {
       if(length(f)>3)
         m=m+((f[0],"","SetBookIndex("+tostr(f[1])+","+tostr(f[2])+","+f[3]+")"),);
       else
         m=m+((f[0],"","SetBookIndex("+tostr(f[1])+","+tostr(f[2])+")"),);
    }
    m=m+(("{hr}","",""),);
  }
  if(isvar("FILTER_OPTIONS"))
  {
    for(f)(FILTER_OPTIONS)
    {
      if(f=="{hr}")
        m=m+(("{hr}","",""),);
      else
      {
        if(length(f)>3)
          m=m+((f[0],"","SetBookIndex("+tostr(f[1])+","+tostr(f[2])+","+f[3]+")"),);
        else
          m=m+((f[0],"","SetBookIndex("+tostr(f[1])+","+tostr(f[2])+")"),);
      }
    }
  }
  Submenu("Select Display",m);
  m=pop();
}

#
# SectionSubmenu() - Display page title choices.
#
def SectionSubmenu
{
  push(m);
  if(length(book_titles(card.book))>1000)
    Msg("{red}Too many sections.");
  else
  {
    m=(,);
    for(t)(book_titles(card.book))
      m=m+((t[0],"","SetBookPage("+t[1]+")"),);
    Submenu("Select section",m);
  }
  m=pop();
}

#
# MyCollectionMenu() - Generate menu for card book.
#
def MyCollectionMenu
{
  push(e);
  push(b);
  push(i);
  push(t);

  b=(,);
  if(card.number && mode=="play")
  {
    b=b+(
      ("Bring {blue}"+card.name+"{black} to the play","",'Send("Transfer",(1,("out.of.play",card.number),("play",0)))'),
      ("Bring {blue}"+card.name+"{black} to your hand","",'Send("Transfer",(1,("out.of.play",card.number),("hand",me)))'),
      ("{hr}","",""));
  }
  else if(card.number && (mode=="chat" || mode=="watch"))
  {
    e=book_entry(card.book,card.number);

    if(card.name!=NULL && length(room.players) > 1 && (e[0] >= 1 || username=="God" || username=="Judge"))
      b=b+(("Give {blue}"+card.name+"{black} to ...","","GiveCardSubmenu(card.number)"),);
    else
      b=b+(("{gray}Give "+card.name+" to...","",""),);

    if(e[2]!="" && e[2]!=username)
      b=b+(("Buy {blue}"+card.name+"{black} for $"+format('%.2f',e[1]),"",'SetAwayOff();SendMeta("BuyCard",('+card.number+','+e[1]+'))'),);
    else
      b=b+(("{gray}Buy "+card.name,"",""),);

    if(e[4]==0)
      b=b+(("Put one for sale","Ctrl+S",""),("Put one to wanted list","Ctrl+W",""));
    else if(e[4]>0)
      b=b+(("Add one for sale","Ctrl+S",""),("Delete one for sale","Ctrl+W",""));
    else
      b=b+(("Delete one from wanted list","Ctrl+S",""),("Add one to wanted list","Ctrl+W",""));

    b=b+(("{hr}","",""),("Add one to the current deck section","middle click",""),("Delete one from the current deck section","left click",""));
    if(deck.name != NULL && has_entry(deck.name,decks))
    {
      for(p)(keys(decks{deck.name}))
      {
        b=b+(("Add one to the {blue}"+p,"","SelectDeckPart("+tostr(p)+"); EditAdd("+tostr(p)+",card.number)"),);
      }
    }
    b=b+(("Show card text w/ errata","Ctrl+H",""),);
    b=b+(("Search for other versions","","CommandSets(card.name)"),);
  }
  else
  {
    if(isvar("FILTER_OPTIONS") || length(book.my_filters)>0)
      b=b+(("Select display...","","DisplaySubmenu()"),);
    else
      b=b+(("Default display","","SetBookIndex('default','default')"),);

    if(length(book_titles(card.book)) > 1)
      b=b+(("Goto section...","","SectionSubmenu()"),);
    else
      b=b+(("{gray}Goto section...","",""),);

    if(IsUserDisplay())
      b=b+(("Destroy this display","","DestroyUserDisplay()"),);
    else
      b=b+(("{gray}Destroy this display","",""),);
  }

  b=b+(("{hr}","",""),);
  if(length(book.history)>0)
    b=b+(("Previous display","","BookGoBack()"),);
  else
    b=b+(("{gray}Previous display","",""),);

  b=b+(("Previous page","Page Up",""),("Next page","Page Down",""),("Previous section","Ctrl+Page Up",""),("Next section","Ctrl+Page Down",""));
  b=b+(("Close","Esc",'set_attr(card.book,"visible",0)'),);

  Menu("My Collection Menu",b);

  t=pop();
  i=pop();
  b=pop();
  e=pop();
}

#
# SaveMenuContext() - Save GUI object variables.
#
def SaveMenuContext
{
  menu.object.name=object.name;
  menu.object.number=object.number;
  menu.object.type=object.type;
  menu.card.number=card.number;
  menu.cardbox.card_index=cardbox.card_index;
  menu.listbox.index=listbox.index;
  menu.hand.card_index=hand.card_index;
  menu.card.name=card.name;
  menu.card.number=card.number;
  menu.cardbox.card_index=cardbox.card_index;
}

#
# RestoreMenuContext() - Restore saved GUI object variables.
#
def RestoreMenuContext
{
  object.name=menu.object.name;
  object.number=menu.object.number;
  object.type=menu.object.type;
  card.number=menu.card.number;
  cardbox.card_index=menu.cardbox.card_index;
  listbox.index=menu.listbox.index;
  hand.card_index=menu.hand.card_index;
  card.name=menu.card.name;
  card.number=menu.card.number;
  cardbox.card_index=menu.cardbox.card_index;
}

#
# MenuByContext() - Deside which menu to show according to GUI variables.
#
def MenuByContext
{
  if(menu!=NULL)
    DelMenu();
  else if(object.type == "menu")
    DelMenu();
  elseif(object.name != NULL)
  {
    SaveMenuContext();
    if(isfunction(ucfirst(mode)+tofnc(object.name)+"Menu"))
      call(ucfirst(mode)+tofnc(object.name)+"Menu",NULL);
    else if(isfunction(tofnc(object.name)+"Menu"))
      call(tofnc(object.name)+"Menu",NULL);
    else if(right(object.name,7)=="booster" || right(object.name,7)=="starter" || right(object.name,5)==" pack" || right(object.name,4)==" set")
      Menu(object.name,(("Buy one","left click",""),("Buy one and open","middle click","")));
    else if(object.type=="card")
    {
      if(mode=="watch")
         WatchCardMenu();
      else
        CardMenu();
    }
    else if(left(object.name,7)=="Player ")
    {
      push(p);
      push(m);
      p=right(object.name,length(object.name)-7);
      m=(("Show player info","/whois "+p,""),("Show want list","/want "+p,""),("Show have list","/have "+p,""),("{hr}","",""));

      if(p==username)
        m=m+(("{gray}Start private chat","",""),("Mark away","/away Away",""),("Mark here","/away",""));
      else
        m=m+(("Start private chat","/pm "+p,""),("{gray}Mark away","",""),("{gray}Mark here","",""));

      Menu("Player: "+p,m);
      m=pop();
      p=pop();
    }
    else if(mode=="play" && object.type=="image")
    {
      Menu("Player: "+object.name,(("Touch","Ctrl+T",""),));
    }
    else if(find(object.name,forall("(#)[1][0]",room.players))!=NULL)
    {
      Menu("Player: "+object.name,(("Show player info","/whois "+object.name,""),));
    }
    else if(has_entry(ucfirst(object.name),MENU))
      Menu(ucfirst(object.name),ConstructMenu(ucfirst(object.name)));
    else
      Menu("Main Menu - "+ucfirst(mode),ConstructMenu("Main Menu - "+ucfirst(mode)));
  }
  else
    Menu("Main Menu - "+ucfirst(mode),ConstructMenu("Main Menu - "+ucfirst(mode)));
}

#
# ConstructMenu(context) - Construct a menu and return a menu for the given
#   context by integrating standard entries (MENU variable), game specific entries
#   (GAME_MENU variable) and extension defined entries (EXTRA_MENU variable)
#   together. A context parameter is one of the following:
#   - 'Main Menu - Chat' chat mode main menu.
#   - 'Main Menu - Play' play mode main menu.
#   - 'Main Menu - Watch' watch mode main menu.
#   - 'Current Deck Menu' deck editor.
#   - 'Tap a card' menu used instead of default tapping menu.
#   - 'A card' - menu added to card in play menu.
#   - 'Deck Draw' - Additional deck menu card draw entries.
#   - 'Table' - game table menu.
#   - 'Open Booster' - opened booster menu.
#   - 'Hand' - my hand menu.
#   - 'Products' - products menu.
#
def ConstructMenu
{
  push(m);
  push(q);
  q=(,);
  m=(,);

# Look for applicable context menu items

  if(server.meta==NULL)
    m=m+((1,"{red}Reconnect to server","/reconnect",""),);
  elseif(!net_isopen(server.meta))
    m=m+((1,"{red}Reconnect to server","/reconnect",""),);
  elseif(server==NULL && mode=="play")
    m=m+((1,"{red}Go back to main server","","SetMode('chat')"),);
  elseif(!net_isopen(server) && mode=="play")
    m=m+((1,"{red}Go back to main server","","SetMode('chat')"),);

  elseif(ARG=="Main Menu - Chat" && right(username,7)=="-sealed")
    m=((1,"Leave sealed mode","/sealed end",""),);

  if(length(m))
    m=m+((1,"{hr}","",""),);

# Construct menu list 'm'

  if(has_entry(ARG,MENU))
    m=m+MENU{ARG};

  if(length(m))
  {
    push(e);
    e=last(m);
    if(e[1]=="Quit" || e[1]=="Leave")
    {
      q=(last(m),);
      m=head(m);
    }
    e=pop();
  }

  if(has_entry(ARG,GAME_MENU))
    m=m+GAME_MENU{ARG};
  if(has_entry(ARG,EXTRA_MENU))
    m=m+EXTRA_MENU{ARG};

  m=m+q;
  q=(,);

# Make gray entries and copy to 'q'

  for(e)(m)
  {
    if(eval(e[0]))
      q=q+(tail(e),);
    else
      q=q+(("{gray}"+e[1],"",""),);
  }

# Eval short cuts and copy to 'm'
  m=(,);
  for(e)(q)
  {
    if(left(e[1],5)=="EVAL:")
      e[1]=eval(substr(e[1],5));
    m=m+(e,);
  }

  return(m);

  q=pop();
  m=pop();
}

#
# OpenBoosterMenu() - Menu for just opened booster.
#
def OpenBoosterMenu
{
  Menu(object.name,ConstructMenu("Open Booster"));
}

#
# TableMenu() - Menu for tables.
#
def TableMenu
{
  Menu("Table Menu",ConstructMenu("Table"));
}

#
# CardSelectBoxMenu() - Menu for card selector.
#
def CardSelectBoxMenu
{
  Menu("{blue}"+canonical_name(card.number),ConstructMenu("Card Select Box"));
}

#
# CurrentDeckMenu() - Menu for current deck editor operations.
#
def CurrentDeckMenu
{
  push(m);
  m=(,);

  if(EditCardname()!=NULL)
  {
    push(n);
    n=EditNearestPartname();
    m=m+(("Add one {blue}"+EditCardname(),"middle click",""),("Delete one {blue}"+EditCardname(),"left click",""));
    for(p)(keys(decks{deck.name}))
    {
      if(n!=p)
        m=m+(("Move one {blue}"+EditCardname()+"{black} to {green}"+p,"","EditMove('"+n+"','"+p+"',"+tostr(EditCardname())+")"),);
    }
    m=m+(("Find card","/find "+EditCardname(),""),);
    n=pop();
  }
  else if(EditPartname()!=NULL)
  {
    m=m+(("Select {blue}"+EditPartname()+"{black} under construction","left click",""),);
  }
  else
  {
    m=m+(("Destroy this deck","/deletedeck",""),("Select another deck","Ctrl+D",""),("Export deck","Ctrl+X",""),("Move deck to a group...","","ChooseGroupMenu()"));
    if(length(GroupOf(deck.name))>0)
      m=m+(("Remove deck from group","","RemoveDeckFromGroup(0)"),);
    else
      m=m+(("{gray}Remove deck from group","",""),);
    
    if(length(OtherDeckFormats())>0)
      m=m+(("Export deck as...","","ExportDeckMenu()"),);
    else
      m=m+(("{gray}Export deck as...","",""),);

    if(length(deck_rules)==1)
      m=m+(("Check legality for "+deck_rules[0][0],"","MakeLegalityCheck("+tostr(deck_rules[0][0])+")"),);
    else
      m=m+(("Check legality...","","CheckLegalitySubmenu()"),);
    m=m+(("Add cards from another deck...","","MergeDeckSubmenu('')"),
         ("Remove all cards","/erasedeck",""),("Undo change","Ctrl+Z",""),("Redo change","Ctrl+Y",""));
    
  }

  m=m+(("{hr}","",""),("Scroll up","Page Up",""),("Scroll down","Page Down",""),("Close","Esc",'set_attr(deck.box,"visible",0)'));
  for(p)(keys(decks{deck.name}))
  {
    if(p!="deck")
      m=m+(("Remove {blue}"+p+"{black} section","","RemoveDeckPart('"+p+"')"),);
  }

  m=m+ConstructMenu("Current Deck Menu");

  Menu("Current Deck Menu",m);
  m=pop();
}

#
# MenuClick() - Handle menu event.
#
def MenuClick
{
  push(k);
  DelMenu();

  if(menu.action!="")
  {
    RestoreMenuContext();
    eval(menu.action);
  }
  else if(isfunction("SelectMenu"+tofnc(object.name)))
  {
    call("SelectMenu"+tofnc(object.name),NULL);
  }
  else if(menu.shortcut=="left click")
  {
    RestoreMenuContext();
    MouseLeftClick();
  }
  else if(menu.shortcut=="middle click")
  {
    RestoreMenuContext();
    MouseMiddleClick();
  }
  else if(menu.shortcut=="Ctrl+left click")
  {
    RestoreMenuContext();
    MouseControlLeftClick();
  }
  else if(menu.shortcut=="Ctrl+middle click")
  {
    RestoreMenuContext();
    MouseControlMiddleClick();
  }
  else
  {
    if(left(menu.shortcut,1)=="/")
      SlashCommand(menu.shortcut);
    else 
    {
      k=menu.shortcut;
      if(left(k,5)=="Ctrl+")
        k="control key "+substr(k,5);
      if(left(k,4)=="Alt+")
        k="alt key "+substr(k,4);
      if(left(k,6)=="Shift+")
        k="shift key "+substr(k,6);
      
      if(k!="")
      {
        RestoreMenuContext();
        if(!PressKey(lc(k),""))
        {
          if(object.name!=NULL)
          {
            if(trigger(k,object.name)==NULL)
              trigger(k,"");
          }
          else
            trigger(k,"");
        }
      }
    }
  }
  k=pop();
}

#
# MENU SELECTION EVENTS
# =====================
 
#
# SelectMenuChooseADeck() - Handler for selection from deck menu.
#
def SelectMenuChooseADeck
{
  SelectDeck(menu.text);
  set_attr(deck.box,"visible",1);
  raise(deck.box);
}

#
# MENUS (PLAY MODE)
# =================

#
# SingleCardMenu(context) - Return menu items for single card.
#
def SingleCardMenu
{
  push(m);
  m=(,);

  if(card.number!=NULL)
  {

    m=m+(("Play {blue}"+card.name,"Ctrl+P",""),);
    m=m+(("Play {blue}"+card.name+"{black} face down","","TryTransferTo('play',1)"),);

    if(isfunction("SingleCardMenuHook"))
      m=m+call("SingleCardMenuHook",ARG);

    for(i)(
        ("hand","Put to hand","Insert",""),
  		("discard","Discard","Delete",""),
  	  	("deck","Put to the top of the deck","Home",""),
  	  	("deck","Put to the bottom of the deck","Ctrl+Home",""),
  	  	("aside","Set aside","End",""),
  	  	("all","Remove from the game","Ctrl+Delete",""),
    	("all","Show card text w/ errata","Ctrl+H",""),
    	("all","Play duplicate","Alt+D",""),
        )
    {
      if(ARG!=first(i))
        m=m+(tail(i),);
    }

    m=m+ConstructMenu("A Card");
  }
  return(m);
  m=pop();
}

#
# HandMenu() - Create a menu for your hand.
#
def HandMenu
{
  push(m);

  m=(,);

  if(card.number!=NULL)
  {
    m=m+SingleCardMenu("hand");
    m=m+(("{hr}","",""),);
  }

  m=m+ConstructMenu("Hand");

  if(card.number!=NULL)
    Menu("Hand / {blue}"+card.name,m);
  else
    Menu("Hand",m);

  m=pop();
}

#
# OpponentHandMenu() - Create a menu for your opponent's hand.
#
def OpponentHandMenu
{
  push(m);
  m=(,);
  if(card.number!=NULL)
  {
    m=m+(
	("Force discard","",'Send("Transfer",(1,("hand",Owner(object.number),hand.card_index),("deck.top",deck.objects[Owner(object.number)]{"opponent discard pile"})))'),
	("Reveal card","",'Send("Reveal",(object.number,hand.card_index))'),
	("Set aside","",'Send("Transfer",(1,("hand",Owner(object.number),hand.card_index),("active",me)))'),
    ("{hr}","","")
	);
  }
  m=m+(
	("Show/Hide cards","left click",""),
    ("Touch","Ctrl+T",""),
  );

  Menu("Hand",m);
  m=pop();
}

#
# ActiveSetMenu() - Create a menu for your cards set aside.
#
def ActiveSetMenu
{
  push(m);
  m=(,);
  if(card.number!=NULL)
  {
    m=m+SingleCardMenu("aside");

    for(i)(players)
    {
      if(i != me)
        m=m+(("Put to the top of player {blue}"+player.name{i}+"{black}'s deck","",'TryTransferTo("deck.top",'+deck.objects[i]{"opponent deck"}+')'),);
    }

    m=m+(
      ("{hr}","",""),);
  }
  m=m+(
	("Reveal/Hide card(s)","Ctrl+F",""),
	("Shuffle to the deck","",'Send("Transfer",(length(cardbox(active[me])),("active",me,0),("deck.top",deck))); Send("ShuffleDeck",deck);'),
	("Shuffle and put to the top of the deck","",'Send("Transfer",(length(cardbox(active[me])),("active",me,0),("deck.top",deck),(("shuffle","yes"),)))'),
	("Shuffle and put to the bottom of the deck","",'Send("Transfer",(length(cardbox(active[me])),("active",me,0),("deck.bottom",deck),(("shuffle","yes"),)))'),);

  for(i)(players)
  {
    if(i != me)
      m=m+(
	("Shuffle and put to the top of player {blue}"+player.name{i}+"{black}'s deck","",'Send("Transfer",(length(cardbox(active[me])),("active",me,0),("deck.top",'+tostr(deck.objects[i]{"opponent deck"})+'),(("shuffle","yes"),)))'),
	("Shuffle and put to the bottom of player {blue}"+player.name{i}+"{black}'s deck","",'Send("Transfer",(length(cardbox(active[me])),("active",me,0),("deck.bottom",'+tostr(deck.objects[i]{"opponent deck"})+'),(("shuffle","yes"),)))'),);
  }

  m=m+(
    ("Touch","Ctrl+T",""),
	);

  Menu("Cards set aside",m);
  m=pop();
}

#
# OpponentActiveSetMenu() - Create a menu for opponent's cards set aside.
#
def OpponentActiveSetMenu
{
  push(m);
  m=(,);
  if(card.number!=NULL)
  {
    m=m+SingleCardMenu("aside");

    for(i)(players)
    {
      if(i != me)
        m=m+(("Put to the top of player {blue}"+player.name{i}+"{black}'s deck","",'TryTransferTo("deck.top",'+deck.objects[i]{"opponent deck"}+')'),);
    }

    m=m+(
      ("Touch","Ctrl+T",""),
	 );
  }

  Menu("Cards set aside",m);
  m=pop();
}

#
# DiscardPileMenu() - Create menu for your discard pile.
#
def DiscardPileMenu
{
  push(m);
  m=(,);
  if(card.number!=NULL)
  {
    m=m+SingleCardMenu("discard");

    m=m+(
      ("{hr}","",""),
	  ("Look","Ctrl+L",""),
	  ("Shuffle","Ctrl+S",""),
      );
  }

  m=m+(
	("Reveal/Hide pile","Ctrl+F",""),
	("Shuffle to the deck","",'Send("Transfer",(length(deck(deck.objects[me]{"discard pile"})),("deck.top",discard),("deck.top",deck))); Send("ShuffleDeck",deck);'),
        ("Touch","Ctrl+T",""),
	);

  m=m+ConstructMenu("Discard Pile");  
	
  Menu("Discard pile",m);
  m=pop();
}

#
# OpponentDiscardPileMenu() - Create menu for opponent's discard pile.
#
def OpponentDiscardPileMenu
{
  push(m);
  m=(,);
  if(card.number!=NULL)
  {
    m=m+(
	  ("Look","Ctrl+L",""),
      );
  }

  m=m+(
    ("Touch","Ctrl+T",""),
  );

  Menu("Opponent's Deck",m);
  m=pop();
}

#
# DeckMenu() - Create menu for your deck.
#
def DeckMenu
{
  push(m);
  m=(,);
  if(card.number!=NULL)
  {
    if(length(ConstructMenu("Deck Draw")))
	{
		m=m+ConstructMenu("Deck Draw");
	}
	else
	{
      m=m+(
	    ("Draw a card","left click",""),
	    ("Draw "+HANDSIZE+" cards","",'Send("Transfer",(HANDSIZE,("deck.top",deck),("hand",me)))'),
        );
	}
	
    m=m+(
      ("{hr}","",""),
      );

   m=m+SingleCardMenu("deck");

   m=m+(
      ("{hr}","",""),
	  ("Look","Ctrl+L",""),
	  ("Shuffle","Ctrl+S",""),
	  ("Set aside bottom card","Shift+End",""),
      );
  }

  m=m+(
	("Reveal/Hide deck","Ctrl+F",""),
    ("Touch","Ctrl+T",""),
	);

  Menu(ucfirst(object.name),m);
  m=pop();
}

#
# OpponentDeckMenu() - Create menu for opponent's deck.
#
def OpponentDeckMenu
{
  push(m);
  m=(,);
  if(card.number!=NULL)
  {
    m=m+(
	  ("Look","Ctrl+L",""),
	  ("Set aside the topmost card","End",""),
	  ("Set aside bottom card","Shift+End",""),
      ("{hr}","","")
      );
  }

  m=m+(
    ("Touch","Ctrl+T",""),
  );

  Menu("Opponent's Deck",m);
  m=pop();
}

#
# DeckSearchBoxMenu() - Create menu for deck search box.
#
def DeckSearchBoxMenu
{
  if(isfunction(ucfirst(object_name(search.source))+"SearchBoxMenuHook"))
    call(ucfirst(object_name(search.source))+"SearchBoxMenuHook",NULL);
  else
  {
    push(m);
    m=(,);
    if(card.number!=NULL)
    {
      if(search.source==deck)
        m=m+SingleCardMenu("deck")+(("{hr}","",""),);
      else if(search.source==discard)
        m=m+SingleCardMenu("discard")+(("{hr}","",""),);
      else
        m=m+SingleCardMenu("none")+(("{hr}","",""),);
    }
  
    m=m+(
      ("Touch","Ctrl+T",""),
  	("Close","Escape",""),
  	);
  
    Menu("Look at "+object_name(search.source),m);
    m=pop();
  }
}

#
# CardMenu() - Create a menu for single card in play.
#
def CardMenu
{
  push(m);
  push(n);
  m=(,);
  n=card.name;

  if(card.number!=NULL)
  {
    m=ConstructMenu("Tap a card");
    if(length(m) < 1)
      m=(("Tap/Untap","middle click",""),("Keep tapped","","SetStayTapped()"),("Keep untapped","","SetStayUntapped()"));

    for(t)(TargetingOptions())
      m=m+(("Attach like "+join(t," / "),"","ManualTarget("+object.number+","+tostr(t)+")"),);

    m=m+(("{hr}","",""),)+SingleCardMenu("inplay")+(("{hr}","",""),);

	if(isfunction("CardMenuHook"))
      m=m+call("CardMenuHook",ARG);
    else
	  m=m+(
  	    ("Reveal/Hide","Ctrl+F",""),
  	    ("Add one counter","Ctrl+A",""),
  	    ("Remove one counter","Ctrl+D",""),
        ("Touch","Ctrl+T",""),
        );
  }

  if(length(m))
    Menu(n,m);

  n=pop();
  m=pop();
}

#
# CounterSubmenu() - Choose a counter color.
#
def CounterSubmenu
{
  Submenu("Select counter color",(
    ("Red","Alt+0","SetCounterColor(0,1)"),
    ("Green","Alt+1","SetCounterColor(1,1)"),
    ("Blue","Alt+2","SetCounterColor(2,1)"),
    ("Yellow","Alt+3","SetCounterColor(3,1)"),
    ("Orange","Alt+4","SetCounterColor(4,1)"),
    ("Black","Alt+5","SetCounterColor(5,1)"),
    ("White","Alt+6","SetCounterColor(6,1)"),
    ("Default","Alt+7","SetCounterColor(7,1)"),
  ));
}

#
# MENUS (WATCH MODE)
# =================

#
# WatchHandMenu() - Nothing.
#
def WatchHandMenu
{
}

#
# WatchOpponentHandMenu() - Nothing.
#
def WatchOpponentHandMenu
{
}

#
# WatchActiveSetMenu() - Nothing.
#
def WatchActiveSetMenu
{
}

#
# WatchDiscardPileMenu() - Nothing.
#
def WatchDiscardPileMenu
{
}

#
# WatchDeckMenu() - Nothing.
#
def WatchDeckMenu
{
}

#
# WatchOpponentDiscardPileMenu() - Create opponent's discard pile menu
#  during watch mode.
#
def WatchOpponentDiscardPileMenu
{
  WatchCardMenu();
}

#
# WatchOpponentDeckMenu() - Create deck menu during watch mode.
#
def WatchOpponentDeckMenu
{
  WatchCardMenu();
}

#
# WatchDeckSearchBoxMenu() - Create deck search box menu during watch mode.
#
def WatchDeckSearchBoxMenu
{
  WatchCardMenu();
}

#
# WatchCardMenu() - Create single card menu during watch mode.
#
def WatchCardMenu
{
  if(card_back(card.number)!=card.number && card.number!=NULL)
  {
    Menu(card.name,(
    ("Show card text w/ errata","Ctrl+H",""), 
    ("{hr}","",""),
    ("Find from collection","/find "+canonical_name(card.number),""),
    ));
  }
}

#
# MOUSE (GENERIC)
# ===============

#
# MouseMiddleClick() - Handle middle click event.
#
def MouseMiddleClick
{
  if(object.name != NULL)
  {
    push(p);
    p=products;
    if(p==NULL)
      p=(,);
    if(has_entry(object.name,p))
    {
      set_fgcolor(object.number,(255,255,255));
      AddTimer(1,'set_fgcolor('+object.number+',BRCOLOR)');
      booster.open_at_once=1;
      booster.manual_buy=0;
      SendMeta("Buy",(1,object.name));
    }
    else if(isfunction("MouseMiddleClick"+tofnc(object.name)))
      call("MouseMiddleClick"+tofnc(object.name),NULL);
    else if(isfunction("MouseMiddleClick"+tofnc(object.type)))
      call("MouseMiddleClick"+tofnc(object.type),NULL);
    p=pop();
  }
}

#
# MouseLeftClick() - Handle left click event.
#
def MouseLeftClick
{
  if(object.number==NULL)
  {
    DelMenu();
    if(mode=="chat")
      if(room.players{me}[2] >= 0)
        ChatCommandLeavetable();
  }
  else
  {
    push(p);
    p=products;
    if(p==NULL)
      p=(,);
    if(has_entry(object.name,p))
    {
      set_fgcolor(object.number,(255,255,255));
      AddTimer(1,'set_fgcolor('+object.number+',BRCOLOR)');
      booster.open_at_once=0;
      booster.manual_buy=0;
      SendMeta("Buy",(1,object.name));
    }
    else if(isfunction("MouseLeftClick"+tofnc(object.name)))
      call("MouseLeftClick"+tofnc(object.name),NULL);
    else if(isfunction("MouseLeftClick"+tofnc(object.type)))
      call("MouseLeftClick"+tofnc(object.type),NULL);
    p=pop();
  }
}

#
# MouseControlLeftClick() - Handle control+left click event.
#
def MouseControlLeftClick
{
  if(object.type=="card")
    Send("Detach",object.number);
  else if(isfunction("MouseControlLeftClick"+tofnc(object.name)))
    call("MouseControlLeftClick"+tofnc(object.name),NULL);
  else if(isfunction("MouseControlLeftClick"+tofnc(object.type)))
    call("MouseControlLeftClick"+tofnc(object.type),NULL);
}

#
# MouseControlMiddleClick() - Handle control+middle click event.
#
def MouseControlMiddleClick
{
  if(object.number)
  {
    if(isfunction("MouseControlMiddleClick"+tofnc(object.name)))
      call("MouseControlMiddleClick"+tofnc(object.name),NULL);
    else if(isfunction("MouseControlMiddleClick"+tofnc(object.type)))
      call("MouseControlMiddleClick"+tofnc(object.type),NULL);
    else
    {
      if(card.name!=NULL && card_back(card.number) != card.number)
        Input("'"+card.name+"' ");
      else if(card.number!=NULL && object.number!=NULL)
         Input("'"+name((card_data(object.number))[3])+"' ");
      else if(object.name != NULL && object.name != "")
      {
        if(left(object.name,7)=="Player ")
          Input(right(object.name,length(object.name)-7)+" ");
        else if(object.name=="table")
          Input("Table "+TableNumber(object.number)+" ");
        else
          Input(object.name+" ");
      }
    }
  }
}

#
# MouseWheel(dir) - Mouse wheel rolled (dir=0 up, dir=1 down).
#
def MouseWheel
{
  if(object.name==NULL)
    object.name="none";

  if(isfunction("MouseWheel"+tofnc(object.name)))
    call("MouseWheel"+tofnc(object.name),ARG);
  else if(isfunction("MouseWheel"+tofnc(object.type)))
    call("MouseWheel"+tofnc(object.type),ARG);
  else
  {
    if(ARG)
      msgbox_scroll(msg.box,1);
    else
      msgbox_scroll(msg.box,-1);
  }
}

#
# MouseLeftDragBegin() - The beginning of mouse dragging using left button.
#
def MouseLeftDragBegin
{
  if(object.number) 
  {
    dragging=1;
    dragging.highlight=set_attr(object.number,"highlight",1);
    raise(object.number);
    if(mode=="play")
      Send("Raise",object.number);
  }
}

#
# MouseLeftDragEnd() - The end of mouse dragging using left button.
#
def MouseLeftDragEnd
{
  if(dragging) 
  {
    dragging=0;
    set_attr(object.number,"highlight",dragging.highlight);
  }
}

#
# MouseMiddleDragBegin() - The beginning of mouse dragging using middle button.
#
def MouseMiddleDragBegin
{
  push(c);

  c=CheckForCard();
  if(c!=NULL && mode=="chat")
  {
    set_attr(drag.box,"visible",0);
    put_cardbox(drag.box,c);
    raise(drag.box);
    move_object(drag.box,mouse.x-ObjW(drag.box)/2,mouse.y-ObjH(drag.box)/2);
    set_attr(drag.box,"visible",1);
    Msg("START TRANSFER (this is future expansion)");
  }

  c=pop();
}

#
# MouseMiddleDragEnd() - The end of mouse dragging using middle button.
#
def MouseMiddleDragEnd
{
  if(length(cardbox(drag.box))>0)
  {
    del_cardbox(drag.box,0);
    Msg("STOP TRANSFER (this is future expansion)");
  }
}

#
# MouseControlLeftDragBegin() - The beginning of mouse dragging using ctrl+left button.
#
def MouseControlLeftDragBegin
{
  if(object.type=="card")
    attach.object=object.number;
}

#
# MouseControlLeftDragEnd() - The end of mouse dragging using ctrl+left button.
#
def MouseControlLeftDragEnd
{
  if(object.type=="card")
    Send("Attach",(attach.object,object.number));
}

#
# MouseLeftClickCardSelectBox() - Apply the selector expression to
#  the selected card.
#
def MouseLeftClickCardSelectBox
{
  forall(select.expression,(card.number,));
  del_cardbox_all_recenter(select.box);
}

#
# MouseMove - Called when the mouse is moved.
#
def MouseMove
{
	if(find("shift",modifier) && info.persistent==0)
	{
		push(c);
		c=CheckForCard();
		if(c!=NULL)
		{
			if(find("ctrl",modifier) && length(Attr("flipid",c)))
				c=toint(Attr("flipid",c));
			if(info.current==NULL)
			{
				raise(info.box);
				put_cardbox(info.box,c);
				info.current=c;
			}
			else if(c!=info.current)
			{
				replace_cardbox(info.box,c);
				info.current=c;
			}
		}
		else if(info.current!=NULL)
		{
			del_cardbox(info.box,0);
			info.current=NULL;
		}
		c=pop();
	}
	else if(info.persistent==1)
	{
		push(c);
		c=CheckForCard();
		if(c!=NULL)
		{
			if(find("ctrl",modifier) && length(Attr("flipid",c)))
				c=toint(Attr("flipid",c));
			if(info.current==NULL)
			{
				raise(info.box);
				put_cardbox(info.box,c);
				info.current=c;	    
			}
			else if(c!=info.current)
			{
				replace_cardbox(info.box,c);
				info.current=c;
			}
		}
		c=pop();
	}
}

#
# MOUSE (CHAT MODE)
# =================

#
# SelectDeckPart(part) - Select default editing section.
#
def SelectDeckPart
{
  if(decks != NULL && has_entry(deck.name,decks) && ARG != deck.part)
  {
    deck.part=ARG;
    Msg("Deck part '"+ARG+"' selected.");
    undo_buffer=(,);
    undo.pos=-1;
  }
}

#
# MouseMiddleClickCurrentDeck() - Add a card to the deck.
#
def MouseMiddleClickCurrentDeck
{
  raise(object.number);
  if(deck.name!=NULL)
  {
    if(EditCardname()!=NULL)
    {
      SelectDeckPart(EditNearestPartname());
      EditAdd(deck.part,EditCardname());
    }
  }
}

#
# MouseLeftClickCurrentDeck() - Remove a card from the deck.
#
def MouseLeftClickCurrentDeck
{
  raise(object.number);
  if(deck.name!=NULL)
  {
    push(e);
    e=EditPartname();

    if(EditCardname()!=NULL)
    {
      SelectDeckPart(EditNearestPartname());
      EditDel(deck.part,EditCardname());
    }
    else if(e!=NULL)
    {
      SelectDeckPart(e);
    }
    e=pop();
  }
}

#
# MouseWheelCurrentDeck(dir) - Scroll deck list (0=up, 1=down).
#
def MouseWheelCurrentDeck
{
  if(ARG)
    KeyPageDown();
  else
    KeyPageUp();
}

#
# MouseWheelMyCollection(dir) - Scroll through card book pages (0=up, 1=down).
#
def MouseWheelMyCollection
{
  if(ARG)
    KeyPageDown();
  else
    KeyPageUp();
}

#
# MouseWheelMenu(dir) - Scroll through menu box (0=up, 1=down).
#
def MouseWheelMenu
{
  push(o);
  o=object_data(object.number);
  move_object(object.number,o[0],o[1]+(32-ARG*64));
  o=pop();
}

#
# MouseWheelChatMsg(dir) - Scroll through secondary chat box (0= up, 1=down).
#
def MouseWheelChatMsg
{
  if(ARG)
    msgbox_scroll(chat_msg.box,1);
  else
    msgbox_scroll(chat_msg.box,-1);
}

#
# MouseLeftClickMyCollection() - Remove a card from the deck.
#
def MouseLeftClickMyCollection
{
  push(ok);
  raise(object.number);
  if(book.tab!=NULL)
  {
    book_set_slot(object.number,(book_titles(object.number))[book.tab][0]);
    SetBookPage(((book_titles(object.number))[book.tab])[1]);
  }
  else if(deck.name != NULL && card_back(card.number)!=card.number && card.number!=NULL)
  {
    if(deck.part==NULL)
      SelectDeckPart("deck");
    if(!EditDel(deck.part,card.number))
    {
      ok=0;
      for(p)(keys(decks{deck.name}))
      {
        if(!ok)
        {
          if(EditDel(p,card.number))
          {
            SelectDeckPart(p);
            ok=1;
          }
        }
      }
    }
  }
  ok=pop();
}

#
# MouseMiddleClickMyCollection() - Add a card to the deck.
#
def MouseMiddleClickMyCollection
{
  raise(object.number);
  if(deck.name != NULL && card_back(card.number)!=card.number && card.number!=NULL)
  {
    if(deck.part==NULL)
      SelectDeckPart("deck");
    EditAdd(deck.part,card.number);
  }
}

#
# MouseMiddleClickTable() - Set ready-to-play signal if sitting at table.
#
def MouseMiddleClickTable
{
  if(deck.name==NULL && length(room.tables{TableNumber(object.number)}[6])<room.tables{TableNumber(object.number)}[5])
    Msg("{red}Please select deck first or create new one using command /newdeck <deck name>.");
  else if(room.players{me}[2]==TableNumber(object.number))
  {
    SetAwayOff();
    Send("ToggleJoinGame",NULL);
  }
}

#
# MouseMiddleClickOpenBooster() - Reveal all cards in booster.
#
def MouseMiddleClickOpenBooster
{
  if(length(booster)>0)
  {
    booster.visible=booster;
    replace_cardbox_recenter(booster.box,booster.visible);
  }
}

#
# MouseLeftClickTable() - Sit at a table.
#
def MouseLeftClickTable
{
  SetAwayOff();
  Send("JoinTable",TableNumber(object.number));
}

#
# MouseLeftClickOpenBooster() - Reveal single card in booster.
#
def MouseLeftClickOpenBooster
{
  raise(object.number);
  if(length(booster)>0 && cardbox.card_index!=NULL)
  {
    booster.visible[cardbox.card_index]=booster[cardbox.card_index];
    replace_cardbox_recenter(booster.box,booster.visible);
  }
}

#
# MOUSE (PLAY MODE)
# =================

#
# MouseMoveObject() - Handler for moving objects using mouse.
#
def MouseMoveObject
{
  push(x);
  push(y);

  x=object.x;
  y=object.y;
  
  if(object.number==info.box)
  {
    info.x=(object_data(info.box))[0];
    info.y=(object_data(info.box))[1];
  }

  if(me>1)
    x=x-((me/2) * BASE_TABLE_WIDTH / ((players + 1) / 2));

  if(mode=="play" && (object.type=="card" || object.type=="deck" || object.type=="image"))
    Send("MoveObject",(object.number,x,y));

  y=pop();
  x=pop();
}

#
# MouseMiddleClickCard() - Tap or untap a card.
#
def MouseMiddleClickCard
{
  if(tapped(object.number)) 
  {
    UnsetStayTapped();
    Send("Rotate",(object.number,0));
  }
  else if((card_data(object.number))[1]==180) 
  {
    UnsetStayUntapped();
    Send("Rotate",(object.number,270));
  }
  else if(tapped_left(object.number)) 
  {
    UnsetStayTapped();
    Send("Rotate",(object.number,180));
  }
  else 
  {
    if(untapped(object.number))
    {
      UnsetStayUntapped();
      Send("Rotate",(object.number,90));
    }
  }
}

#
# MouseLeftClickCard() - Select target for a card in targeting queue.
#
def MouseLeftClickCard
{
  push(a);
  push(ok);

  ok=0;

# Check targeting queue and attach and move if found.

  if(length(targeting_queue)>0)
  {
#Msg("TARGETING QUEUE BEFORE: "+tostr(targeting_queue));
    push(t);
    t=NextTarget();
    if(t!=NULL)
    {
      if(t[0]==object.number)
      {
        targeting_queue=targeting_queue+(tail(t),);
      }
      else
      {
        push(xy);
        push(i);

        i=NextFreeAttachPos(object.number,t[2],t[3],t[4],t[5]);
        xy=center_of(object.number);
        xy[0]=xy[0]+t[2] + i*t[4];
        xy[1]=xy[1]+t[3] + i*t[5];
        if(me>1)
          xy[0]=xy[0]-((me / 2) * BASE_TABLE_WIDTH / ((players + 1) / 2));
        xy=screen2table(xy);
        Send("MoveObject",(t[0],)+xy);

        Send("Lower",t[0]);
        LowerAttachments(object.number,t[2],t[3],t[4],t[5],i+1);

        if(t[6]{"RaiseSource"}=="yes")
          Send("Raise",t[0]);

        if(t[6]{"ReverseAttach"}=="yes")
          Send("Attach",(object.number,t[0]));
        else
          Send("Attach",(t[0],object.number));

        if(t[6]{"RaiseTarget"}=="yes")
          Send("Raise",object.number);

        ok=1;

        i=pop();
        xy=pop();
      }
    }
    t=pop();
#Msg("TARGETING QUEUE AFTER: "+tostr(targeting_queue));
  }

# Call hooks if no targeting cards found.

  if(!ok)
  {
    for(c)(game.data{"play"})
    {
      a=Attr(c,card.number);
  
      if(a!="" && isfunction("MouseLeftClick"+tofnc(a)+"Card"))
      {
        call("MouseLeftClick"+tofnc(a)+"Card",NULL);
        ok=1;
      }
    }
  }

# Default action is raise.

  if(!ok)
    Send("Raise",object.number);

  ok=pop();
  a=pop();
}

#
# MouseLeftClickDeck() - Draw a card from deck.
#
def MouseLeftClickDeck
{
  if(object.name=="deck")
    TryTransferTo("hand",me);
}

#
# MouseLeftClickHand() - Play a card from hand.
#
def MouseLeftClickHand
{
  if(length(hand(hand[me])))
  {
    ClearSearchbox();
    Send("Transfer",(1,("hand",me,hand.card_index),("play",0)));
  }
}

#
# MouseLeftClickActiveSet() - Move card that's been set aside into hand.
#
def MouseLeftClickActiveSet
{
  if(length(cardbox(active[me])))
  {
    ClearSearchbox();
    Send("Transfer",(1,("active",me,cardbox.card_index),("hand",me)));
  }
}

#
# MouseLeftClickOpponentHand() - Shrink your expand your view of opponent's hand.
#
def MouseLeftClickOpponentHand
{
  set_attr(object.number,"tiny",!get_attr(object.number,"tiny"));
}

#
# MouseLeftClickDeckSearchBox() - Move card from search into hand.
#
def MouseLeftClickDeckSearchBox
{
  if(isfunction("MouseLeftClick"+tofnc(object_name(search.source))+"SearchBoxHook"))
    call("MouseLeftClick"+tofnc(object_name(search.source))+"SearchBoxHook",NULL);
  else
    TryTransferTo("hand",me);
}

#
# MouseMiddleClickDeckSearchBox() - Handler for mouse middle clicking
#   on deck search box.
#
def MouseMiddleClickDeckSearchBox
{
  if(search.source!=NULL)
  {
    if(isfunction("MouseMiddleClick"+tofnc(object_name(search.source))+"SearchBoxHook"))
      call("MouseMiddleClick"+tofnc(object_name(search.source))+"SearchBoxHook",NULL);
  }
}

#
# LOCATION ALGORITHM
# ==================

#
# Category(card number) - Return the category of the card from rules.category table.
#
def Category
{
    push(card);
    push(c);

    card=ARG;
    for(v)(game.data{"location hint"})
    {
      eval("push("+v+");"+v+"="+tostr(Attr(v,card)));
    }

    c=NULL;
    for(r)(rules.category)
    {
      if(c==NULL)
      {
        if(eval(r[0]))
          c=eval(r[1]);
      }
    }

    if(c==NULL)
      c=("default","");

    for(v)(reverse(game.data{"location hint"}))
      eval(v+"=pop()");

    return(c);

    c=pop();
    card=pop();
}

#
# CategoryMatch(category,partial categroy) - Return 1 if a 'category'
#   have includes a 'partial category' at the beginning of it's components.
#
def CategoryMatch
{
  push(i);
  i=0;
  return(1);
  while(i < min(length(ARG[0]),length(ARG[1])))
  {
    if(ARG[0][i] != ARG[1][i])
    {
      return(0);
      i=length(ARG[0]);
    }
    i=i+1;
  }
  i=pop();
}

#
# CoordinateMapping(category) - Return coordinate mapping rules of the
#   given category from the 'rules.coordinate' table.
#
def CoordinateMapping
{
  push(m);

  m=NULL;
  for(r)(rules.coordinate)
  {
    if(m==NULL)
    {
      if(CategoryMatch(ARG,r[0]))
        m=r[1];
    }
  }
  if(m==NULL)
    m=((,),(,));

  return(m);

  m=pop();
}

#
# GetByPrimaryCategory(category table, primary category) - Return a list of 'category table'
#   table entries having a selected 'primary category'.
#
def GetByPrimaryCategory
{
  push(c);
  return(select('c=#;c[1][2][0]==ARG[1]',ARG[0]));
  c=pop();
}

#
# GetGroups(category table) - Collect group names from the list of
#   category table entries.
#
def GetGroups
{
  push(c);
  return(forall('c=#;if(length(c[1][2]) >= 2) c[1][2][1]; else ""',ARG));
  c=pop();
}

#
# FindSpace(card number,orientation,face down?) - Return suitable free location (x,y) to put card in play.
#
def FindSpace
{
  push(c);
  push(m);
  push(i);
  push(j);
  push(r);
  push(xy);

  findspace.card=ARG[0];
  findspace.orientation=ARG[1];
  findspace.facedown=ARG[2];
  c=Category(ARG[0]);

  findspace.category=c[0];
  findspace.group=c[1];
  m=CoordinateMapping(c);
  i=FindCardGroupIndices(c);
  r=m[0];
  findspace.options=m[1];
  j=0;
  xy=NULL;
  while(j < length(r))
  {
    if(!isfunction(r[j][0]))
      Msg("{red}Rule implementation for '"+r[j][0]+"' is missing. Skipping.");
    else
    {
      xy=call(first(r[j]),(i[0],i[1])+tail(r[j]));
      if(xy != NULL && findspace.options{"OffscreenEnabled"}!="yes")
      {
        if(xy[0] < 0 || xy[0]+card.design.width > design.width || xy[1] < -design.height/2 || xy[1]+card.design.height > design.height/2)
          xy=NULL;
      }
      if(xy != NULL)
      {
        if(xy[0] > design.width || xy[1] > design.height/2)
          xy=NULL;
        else
          j=length(r);
      }
    }
    j=j+1;
  }

  if(xy==NULL)
    return(Default(0,0));
  else
    return(xy);

  xy=pop();
  r=pop();
  j=pop();
  i=pop();
  m=pop();
  c=pop();
}

#
# RuleOptions(category) - Return options for the rule matching category.
#
def RuleOptions
{
  push(m);
  m=CoordinateMapping(ARG);
  return(m[1]);
  m=pop();
}

#
# ClearEmptyGroups() - Move cards that has been moved enough since
#   they played to the group ("moved",""). Remove groups without cards
#   on table from 'card.group' table. Fix also cards having (0,0) as
#   their coordinates.
#
#
def ClearEmptyGroups
{
  push(o);
  for(c)(keys(card.group))
  {
    if(c != "moved")
    {
      for(g)(keys(card.group{c}))
      {
        for(i)(length(card.group{c}{g}[1]))
        {
          if(typeof(card.group{c}{g}[1][i])=="integer")
          {
            o=center_of(card.group{c}{g}[1][i],1);

            if(card.group{c}{g}[2][i]==(0,0))
              card.group{c}{g}[2][i]=(o[0],o[1]);
            else
            {
              if(dist((o[0],o[1]),card.group{c}{g}[2][i]) > CLEAR_GROUP_DISTANCE*CLEAR_GROUP_DISTANCE)
              {
                if(!has_entry("moved",card.group))
                  card.group{"moved"}=(,);
                if(!has_entry("",card.group{"moved"}))
                  card.group{"moved"}{""}=(0,(,),(,));
  
                card.group{"moved"}{""}[1]=card.group{"moved"}{""}[1] + (card.group{c}{g}[1][i],);
                card.group{"moved"}{""}[2]=card.group{"moved"}{""}[2] + ((0,0),);
  
                card.group{c}{g}[1][i]="free";
              }
            }
          }
        }
      }
    }
  }

  for(c)(keys(card.group))
  {
    for(g)(keys(card.group{c}))
    {
      if((card.group{c}{g}[1] - ("free",))==(,))
        card.group{c}=del_entry(g,card.group{c});
    }
  }
  o=pop();
}

#
# GroupNumbers(primary category) - Return group numbers in use under
#   the given primary category.
#
def GroupNumbers
{
  if(!has_entry(ARG,card.group))
    return((,));
  else
  {
    push(b);
    return(forall('b=#;b[1][0]',card.group{ARG}));
    b=pop();
  }
}

#
# FindCardGroupIndices(category) - Return a pair (group index,index)
#   by searching for a free slot in 'card.group' table. Add "reserved"
#   entry to the table.
#
def FindCardGroupIndices
{
  push(n);
  push(g);

  if(card.group==NULL)
    card.group=(,);

  ClearEmptyGroups();
  g=GroupNumbers(ARG[0]);
  if(length(g)==0)
    g=0;
  else
    g=min(seq(0,max(g)+1)-g);

  if(!has_entry(ARG[0],card.group))
    card.group{ARG[0]}=(,);
  if(!has_entry(ARG[1],card.group{ARG[0]}))
    card.group{ARG[0]}{ARG[1]}=(g,(,),(,));

  if(count("free",card.group{ARG[0]}{ARG[1]}[1]))
  {
    push(i);
    i=find("free",card.group{ARG[0]}{ARG[1]}[1]);
    return(card.group{ARG[0]}{ARG[1]}[0],i);
    card.group{ARG[0]}{ARG[1]}[1][i]="reserved";
    i=pop();
  }
  else
  {
    return(card.group{ARG[0]}{ARG[1]}[0],length(card.group{ARG[0]}{ARG[1]}[1]));
    card.group{ARG[0]}{ARG[1]}[1]=card.group{ARG[0]}{ARG[1]}[1] + ("reserved",);
    card.group{ARG[0]}{ARG[1]}[2]=card.group{ARG[0]}{ARG[1]}[2] + ((0,0),);
  }

  g=pop();
  n=pop();
}

#
# PutCardInGroup(card number,object number,x,y) - Update 'card.group'
#   table replacing "reserved" entry with this card. This hook is
#   called when a card is put to the table. If no "reserved" entry is
#   found, reserve new entry.
#
def PutCardInGroup
{
  push(o);
  push(C);
  push(i);
  push(I);
  push(ok);
  ok=0;
  C=Category(ARG[0]);

# Check if there is "reserved" entry in the category of the current card and use that.

  if(has_entry(C[0],card.group))
  {
    if(has_entry(C[1],card.group{C[0]}))
    {
      i=length(card.group{C[0]}{C[1]}[1])-1;
      while(i >= 0)
      {
        if(card.group{C[0]}{C[1]}[1][i]=="reserved")
        {
          card.group{C[0]}{C[1]}[1][i]=ARG[1];
          card.group{C[0]}{C[1]}[2][i][0]=ARG[2];
          card.group{C[0]}{C[1]}[2][i][1]=ARG[3];
          ok=1;
          I=i;
          i=-1;
        }
        i=i-1;
      }
    }
  }

# Otherwise we look everywhere.

  if(!ok)
  {
    for(c)(keys(card.group))
    {
      for(g)(keys(card.group{c}))
      {
        i=length(card.group{c}{g}[1])-1;
        while(i >= 0)
        {
          if(card.group{c}{g}[1][i]=="reserved")
          {
            card.group{c}{g}[1][i]=ARG[1];
            C=(c,g);
            ok=1;
            I=i;
            i=-1;
          }
          i=i-1;
        }
      }
    }
  }

# Apply rule options for category.

  if(ok)
  {
     o=RuleOptions(C);

     if(o{"AutoRaiseGroupTail"}=="yes")
     {
        for(i)(right(card.group{C[0]}{C[1]}[1],length(card.group{C[0]}{C[1]}[1]) - I - 1))
          Send("Raise",i);
     }
  }

# Create free entry if not found.

  if(!ok)
  {
#    Msg("{red}Internal error: PutCardInGroup("+ARG+"), category: "+tostr(C));
    FindCardGroupIndices(C);
    PutCardInGroup(ARG);
  }

  ok=pop();
  I=pop();
  i=pop();
  C=pop();
  o=pop();
}

# DelCardInGroup(object number) - Remove references of the card from
#   table 'card.group'.
def DelCardInGroup
{
  push(ok);
  ok=0;

  for(c)(keys(card.group))
  {
    for(g)(keys(card.group{c}))
    {
      if(count(ARG,card.group{c}{g}[1]))
      {
        card.group{c}{g}[1][find(ARG,card.group{c}{g}[1])]="free";
        ok=1;
      }
    }
  }

#  if(!ok)
#    Msg("{red}Internal error: DelCardInGroup("+ARG+"), object: "+tostr(ARG));

  ok=pop();
}

#
# Default(group index,card index) - Return a random point at the center of the screen.
#
def Default
{
  return(RandomNearPoint(ARG[0],ARG[1],table.width/2,0));
}

#
# RandomNearPoint(group index,card index,x,y) - Return random point near (x,y).
#
def RandomNearPoint
{
  return(ARG[2]+random(seq(-20,20)),ARG[3]+random(seq(-20,20)));
}

#
# StacksByGroup(group index,card index,x,y,xoffset,yoffset,stack x-step,stack y-step) -
#   Each group forms own vertical stack.
#
def StacksByGroup
{
  return(ARG[2]+ARG[0]*ARG[6]+ARG[1]*ARG[4],ARG[3]+ARG[0]*ARG[7]+ARG[1]*ARG[5]);
}

#
# LocationList(group index,card index,((x1,y1),(x2,y2),...)) - Predefined positions.
#
def LocationList
{
  if(ARG[1] >= length(ARG[2]))
    return(NULL);
  else
    return(ARG[2][ARG[1]]);
}

#
# TargetCard(group index,card index,xoffset,yoffset,xsuboffset,ysuboffset) - Choose a target for card.
#
def TargetCard
{
  Msg("{yellow}Left click target for {card"+findspace.card+"}...");
  targeting_queue=targeting_queue+((findspace.card,ARG[2],ARG[3],ARG[4],ARG[5],findspace.options),);
  if(players>2)
    return(table.width/2-card.design.width,table.height/2-card.design.height-25+ARG[1]*5);
  else
    return(table.width-card.design.width,table.height/2-card.design.height-25+ARG[1]*5);
}

#
# FindOtherCard(group index,card index,expression,xoffset,yoffset) - Look for other
#   card on table using expression as a search criteria
#   'expression'. The criteria can use predefined variables 'group',
#   'category' and 'card'. Symbol # refers to the object number of the
#   card on table under testing.
#
def FindOtherCard
{
  push(group);
  push(category);
  push(o);
  push(c);
  push(i);
  category=findspace.category;
  group=findspace.group;

# Find objects fulfilling the expression.
  o=(,);
  for(c)(reverse(inplay(me)))
  {
    card=card(c);
    if(first(forall(ARG[2],(c,))))
      o=o+(c,);
  }

# Check if there is already a card with the same category intersecting target.
  for(m)(o)
  {
#Msg(m,name(card(m)));
    for(n)(intersect(m))
    {
#Msg("Checking "+n);
      if(card(n)!=NULL)
      {
        if(Category(card(n))==(category,group))
        {
          o=o-(m,);
#Msg("Intersect "+n+"/"+name(card(n))+" is "+Category(card(n)));
        }
      }
    }    
  }

  if(length(o))
  {
#Msg("Found: "+tostr(o));
     push(x);
     push(y);
     c=object_data(first(o));
     if(players > 2 && me >= 2)
     {
#       DOES NOT WORK???? GIVE UP AND USE DEFAULT HANDLER
#       x=first(screen2table(c[0]/2,c[1])) + ARG[3];
#       y=last(screen2table(c[0],c[1])) + ARG[4];
#       return (x,y);
       return(NULL);
     }
     else
     {
       x=first(screen2table(c[0],c[1])) + ARG[3];
       y=last(screen2table(c[0],c[1])) + ARG[4];
       return(x,y);
     }
     y=pop();
     x=pop();
  }

  i=pop();
  c=pop();
  o=pop();
  category=pop();
  group=pop();
}

#
# SCORE CALCULATION
# =================

#
# InitializeScoreSystem() - Initialize score structures and objects.
#
def InitializeScoreSystem
{
  push(y);
  y=5;
  score.object=array(MAX_PLAYERS);
  score=array(MAX_PLAYERS);
  score.raw=array(MAX_PLAYERS);

  for(p)(MAX_PLAYERS)
  {
    score.object[p]=create_msgbox(10,h(y),obj=obj+1,"score"+p,screen.width-20,h(25),1);
    set_bgcolor(score.object[p],NULL);
    set_textsize(score.object[p],20);
    set_textalign(score.object[p],2);
    set_textcolor(score.object[p],(0,242,20));
    set_attr(score.object[p],"ontop",Z_SCORE);
    set_attr(score.object[p],"sticky",1);
    raise(score.object[p]);
    mode_object{"watch"}=mode_object{"watch"}+(score.object[p],);
    mode_object{"play"}=mode_object{"play"}+(score.object[p],);
    mode_object{"playback"}=mode_object{"playback"}+(score.object[p],);
    y=y+25;
  }

  y=pop();
}

#
# SetScore(player,value) - Set value of player's score counter.
#
def SetScore
{
  push(m);
  m=ARG[1];

  if(m!=NULL)
  {
    if(typeof(m)!="string")
      m=tostr(m);

    if(m!="")
    {
      if(ARG[0]==me)
        m="{cyan}"+player.name{ARG[0]}+": "+m;
      else
        m=player.name{ARG[0]}+": "+m;
    }
  }

  if(m==NULL)
    message(score.object[ARG[0]],"");
  else
    message(score.object[ARG[0]],m);

  score[ARG[0]]=ARG[1];

  m=pop();
}

#
# ClearScores() - Remove all scores.
#
def ClearScores
{
  for(p)(MAX_PLAYERS)
  {
    message(score.object[p],"");
    score[p]=NULL;
    score.raw[p]=NULL;
  }
}

#
# ScoreToText(score structure) - Convert a score structure to string.
#
def ScoreToText
{
  if(ARG!=NULL)
    return(tostr(ARG));
}

#
# AVATAR HANDLING
# ===============

# avatar.name{player} - name of the avatar assigned to the player
# avatar.image{avatar name} - image number of avatar
# avatar.object{player} - object numbers of avatars

if(avatar.image==NULL)
  avatar.image=(,);
if(avatar.object==NULL)
  avatar.object=(,);
if(avatar.name==NULL)
  avatar.name=(,);

#
# CreateAvatar(image number,object number,player name,(x,y)) - Create avatar image.
#
def CreateAvatar
{ 
  push(o);
  del_object(ARG[1]);
  create_image(ARG[3][0],ARG[3][1],ARG[1],ARG[0],"Player "+ARG[2],0);
  o=create_msgbox(ARG[3][0]-w(10),ARG[3][1]+h(32-2),obj=obj+1,"Player "+ARG[2],w(32+20),h(30),2);
  set_attr(o,"visible",0);
  set_attr(o,"clickable",1);
  set_attr(o,"ontop",Z_MBOX);
  set_textsize(o,9);
  set_textmargin(o,0);
  set_textalign(o,1);
  set_textvalign(o,0);

  for(t)(split(ARG[2],"-"))
    add_text(o,"{shadow}"+left(t,8));
  set_attr(ARG[1],"clickable",1);
  if(mode=="chat")
  {
    set_attr(o,"visible",1);
    set_attr(ARG[1],"visible",1);
  }

  raise(ARG[1]);
  raise(o);
  attach(o,ARG[1]);

  mode_object{"chat"}=mode_object{"chat"}+(ARG[1],o);

  o=pop();
}

#
# LoadAvatar(name) - Load avatar if not loaded.
#
def LoadAvatar
{
  if(!has_entry(ARG,avatar.image))
  {
    if(typeof(ARG)=="string")
      avatar.image{ARG}=load_image(lc(ARG)+".png","rat.png");
    else
      avatar.image{ARG}=load_image("rat.png");
    scale_image(avatar.image{ARG},32,32);
  }
}

#
# AvatarFloorPos(player number) - Return (x,y) pair telling location of the avatar on the floor.
#
def AvatarFloorPos
{
  return(w((ARG%28)*35+5),h(134+(ARG/28)*35));
}

#
# SetAvatar(player number,player name,avatar name,table or -1) -
#   Create avatar (if needed) and locate it to the table or floor.
#
def SetAvatar
{
  push(a);
  a=ARG[2];

  if(typeof(a)!="string")
    a="rat";
  else if(find("..",a)!=NULL)
    a="kobold";

  a=tr(a,"./\\:","");

  LoadAvatar(a);
  RemoveAvatar(ARG[1]);
  avatar.name{ARG[1]}=a;
  if(!has_entry(ARG[1],avatar.object))
  {
    avatar.object{ARG[1]}=(obj=obj+1);
  }
  CreateAvatar(avatar.image{a},avatar.object{ARG[1]},ARG[1],AvatarFloorPos(ARG[0]));
  MoveAvatar(ARG[0],ARG[3]);
  a=pop();
}

#
# AvatarRecalcTable(table) - Reposition all avatar at table.
#
def AvatarRecalcTable
{
  push(x1);
  push(x2);
  push(y);
  push(d);
  push(o);

  if(has_entry(ARG,room.tables))
  {
    xy=TableCoord(ARG);
    x1=(image_width(table.image)+w(10))*xy[0]+w(20);
    x2=x1+image_width(table.image)-1;
    y=(image_height(table.image)+h(10))*xy[1]+h(228)+image_height(table.image);
    d=(x2-x1+1)/(length(room.tables{ARG}[2])+1);

    for(p)(room.tables{ARG}[2])
    {
      x1=x1+d;
      o=avatar.object{PlayerName(p)};
      if(o!=NULL)
      {
        move_object(o,x1 - w(16),y);
        set_attr(o,"highlight",count(p,room.tables{ARG}[6]) > 0);
        raise(o);
      }
    }
  }

  o=pop();
  d=pop();
  y=pop();
  x2=pop();
  x1=pop();
}

#
# MoveAvatar(player number, table or -1) - Move avatar.
#
def MoveAvatar
{
  push(p);
  if(ARG[1]==-1)
  {
    if(has_entry(ARG[0],room.players))
    {
      p=AvatarFloorPos(ARG[0]);
      move_object(avatar.object{PlayerName(ARG[0])},p[0],p[1]);
      set_attr(avatar.object{PlayerName(ARG[0])},"highlight",0);
      raise(avatar.object{PlayerName(ARG[0])});
    }
  }
  else
  {
    AvatarRecalcTable(ARG[1]);
    raise(avatar.object{PlayerName(ARG[0])});
  }

  p=pop();
}

#
# RemoveAvatar(player name) - Delete avatar from screen.
#
def RemoveAvatar
{
  if(has_entry(ARG,avatar.object))
  {
    del_object(first(subobjects(avatar.object{ARG})));
    del_object(avatar.object{ARG});
    avatar.object=del_entry(ARG,avatar.object);
  }
}

#
# IsAway() - Return 1 if away, 0 if not away or NULL if never set before.
#
def IsAway
{
  load("away");
  if(typeof(away)!="list")
    away=(,);

  return(away{username}!=NULL);
}

#
# SetAwayOn(message) - Turn away status on.
#
def SetAwayOn
{
  if(!IsAway())
  {
    away{username}=options{"avatar"};
    if(away{username}==NULL)
      away{username}="rat";
    save("away");
    CommandSet("avatar","sleep");
    CommandMe("away: "+ARG);
    Msg("{hr}");
    Msg("{sz20}Away log since "+time()+" starts here:");
  }
}

#
# SetAwayOff() - Turn away status off.
#
def SetAwayOff
{
  if(IsAway())
  {
    push(o);
    o=away{username};
    CommandSet("avatar",o);
    CommandMe("is back");
    Msg("{sz20}Away log ends here.");
    Msg("{hr}");
    away{username}=NULL;
    save("away");
    o=pop();
  }
  else if(avatar.name{username}=="sleep")
  {
    if(has_entry(username,avatar))
       CommandSet("avatar",avatar{username});
    else
       CommandSet("avatar","rat");
  }
}

#
# BOOK SORT/FILTER
# ================

#
# SetBookPage(page,[object number of card book]) - Select the page for your collection.
#
def SetBookPage
{
  push(u);
  push(p);
  push(r);
  push(b);
  if(typeof(ARG)=="integer")
  {
    p=ARG;
    b=card.book;
  }
  else if(typeof(ARG)=="list")
  {
    p=ARG[0];
    b=ARG[1];
  }
  r=(,);
  if(mode!="" && isfunction("book_cards") && count(b,books))
  {
    u=book_cards(b,p);
    if(p>0)
      u=u+book_cards(b,p-1);
    else
      u=u+book_cards(b,book_last_page(b));

    if(p<book_last_page(b))
      u=u+book_cards(b,p+1);
    else
      u=u+book_cards(b,0);

    RefreshBook(u);
  }

  if(count(b,books))
    book_set_page(b,p);
  b=pop();
  r=pop();
  p=pop();
  u=pop();
}

#
# SetBookIndex(filter,sorting) - Set current filter and sorting for the card book.
#   If the (filter,sorting) pair does not yet exist, create it first.
#   If the filtering expression is volatile, don't save index.
#
def SetBookIndex
{
  if(book.index==NULL)
    load("book.index");
  if(book.index==NULL)
    book.index=(,);
  if(book.filter==NULL)
    load("book.filter");
  if(book.filter==NULL)
    book.filter=(,);
  if(book.history==NULL)
    book.history=(,);

  if(book.current_index!=NULL)
  {
    if(first(book.history) != book.current_index)
      book.history=(book.current_index,)+book.history;
  }

  book.current_index=(ARG[0],ARG[1]);

  if(book.filter{ARG[0]}==NULL)
    book.filter{ARG[0]}=CreateFilter(ARG[0]);
  if(book.index{book.current_index}==NULL)
    book.index{book.current_index}=CreateIndex(book.current_index,book.filter{ARG[0]});

  book_set_index(card.book,book.index{book.current_index});
  SetBookPage(0);

  if(IsVolatile(ARG[0]))
  {
    book.filter{ARG[0]}=NULL;
    book.index{book.current_index}=NULL;
  }
}

#
# RefreshBook(list of cards) - Ask for refresh for cards if not yet asked.
#
def RefreshBook
{
  if(mode!="offline")
  {
    if(server.meta==NULL)
      0;
    else if(!net_isopen(server.meta))
      0;
    else
    {
      push(u);
      u=select("!book_refresh{#}",ARG);
      if(length(u))
      {
        SendMeta("Refresh",u);
        forall("book_refresh{#}=1",u);
      }
      u=pop();
    }
  }
}

#
# RefreshBookForDeck(deck name) - Refresh all cards in deck.
#
def RefreshBookForDeck
{
  RefreshBook(flatten(values(decks{ARG})));
}

#
# SaveBookState() - Store the state of the collection to the disk.
#
def SaveBookState
{
  if(mode!="offline")
  {
    push(s);
    s=forall("(#,book_entry(card.book,#))",cards());
    if(!call(LOAD_FN,"book.cache"))
      book.cache=(,);
    if(!has_entry(server.name,book.cache))
      book.cache{server.name}=(,);
    book.cache{server.name}{username}=s;
    call(SAVE_FN,"book.cache");
    s=pop();
  }
}

#
# LoadBookState() - Restore the state of the collection from the disk.
#                   Return 1 if found, NULL otherwise.
#
def LoadBookState
{
  if(call(LOAD_FN,"book.cache"))
  {
    if(has_entry(server.name,book.cache))
    {
      if(has_entry(username,book.cache{server.name}))
      {
        ClearCardBook();
        book_set_entry(card.book,book.cache{server.name}{username});
        return(1);
      }
    }
  }
}

#
# BookFullRefresh() - Clear the book content and ask for full refresh.
#
def BookFullRefresh
{
  ClearCardBook();
  RefreshBook(cards());
}

#
# ClearCardBook() - Clear content of the collection.
#
def ClearCardBook
{
  book_refresh=(,);
  book_set_entry(card.book,forall('(#,(0,0.0,"",0.0,0,0))',cards()));
}

#
# IsVolatile(list of expressions) - Check the filtering expression and return 1
#   if it is volatile, i.e. the indexing should be recalculated on every use.
#
def IsVolatile
{
  push(argl);
  argl = join(ARG," ");
  return(find('book_entry(card.book',argl)!=NULL
      || find('playerwants(',argl)!=NULL
      || find('playerhas(',argl)!=NULL);
  argl=pop();
}

#
# BookGoBack() - Return to the previous indexing in history and remove
#  it from the history.
def BookGoBack
{
  if(length(book.history)>0)
  {
    SetBookIndex(first(book.history));
    book.history=tail(tail(book.history));
  }
}

#
# CurrentFilter() - Return value of the current filter expression.
#
def CurrentFilter
{
  return(book.current_index[0]);
}

#
# CurrentSorting() - Return value of the current sorting expression.
#
def CurrentSorting
{
  return(book.current_index[1]);
}

#
# CheckFilterVersion() - Check that stored indices and filters are created with the
#   current algorithm and there were the same number of cards. If different, clear
#   all filters and indices and store new filter version.
#
def CheckFilterVersion
{
  push(c);
  c=length(cards());
  load("book.filter_version");
  if(book.filter_version != (BOOK_FILTER_VERSION+BOOK_FILTER_VERSION_MINOR,c))
  {
    book.filter_version=(BOOK_FILTER_VERSION+BOOK_FILTER_VERSION_MINOR,c);
    book.index=(,);
    book.filter=(,);
    save("book.filter_version");
  }
  c=pop();
}

#
# CreateFilter(filter expressions) - Return a list of cards
#   matching the filter expression.
#
def CreateFilter
{
  if(book.filter{ARG}!=NULL)
    return(book.filter{ARG});
  else
  {
    Alert("Creating new filter");
    if(ARG=="default")
      return(cards());
    else if(typeof(ARG)=="string")
      return(select(ARG,cards()));
    else if(typeof(ARG)=="list")
    {
      push(c);
      c=cards();
      for(f)(ARG)
        c=select(f,c);
      return(c);
      c=pop();
    }
    else
      Msg("{red}Invalid filter expression "+tostr(ARG)+".");
    AlertOff();
  }
}

#
# RefineFilter(single filter expression) - Add expression to the
#   current filter and update the collection to show refined filtering.
#
def RefineFilter
{
  push(f);
  f=CurrentFilter();
  if(f=="default")
    f=ARG;
  else
  {
    if(typeof(f)=="string")
      f=unique(sort((f,ARG)));
    else
      f=unique(sort(f+(ARG,)));
  }
  SetBookIndex(f,CurrentSorting());
  f=pop();
}

#
# CreateIndex((filter expression,sort expression), list of cards) - Return
#  indexing matching filter/sort expression pair. First filter
#  collection is checked and already calculated value is returned if found.
#  Otherwise it is generated. The sort expression is either single string or a list of strings.
#  If the list begins with a number, then it is taken as a title level
#  depth, i.e. how many sorting criteria are taken into account when
#  constructing the title for the sorted section. Default title
#  depth is one.
#
def CreateIndex
{
  if(book.index{ARG[0]}!=NULL)
  {
    return(book.index{ARG[0]});
  }
  else
  {
    Alert("Creating new index");

    if(ARG[0][1]=="default")
    {
      return(sort_by(BOOK_DEFAULT_SORT,ARG[1],1));
    }
    else
    {
      push(e);
      push(t);
      t=1;
      e=ARG[0][1];
      if(typeof(e)=="list")
      {
        if(typeof(first(e))=="integer")
        {
          t=first(e);
          e=tail(e);
        }
      }
      return(sort_by(e,ARG[1],t));
      t=pop();
      e=pop();
    }

    AlertOff();
  }
}

#
# String2Sorting(string) - Convert a string to the sorting expression, 
#   or return NULL if invalid.
#
def String2Sorting
{
  push(s);
  s=forall("str2sorting(#)",split(ARG," "));
  if(count(NULL,s)==0)
  {
    if(last(s)!="[name]")
      return(s+("[name]",));
    else
      return(s);
  }
  s=pop();
}

#
# str2sorting(string) - Helper function to String2Sorting().
#
def str2sorting
{
  strprefix="";
  push(s);
  push(t);
  t=1;
  while(t)
  {
    s=first(ARG);
    if(s=='-' || s=='!')
    {
      strprefix=strprefix+'-';
      ARG=substr(ARG,1);
    }
    else if(s=='#')
    {
      strprefix=strprefix+'N';
      ARG=substr(ARG,1);
    }
    else if(s=='*')
    {
      strprefix=strprefix+'C';
      ARG=substr(ARG,1);
    }
    else t=0;
  }
  ARG=lc(ARG);
  
  if(ARG=="age")
    return(strprefix+"[age]");
  else if(ARG=="set")
    return(strprefix+"[set]");
  else if(ARG=="name")
    return(strprefix+"[name]");
  else if(count(ARG,attributes()))
    return(strprefix+"["+ARG+"]");
  else if(has_entry(ARG,GAME_ATTRIBUTES))
  {
    ARG=GAME_ATTRIBUTES{ARG};
    if(left(ARG,2)=="a:")
      return(strprefix+"["+substr(ARG,2)+"]");
  }
  s=pop();
  t=pop();
}

#
# String2Filter(string) - Convert a string to the filter expression
#   or return NULL if invalid.
#
def String2Filter
{
  push(e);

  e=str2filter_exp(ARG);
  if(e!=NULL)
  {
    e=first(str2filter_typetoint(e,));
    return(e[0]);
  }
  e=pop();
}

#
# str2filter_split(string,split string,function) - Helper function
#   for String2Filter(). Try to split a string from every possible
#   index containing a split string. Call a function for each splitted
#   part and return a list containing two return values of the
#   successful call. Return NULL
#   if the string cannot be splitted legally from any position.
#   (See str2filter_atom for more info about return values).
#
def str2filter_split
{
  push(e);
  push(r);

  e=split(ARG[0],ARG[1]);

  if(length(e)>1)
  {
    r=NULL;
#    for(i)(length(e)-1)
#    {
#      if(r==NULL)
#      {
#        r=(call(ARG[2],join(left(e,i+1),ARG[1])),call(ARG[2],join(right(e,length(e)-i-1),ARG[1])));
#        if(count(NULL,r))
#          r=NULL;
#      }
#    }
    r=forall("call(ARG[2],#)",e);
    if(r==NULL || count(NULL,r))
      r=NULL;
    return(r);
  }

  r=pop();
  e=pop();
}

#
# str2filter_typeconvert(e1,e2) - Helper function for String2Filter().
#   Check compatibility of types for triplets e1 and e2 (See
#   str2filter_atom for info about triplets). If incompatible, add proper
#   type conversion to the expression and change a type of the return
#   value. If an argument e2 is not given, return arguments unmodified.
#
def str2filter_typeconvert
{
  return(ARG);
  if(length(ARG) > 1)
  {
    if(ARG[0][1]=="r" && ARG[1][1]!="r")
      return(ARG[0],("toreal("+ARG[1][0]+")","r"));
    else if(ARG[0][1]!="r" && ARG[1][1]=="r")
      return(("toreal("+ARG[0][0]+")","r"),ARG[1]);
    else if(ARG[0][1]=="i" && ARG[1][1]!="i")
      return(ARG[0],("toint("+ARG[1][0]+")","i"));
    else if(ARG[0][1]!="i" && ARG[1][1]=="i")
      return(("toint("+ARG[0][0]+")","i"),ARG[1]);
  }
}

#
# str2filter_typetoint(e1,e2) - Helper function for String2Filter().
#   Convert types to integer when needed.
#
def str2filter_typetoint
{
  push(r);

  r=(,);
  for(e)(ARG)
  {
    if(e[1]=="i")
      r=r+(e,);
    else
      r=r+(("toint("+e[0]+")","i"),);
  }

  return(r);

  r=pop();
}

#
# str2filter_typetostring(e1,e2) - Helper function for String2Filter().
#   Convert types to string when needed.
#
def str2filter_typetostring
{
  push(r);

  r=(,);
  for(e)(ARG)
  {
    if(e[1]=="s")
      r=r+(e,);
    else
      r=r+(("tostr("+e[0]+")","s"),);
  }

  return(r);

  r=pop();
}

#
# str2filter_join((e1,e2),operator) - Join one or two triplets together
#   by adding operator string between them. If two triplets are given,
#   they are assumed to have the same type.
#
def str2filter_join
{
  if(length(ARG[0])==1)
    return(ARG[0][0]);
  else
     return(join(forall("#[0]",ARG[0]),ARG[1]),ARG[0][0][1]);
#    return(ARG[0][0][0]+ARG[1]+ARG[0][1][0],ARG[0][0][1]);
}

#
# str2filter_exp(string) - Helper function for String2Filter().
#   Parse logical expression.
#
def str2filter_exp
{
  push(e);
  e=str2filter_split(ARG," and ","str2filter_rel");
  if(e!=NULL)
    return(str2filter_join(e,"&&"));
  else
  {
    e=str2filter_split(ARG,"&&","str2filter_rel");
    if(e!=NULL)
      return(str2filter_join(e,"&&"));
    else
    {
      e=str2filter_split(ARG," or ","str2filter_rel");
      if(e!=NULL)
        return(str2filter_join(e,"||"));
      else
      {
        e=str2filter_split(ARG,"||","str2filter_rel");
        if(e!=NULL)
          return(str2filter_join(e,"||"));
        else
          return(str2filter_rel(ARG));
      }
    }
  }
  e=pop();
}

#
# str2filter_rel(string) - Helper function for String2Filter().
#   Parse comparison relation.
#
def str2filter_rel
{
  push(e);
  e=str2filter_split(ARG,">=","str2filter_bits");
  if(e!=NULL)
    return(str2filter_join(str2filter_typeconvert(e),">="));
  else 
  {
    e=str2filter_split(ARG,"<=","str2filter_bits");
    if(e!=NULL)
      return(str2filter_join(str2filter_typeconvert(e),"<="));
    else
    {
      e=str2filter_split(ARG,"!=","str2filter_bits");
      if(e!=NULL)
        return(str2filter_join(str2filter_typeconvert(e),"!="));
      else
      {
        e=str2filter_split(ARG,"=","str2filter_bits");
        if(e!=NULL)
          return(str2filter_join(str2filter_typeconvert(e),"=="));
        else
        {
          e=str2filter_split(ARG,"<","str2filter_bits");
          if(e!=NULL)
            return(str2filter_join(str2filter_typeconvert(e),"<"));
          else
          {
            e=str2filter_split(ARG,">","str2filter_bits");
            if(e!=NULL)
              return(str2filter_join(str2filter_typeconvert(e),">"));
            else
            {
              e=str2filter_split(ARG," has ","str2filter_bits");
              if(e!=NULL)
              {
                e=str2filter_typetostring(e);
                e[1][0]=strreplace(lc(e[1][0]),"cardname","\"+name(#)+\"");
                return("find(lc("+e[1][0]+"),lc("+e[0][0]+"))!=NULL","s");
              }
              else
                return(str2filter_bits(ARG));
            }
          }
        }
      }
    }
  }

  e=pop();
}

#
# str2filter_bits(string) - Helper function for String2Filter().
#  Parse bitwise expression.
#
def str2filter_bits
{
  push(e);
  e=str2filter_split(ARG,"&","str2filter_bits");
  if(e!=NULL)
    return(str2filter_join(str2filter_typeconvert(e),"&"));
  else
  {
    e=str2filter_split(ARG,"|","str2filter_bits");
    if(e!=NULL)
      return(str2filter_join(str2filter_typeconvert(e),"|"));
    else
    {
      e=str2filter_split(ARG,"^","str2filter_bits");
      if(e!=NULL)
        return(str2filter_join(str2filter_typeconvert(e),"^"));
      else
        return(str2filter_sum(ARG));
    }
  }
  e=pop();
}

#
# str2filter_sum(string) - Helper function for String2Filter().
#  Parse sum expression.
#
def str2filter_sum
{
  push(e);
  e=str2filter_split(ARG,"+","str2filter_sum");
  if(e!=NULL)
    return(str2filter_join(str2filter_typeconvert(e),"+"));
  else
  {
    e=str2filter_split(ARG,"-","str2filter_sum");
    if(e!=NULL)
      return(str2filter_join(str2filter_typeconvert(e),"-"));
    else
      return(str2filter_term(ARG));
  }
  e=pop();
}

#
# str2filter_term(string) - Helper function for String2Filter().
#  Parse multiplication expression.
#
def str2filter_term
{
  push(e);
  e=str2filter_split(ARG,"*","str2filter_term");
  if(e!=NULL)
    return(str2filter_join(str2filter_typeconvert(e),"*"));
  else
  {
    e=str2filter_split(ARG,"/","str2filter_term");
    if(e!=NULL)
      return(str2filter_join(str2filter_typeconvert(e),"/"));
    else
      return(str2filter_atom(ARG));
  }
  e=pop();
}


#
# str2filter_atom(string) - Helper function for String2Filter().
#   Parse atomic expression and return a pair (e,t), where
#   e is the expression corresponding the atom, t is a presenting type
#   the type of expression "i"/"r"/"s" (integer,real,string).
#
def str2filter_atom
{
  push(a);

  a=ARG;
  while(left(a,1)==" " && length(a))
    a=substr(a,1);
  while(right(a,1)==" ")
    a=left(a,length(a)-1);

  if(tostr(toint(a))==a)
    return(a,"i");
  elseif(isreal(a))
    return(a,"r");
  else if(left(a,4)=="not ")
  {
    a=str2filter_exp(substr(a,4));
    if(a!=NULL)
    {
      a=first(str2filter_typetoint(a,));
      return("(!("+a[0]+"))",a[1]);
    }
  }
  else if(left(a,1)=="(" && right(a,1)==")")
  {
    a=str2filter_exp(substr(a,1,length(a)-2));
    if(a!=NULL)
      return("("+a[0]+")",a[1]);
  }
  else if(left(a,1)=='"' && right(a,1)=='"' && length(a)>1)
  {
    if(strreplace(a,'"','')==substr(a,1,length(a)-2))
      return(a,"s");
  }
  else if(count(lc(a),attributes()))
  {
    a=lc(a);
    push(b);
    if(has_entry(a,GAME_ATTRIBUTES))
    {
      b=GAME_ATTRIBUTES{a};
      if(b=="i")
        return("toint(Attr('"+a+"',#))","s");
      else if(b=="r")
        return("toreal(Attr('"+a+"',#))","s");
      else
        return("Attr('"+a+"',#)","s");
    }
    else
      return("Attr('"+a+"',#)","s");
    
    b=pop();
  }
  else if(has_entry(a,GAME_ATTRIBUTES))
  {
    push(b);
    b=GAME_ATTRIBUTES{a};
    if(left(b,2)=="a:")
    {
      a=substr(b,2);
      b="s";
      if(has_entry(a,GAME_ATTRIBUTES))
        b=GAME_ATTRIBUTES{a};
      if(b=="i")
        return("toint(Attr('"+a+"',#))","s");
      else if(b=="r")
        return("toreal(Attr('"+a+"',#))","s");
      else
        return("Attr('"+a+"',#)","s");
    }
    else
      Msg("{red}Invalid attribute definition '"+b+"'.");
    
    b=pop();
  }
  else if(count(lc(a),keys(FILTER_FUNCTIONS)))
    return("filter_"+lc(a)+"(#)",FILTER_FUNCTIONS{lc(a)}[0]);
  else if(left(a,6) == "pwant(" && right(a,1) == ")")
    return("playerwants('" + substr(a,6,length(a)-7) + "',#)", "i");
  else if(left(a,6) == "phave(" && right(a,1) == ")")
    return("playerhas('" + substr(a,6,length(a)-7) + "',#)", "i");
  else if(a=="set")
    return("set_of(#)","s");
  else if(a=="name")
    return("name(#)","s");
  else if(a=="text")
    return("text(#)","s");
  else if(a=="have")
    return("(book_entry(card.book,#))[0]","i");
  else if(a=="deck")
    return("(book_entry(card.book,#))[5]","i");
  else if(a=="seller")
    return("(book_entry(card.book,#))[2]","s");
  else if(a=="sell")
    return("max(0,(book_entry(card.book,#))[4])","i");
  else if(a=="want")
    return("max(0,-(book_entry(card.book,#))[4])","i");
  else if(a=="price")
    return("(book_entry(card.book,#))[1]","r");
  else if(a=="myprice")
    return("(book_entry(card.book,#))[3]","r");

  a=pop();
}


#
# IsUserDisplay() - Return 1 if the current display is an user defined display.
#
def IsUserDisplay
{
  push(n);
  n=(CurrentFilter(),CurrentSorting());
  for(d)(book.my_filters)
  {
    if((d[1],d[2])==n)
      return(1);
  }
  n=pop();
}

#
# DestroyUserDisplay() - Remove current display if it is user defined.
#
def DestroyUserDisplay
{
  if(IsUserDisplay())
  {
    push(n);
    n=(CurrentFilter(),CurrentSorting());
    for(d)(book.my_filters)
    {
      if((d[1],d[2])==n)
      {
        book.my_filters=book.my_filters-(d,);
        SetBookIndex("default","default");
      }
    }
    n=pop();
  }
}

#
# TIMERS
# ======

#
# MainLoop() - Main loop called frequently.
#
def MainLoop
{
  push(d);
  d=net_get();
  if(d!=NULL)
  {
    if(d[0]=="close")
    {
      message(msg.box,"{red}Server closed connection.");
      message(msg.box,"{red}ABNORMAL EXIT!");
      if(server.meta!=NULL && server.meta==server)
        net_close(server.meta);
      if(server!=NULL)
        net_close(server);
    }
    else
    {
      con=d[0];
      Receive(toval(d[1]));
    }
  }
  d=pop();
}

#
# TimerMinute() - Timer which is called every minute. Send NULL to meta server.
#
def TimerMinute
{
  if(server != NULL && server.meta!=NULL)
  {
    if(net_isopen(server))
      net_send(server,("Null",NULL));
    if(server!=server.meta && net_isopen(server.meta))
      net_send(server.meta,("Null",NULL));
  }
}

#
# Timer5Seconds() - Timer which is called every 5 seconds. Handle timer_minute queue.
#
def Timer5Seconds
{
  push(t);
  t=current_time();
  for(i)(length(timer_minute))
  {
    if(t>=timer_minute[i][0])
      eval(timer_minute[i][1]);
  }
  timer_minute=select("t<first(#)",timer_minute);
  t=pop();
}

#
# Timer15Seconds() - Timer which is called every 15 seconds. Unused.
#
def Timer15Seconds
{
}

#
# Timer() - Timer function to handle timer events in queue every
#   second if the queue is not empty.
#
def Timer
{
  for(i)(length(timer))
  {
    timer[i][0]=timer[i][0]-1;
    if(timer[i][0]<=0)
      eval(timer[i][1]);
  }
  timer=select("first(#)>0",timer);
}

#
# AddTimer(delay in seconds,command) - Add a timer which fires after the given delay.
#
def AddTimer
{
  timer=timer+(ARG,);
}

#
# AddMinuteTimer(delay in minutes,command) - Add a timer which fires after the given delay.
#
def AddMinuteTimer
{
  timer_minute=timer_minute+((current_time()+ARG[0]*60,ARG[1]),);
}

HELP{"chat"}{"time"}=("time,message","add a timer",("Judge",),
"Adds a timer for calling time limits in a tournament. When this command is issued, the Judge yells '{yellow}time{white} minutes until {yellow}message{white}'. Then it announces half time (if the limit is more than 19 minutes) and 5 minutes before the limit (if the limit is more than 5 minutes). Finally the end of the time limit is called.");


#
# JudgeChatCommandTime(minutes,event) - Add timer calling the event after specified time in minutes.
#
def JudgeChatCommandTime
{
  if(length(ARG)>=2)
  {
    push(t);
    push(e);
    t=toint(ARG[0]);
    if(t>0)
    {
      e=join(tail(ARG)," ");
      AddMinuteTimer(0,'SlashCommand("/yell {hr} '+t+' minutes until '+e+'.")');
      AddMinuteTimer(0,'SlashCommand("/yell TIME STARTS NOW!")');
      AddMinuteTimer(t,'SlashCommand("/yell {hr} '+e+'")');
      if(t>5)
        AddMinuteTimer(t-5,'SlashCommand("/yell {hr} 5 minutes until '+e+'")'); 
      if(t>19)
        AddMinuteTimer(t/2,'SlashCommand("/yell {hr} '+(t/2)+' minutes until '+e+'")'); 
    }
    e=pop();
    t=pop();
  }
  else
    Msg("{red}Invalid arguments.");
}

#
# JudgeChatAt(minutes,message) - Add single timed message after specified time in minutes.
#
def JudgeChatCommandAt
{
  if(length(ARG)>=2)
  {
    AddMinuteTimer(toint(ARG[0]),'SlashCommand("/yell '+join(tail(ARG)," ")+'")');
    Msg("Timer added.");
  }
  else
    Msg("{red}Invalid arguments.");
}

#
# Times(times,current_player) - Update timing information for the client.
#
# NOTE: future compatibility for now - implemented later.
def Times
{
}

#
# DECK IMPORT/EXPORT
# ==================

#
# ImportDeck(file content) - Try to recognize the deck format of
#   the file and then import the deck according to that format. The
#   file content is given as a list of strings representing lines of the
#   file. Return a deck structure or a string describing the reason
#   why import failed.
#
def ImportDeck
{
  push(f);
  push(d);
  d=select("#!=''",ARG);
  f=RecognizeDeckFormat(d);
  if(f==NULL)
    return("format not recognized");
  else
  {
    Msg("Found "+f+" deck...");
    return(ImportDeckFormat(f,d));
  }
  d=pop();
  f=pop();
}

#
# ImportDeckFormat(format,file content) - Import deck in the given format.
#   Arguments and return value as in ImportDeck(). The variables
#   import.deck, import.part and import.error are initialized and
#   filled during the import process.
#   It import.error is still an empty
#   string after the calling appropriate importer, then import.deck
#   structure is returned. Otherwise import.error is returned.
#
def ImportDeckFormat
{
  import.deck=NewDeck();
  import.part="deck";
  import.error="";

  if(!isfunction("Import"+tofnc(ARG[0])+"Deck"))
    return("importer function "+"Import"+tofnc(ARG[0])+"Deck() is not defined for the format '"+ARG[0]+"'");
  else
  {
    call("Import"+tofnc(ARG[0])+"Deck",ARG[1]);
    if(import.error!="")
       return("(format "+ARG[0]+") "+import.error);
    else
       return(import.deck);
  }
}

#
# OtherDeckFormats() - Return the list of game specific deck format codes.
#
def OtherDeckFormats
{
  return(forall('left(#,length(#)-7)',select('right(#,7)==".format"',scripts())));
}

#
# RecognizeDeckFormat(file content) - Return format code for the deck or
#  NULL if not recognized.
#
def RecognizeDeckFormat
{
  return("ASCII");
  if(length(ARG)>=3)
  {
    if(left(ARG[1],8)=="# GCCG v" && right(ARG[1],4)=="deck")
      return("Gccg");
    else
    {
      push(r);
      r=NULL;
      for(f)(OtherDeckFormats())
      {
        if(r==NULL)
        {
          if(!isfunction("Is"+tofnc(f)+"Deck"))
            execute(f+".format");
          if(!isfunction("Is"+tofnc(f)+"Deck"))
            Msg("{red}WARNING: Function "+"Is"+tofnc(f)+"Deck() not defined in "+f+".format");
          elseif(call("Is"+tofnc(f)+"Deck",ARG))
            r=f;
        }
      }
      if(r!=NULL)
        return(r);
      r=pop();
    }
  }
}

#
# ImportReaderLineByLine(file content,comment stripper,line trimmer,line splitter,line parser) -  Deck
#   import reader for text formats. Comment stripper, line trimmer and
#   line splitter are function names,which are applied to the each line of the file. Comment
#   stripper removes comments, line trimmer removes unnecessary parts
#   of the line and line splitter converts it to the suitable format
#   to the line parser. The parser updates variables import.error, import.deck and
#   import.part and is applied to every non-empty line after trimming.
#
def ImportReaderLineByLine
{
  return(NewDeck());

  for(l)(ARG[0])
  {
    l=call(ARG[1],l);
    if(l!="")
    {
      l=call(ARG[2],l);
      if(l!="")
      {
        l=call(ARG[3],l);
        if(l!=NULL)
          call(ARG[4],l);
      }
    }
  }
}

#
# None() - Empty function returning it's arguments.
#
def None
{
  return(ARG);
}

#
# HashComments(text line) - Return empty string when the text line
#   begins with #-character. Otherwise the line itself.
#
def HashComments
{
  if(left(ARG,1)=="#")
    return("");
  else
    return(ARG);
}
#
# SlashComments(text line) - Return empty string when the text line
#   begins with //. Otherwise the line itself.
#
def SlashComments
{
  if(left(ARG,2)=="//")
    return("");
  else
    return(ARG);
}

#
# TrimSpaces(text line) - Remove spaces from the beginning and the end
#   of text line.
#
def TrimSpaces
{
  return(trim(ARG));
}

#
# LineSplitFirstSpace(text line) - Split a line to two from the first
#   space occurring in the text line. Return the original line if none.
#
def LineSplitFirstSpace
{
  push(i);
  i=find(" ",ARG);
  if(i==NULL)
    return(ARG,);
  else
    return(left(ARG,i),substr(ARG,i+1));
  i=pop();
}

#
# ImportAdd(n,card number) - Add n cards to the import.part part of
#   the import.deck structure.
#
def ImportAdd
{
  if(ARG[1]!=NULL)
  {
    if(!has_entry(import.part,import.deck))
      import.deck{import.part}=(,);

    import.deck{import.part}=import.deck{import.part}+copy(ARG[1],ARG[0]);
  }
}

#
# RecognizeCard(name) - Try to convert a name to card number applying
#   images() and fuzzy_images(). Return NULL if unknown.
#
def RecognizeCard
{
  push(c);
  c=images(ARG);
  if(c==(,))
    c=fuzzy_images(ARG);
  if(c!=(,))
  {
    if(length(c)>1)
    {
      Msg("{yellow}Warning: Ambiguous name: {white}"+ARG+"{yellow} matches {white}"+join(forall('canonical_name(#)',c),", ")+"{white}");
      cb=select("(book_entry(card.book,#))[0]",c);
      if(length(cb)>0)
        c=cb;
    }
    return(random(c));
  }
  c=pop();
}

#
# ImportErrorAdd(msg) - Add a message msg to import.error variable.
#
def ImportErrorAdd
{
  if(import.error!="")
    import.error=import.error+"; ";
  import.error=import.error+ARG;
}

#
# ExportCards(format,list of card number) - Return a list mapped
#   through conversion table cardmap{"E"}{format}.
#
def ExportCards
{
  return(forall('cardmap{"E"}{ARG[0]}{#}',ARG[1]));
}

#
# SelectByAttr(list of card numbers, attr, search) - Return the list
#   of card numbers which have an attribute attr and it contains
#   search string.
#
def SelectByAttr
{
  return(select('find(ARG[2],Attr(ARG[1],#))!=NULL',ARG[0]));
}

#
# InverseSelectByAttr(list of card numbers, attr, search) - Return the list
#   of card numbers which do not have an attribute attr which contains
#   search string.
#
def InverseSelectByAttr
{
  return(select('find(ARG[2],Attr(ARG[1],#))==NULL',ARG[0]));
}

#
# CountNamePairs(list of card numbers) - Return the list of strings having
#   number of cards and a card name.
#
def CountNamePairs
{
  push(c);
  c=unique(sort(ARG));
  return(forall('count(#,ARG)+" "+name(#)',c));
  c=pop();
}

#
# CountCanonicalNamePairs(list of card numbers) - Return the list of strings having
#   number of cards and a card name.
#
def CountCanonicalNamePairs
{
  push(c);
  push(s);
  c=sort_by("[name]",unique(sort(ARG)),0);

  if(options.export_set)
     return(forall('s=set_of(#); if(right(canonical_name(#),length(s)+2)=="("+s+")") count(#,ARG)+" "+canonical_name(#); else count(#,ARG)+" "+canonical_name(#)+" ("+s+")"',c));
  else
     return(forall('count(#,ARG)+" "+canonical_name(#)',c));

  s=pop();
  c=pop();
}

#
# ImportGccgDeck(file content) - Gccg-format importer.
#
def ImportGccgDeck
{
  ImportReaderLineByLine(ARG,"HashComments","TrimSpaces","LineSplitFirstSpace","GccgFormatParser");
}

#
# GccgFormatParser(one or two strings) - Parse Gccg format lines.
#
def GccgFormatParser
{
  if(toint(ARG[0])==0)
    import.part=lc(join(ARG," "));
  else
  {
    push(c);
    c=images(ARG[1]);

    if(c!=(,))
      ImportAdd(toint(ARG[0]),random(c));
    else
      ImportErrorAdd("'"+ARG[0]+" "+ARG[1]+"' unknown");

    c=pop();
  }
}

#
# ExportGccgDeck(deck name,deck structure) - Convert a deck to the list of lines of the Gccg deckfile.
#
def ExportGccgDeck
{
  push(a);
  push(c);
  push(x);
  x=(
    "#",
    "# GCCG v"+VERSION+" "+GAME+" deck",
    "#",
    "#      "+ARG[0],
    "#",
  );
  for(p)(keys(ARG[1]))
  {
    x=x+(
     "",
     "#"*length(p),
     ucfirst(p),
     "#"*length(p),
    );

    a=game_option("deck order");

    for(t)(unique(sort(Attr(a,ARG[1]{p}))))
    {
      c=select("Attr(a,#)==t",ARG[1]{p});
      x=x+("","# "+t+" ("+length(c)+")","");
      x=x+CountCanonicalNamePairs(c);
    }
  }
  return(x);
  x=pop();
  c=pop();
  a=pop();
}

#
# GccgFormatSuffix() - Return filename suffix .deck for Gccg-format.
#
def GccgFormatSuffix
{
  return(".deck");
}

#
# ImportASCIIDeck(file content) - ASCII-text importer.
#
def ImportASCIIDeck
{
  ImportReaderLineByLine(ARG,"HashComments","TrimSpaces","LineSplitFirstSpace","ASCIIFormatParser");
}

#
# ASCIIFormatParser(one or two strings) - Parse ASCII format lines.
#
def ASCIIFormatParser
{
  if(length(ARG)==1)
    import.part=lc(ARG[0]);
  else
  {
    push(c);
    c=RecognizeCard(ARG[1]);
    if(c==NULL)
      ImportErrorAdd(join(ARG," "));
    else
      ImportAdd(toint(ARG[0]),c);
    c=pop();
  }
}

#
# ExportASCIIDeck(deck name,deck structure) - Convert a deck to the list of lines of the ASCII deckfile.
#
def ExportASCIIDeck
{
  push(x);
  x=(,);
  for(p)(keys(ARG[1]))
  {
    x=x+(
     "",
     ucfirst(p),
     "",
    );
    x=x+CountNamePairs(ARG[1]{p});
  }

  return(x);
  x=pop();
}

#
# ASCIIFormatSuffix() - Return filename suffix .txt for ASCII-format.
#
def ASCIIFormatSuffix
{
  return(".txt");
}

#
# ExportToFile(deck structure,name,format) - Export a deck to the file.
#
def ExportToFile
{
  push(f);
  push(g);
  push(s);
  f=tofilename(ARG[1]);
#  g=GroupOf(ARG[1]);
#  if(length(g)>0)
#    f=tofilename(g)+"/"+f;
  
  if(!isfunction(tofnc(ARG[2])+"FormatSuffix"))
    execute(tofnc(ARG[2])+".format");

  s=call(tofnc(ARG[2])+"FormatSuffix",NULL);
  if(right(f,length(s))!=s)
    f=f+s;
  f=MyPath()+"export/"+f;

  Msg("Exporting "+ARG[1]+" to "+f+".");
  write_file(f,call("Export"+tofnc(ARG[2])+"Deck",(ARG[1],ARG[0])));
  Msg("Done.");

  s=pop();
  g=pop();
  f=pop();
}

#
# PANELS AND SCREENS
# ==================

# panel_objects{panel name} - list of objects belonging to the panel.
# panel_options{panel name} - options for panel construction
# panel_structure{panel name} - construction info for the panel
# screen_panels{screen name} - list of panel names belonging to the screen
# screen - name of the current screen

#
# InitializePanelSystem() - Initialize all panel handling variables.
#   Entries for each object in panel_structure are: 
#   (type,name,variable,x,y,w,h,txtc,fgc,bgc,font,ptsz,align,valign,attrs,arg1,arg2,arg3),
#   where 
#   - type[0] is "msgbox"
#   - name[1] is object name
#   - variable[2] is the name of the variable for object number storage or NULL if none
#   - x[3],y[4],w[5],h[6] is object dimensions (first is absolute, the rest are relative to the first object)
#   - txtc[7],fgc[8],bgc[9] are text, foreground and background colors
#   - font[10],ptsz[11],align[12],valign[13] are font info and text alignment
#   - attrs[14] is a list of attributes to set
#   - arg1[15], arg2[16] and arg3[17] are object specific arguments.
#     msgbox: number of lines
#   Entries for each panel in panel_options are:
#   - none yet.
#
def InitializePanelSystem
{
  screen_panels=(,);
  panel_structure=(,);
  panel_objects=(,);
  panel_options=(,);
  panel_structure{"player info"}=(
    ("msgbox","name","name.box",0,0,w(130),h(18),
      TXCOLOR,BRCOLOR,BGCOLOR,
      0,12,1,1,
      ("highlight","fit"),
      1),
    ("msgbox","money","money.box",0,h(18)-1,w(130),h(18),
      TXCOLOR,BRCOLOR,BGCOLOR,
      0,12,1,1,
      ("highlight","fit"),
      1),
    ("msgbox","deck name","deckname.box",0,h(18)+h(18)-2,w(130),h(28),
      TXCOLOR,BRCOLOR,BGCOLOR,
      2,10,1,1,
      ("highlight",),
      2),
  );
  panel_structure{"alert"}=(
    ("msgbox","alert","alert.box",0,0,w(400),h(50),
      (255,255,255),(255,255,255),(200,0,0),
      0,20,1,1,
      ("highlight","ontop=Z_ALERT"),
      1),
  );
  panel_structure{"messages"}=(
    ("msgbox","msg","msg.box",0,0,screen.width-w(10),h(130),
      (255,255,255),(255,255,255),NULL,
      0,12,0,0,
      ("ontop=Z_LOBBYCHAT",),
      10000),
  );
  panel_structure{"input"}=(
    ("msgbox","input","input.box",0,0,screen.width,h(16),
      INCOLOR,BRCOLOR,BGCOLOR,
      0,12,0,1,
      ("highlight","ontop=Z_MBOX"),
      1),
  );
  panel_structure{"products"}=(
    ("msgbox","products","products.box",0,screen.height,w(800),h(100),
      FGCOLOR,BRCOLOR,BGCOLOR,
      0,12,0,1,
      ("highlight","clickable","draggable","ontop=Z_PRODUCTMENU"),
      1),
  );
  panel_options{"player info"}=(,);
  panel_options{"alert"}=(,);
  panel_options{"messages"}=(,);
  panel_options{"input"}=(,);
  panel_options{"products"}=(,);
}

#
# CreatePanel(name,x,y) - Construct (invisible) objects for the given panel.
#   If the panel already exists, then creation is skipped but the
#   panel is moved to the position (x,y).
#
def CreatePanel
{
  if(panel_objects{ARG[0]}==NULL)
  {
    push(root);
    push(r);
    push(o);
    push(x);
    push(y);

    root=NULL;
    panel_objects{ARG[0]}=(,);

    r=refresh(0);

    for(p)(panel_structure{ARG[0]})
    {
# Calculate postion.
      x=ARG[1]+p[3];
      y=ARG[2]+p[4];

# Create an object.
      if(p[0]=="msgbox")
        o=create_msgbox(x,y,obj=obj+1,p[1],p[5],p[6],p[15]);
      panel_objects{ARG[0]}=panel_objects{ARG[0]}+(o,);
      if(p[2]!=NULL)
        eval(p[2]+"=o");

# Set attributes.
      set_textcolor(o,p[7]);
      set_fgcolor(o,p[8]);
      set_bgcolor(o,p[9]);
      set_textfont(o,p[10]);
      set_textsize(o,p[11]);
      set_textalign(o,p[12]);
      set_textvalign(o,p[13]);

      set_attr(o,"visible",0);
      set_attr(o,"ontop",0);
      for(a)(p[14])
      {
        if(left(a,6)=="ontop=")
          set_attr(o,"ontop",toint(eval(substr(a,6))));
        else
          set_attr(o,a,1);
      }

# Attach.
      if(root==NULL)
        root=o;
      else
      {
        attach(o,root);
      }
    }

# Hide all by default
    for(o)(panel_objects{ARG[0]})
      set_attr(o,"visible",0);

    refresh(r);

    y=pop();
    x=pop();
    o=pop();
    r=pop();
    root=pop();
  }
  else
# Panel already exists. Move existing panel.
    MovePanel(ARG);
}

#
# PanelVisible(name) - Return 1 if the panel is visible.
#
def PanelVisible
{
  return(get_attr(first(panel_objects{ARG}),"visible"));
}

#
# TogglePanel(name) - Toggle visibility status of the panel.
#
def TogglePanel
{
  if(PanelVisible(ARG))
    HidePanel(ARG);
  else
    ShowPanel(ARG);
}

#
# ShowPanel(name,[state]) - Turn the panel visible or hide it if state is given and zero or NULL.
#
def ShowPanel
{
  push(r);
  r=refresh(0);
  if(length(ARG)==2)
  {
    for(o)(panel_objects{ARG[0]})
      set_attr(o,"visible",ARG[1]!=NULL && ARG[1]!=0);  
  }
  else
  {
    for(o)(panel_objects{ARG})
      set_attr(o,"visible",1);  
  }
  refresh(r);
  r=pop();
}

#
# HidePanel(name) - Turn the panel invisible.
#
def HidePanel
{
  push(r);
  r=refresh(0);
  for(o)(panel_objects{ARG})
    set_attr(o,"visible",0);
  refresh(r);
  r=pop();
}

#
# MovePanel(name,x,y) - Move panel to the specified position.
#
def MovePanel
{
  push(o);
  push(p);
  for(o)(length(panel_structure{ARG[0]}))
  {
#   Note the two different containers:
#     panel_structure contains the specifications for putting objects in a panel;
#     panel_objects contains their actual object numbers currently in use
    p=panel_structure{ARG[0]}[o];
    x=ARG[1]+p[3];
    y=ARG[2]+p[4];
    move_object(panel_objects{ARG[0]}[o],x,y);
  }
  p=pop();
  o=pop();
}

#
# CreateScreen(name,list of panels) - Connect number of
#   panels to the one screen.
#
def CreateScreen
{
  screen_panels{ARG[0]}=ARG[1];
}

#
# ShowScreen(name) - Hide previous screen (if any) and display the
#  given screen.
#
def ShowScreen
{
  push(r);
  if(ARG!=screen)
  {
    r=refresh(0);

    if(has_entry(screen,screen_panels))
    {
      for(p)(screen_panels{screen})
      {
        HidePanel(p);
      }
    }

    for(p)(screen_panels{ARG})
    {
      ShowPanel(p);
    }
    refresh(r);
    screen=ARG;
  }
  r=pop();
}

#
# UpdatePanel(panel) - Refresh a content of the panel by calling appropriate function.
#
def UpdatePanel
{
  push(v);
  push(r);
  r=refresh(0);
  v=PanelVisible(ARG);
  call("Update"+ucfirst(ARG)+"Panel",NULL);
  ShowPanel(ARG,v);
  refresh(r);
  r=pop();
  v=pop();
}

#
# UpdateProductsPanel() - Refresh content of the product panel.
#
def UpdateProductsPanel
{
  push(x);
  push(y);
  push(x0);
  push(y0);
  push(w0);
  push(w);
  push(h);

  for(p)(product.objects)
  {
    del_object(p[1]);
    panel_objects{"products"}=panel_objects{"products"}-(p[1],);
  }

  product.objects=(,);

  if(!has_entry("none",product.images))
    product.images{"none"}=load_image("unknown_booster"+IMAGE_FORMAT);

  x=w(6);
  y=h(20);
  w=w(200);
  h=h(100);
  x0=(object_data(products.box))[0];
  y0=(object_data(products.box))[1];
  w0=(object_data(products.box))[2];

  for(b)(sort_fn('age((#)[1][2][0])',products))
  {
    if(!has_entry(b[0],product.images))
    {
      if(!has_entry(b[0],product.image))
        product.images{b[0]}=load_image(b[1][2][0]+"_"+b[1][2][1]+IMAGE_FORMAT,"unknown_booster"+IMAGE_FORMAT);
      else
        product.images{b[0]}=load_image(product.image{b[0]},"unknown_booster"+IMAGE_FORMAT);
    }

    obj=obj+1;

    product.objects{b[0]}=create_image(x0+x,y0+y,obj,product.images{b[0]},b[0],1);
    panel_objects{"products"}=panel_objects{"products"}+(obj,);

    set_attr(obj,"highlight",1);
    set_attr(obj,"clickable",1);
    set_attr(obj,"ontop",Z_PRODUCTMENU+1);
    set_attr(obj,"dragparent",1);
    set_fgcolor(obj,BRCOLOR);

    set_textalign(obj,1); 
    set_textvalign(obj,2);
    add_text(obj,"{shadow}"+b[1][2][0]);
    add_text(obj,"{shadow}{sz10}"+ucfirst(b[1][2][1]));
    add_text(obj,"{shadow}$"+format("%.2f",b[1][1]));

    x=x+image_width(product.images{b[0]})+w(5);
    if(x > w)
      w=x+1;
    if(y+image_height(product.images{b[0]}) > h)
      h=y+image_height(product.images{b[0]})+h(5)+1;

    if(x > (panel_structure{"products"})[0][5])
    {
      x=w(6);
      y=y+image_height(product.images{b[0]})+w(5);
    }
  }

  del_object(products.box);
  create_msgbox(x0,y0,products.box,"products",w,h,1);
  set_attr(products.box,"highlight",1);
  set_attr(products.box,"clickable",1);
  set_attr(products.box,"draggable",1);
  set_fgcolor(products.box,BRCOLOR);
  set_bgcolor(products.box,BGCOLOR);
  set_textcolor(products.box,FGCOLOR);
  add_text(products.box,"Click to buy");
  set_textvalign(products.box,0);
  set_textalign(products.box,1);
  lower(products.box);

  for(o)(panel_objects{"products"})
  {
    if(o!=products.box)
      attach(o,products.box);
  }

  raise(products.box);

  if(y0>screen.height)
    move_object(products.box,w(141),screen.height-h-h(22));

  h=pop();
  w=pop();
  w0=pop();
  y0=pop();
  x0=pop();
  y=pop();
  x=pop();
}

#
# LOTTERY & TOURNAMENTS
# =====================

def JudgePlayCommandLottery
{
  push(u);
  push(c);
  push(i);
  push(n);

  if(length(lottery)<=0)
    lottery=(,);

  if(length(ARG)==1)
  {
     if(ARG[0]=="new")
     {
       lottery=(,);
       lottery.started=0;
       for(c)(inplay())
       {
         Send("Transfer", (1, ("table", c), ("out.of.play",)));
       }
       Send("Transfer", (length(deck(deck)), ("deck.top", deck), ("out.of.play",)));
       Send("Transfer", (length(deck(discard)), ("deck.top", discard), ("out.of.play",)));
     }
     else if(ARG[0]=="list")
     {
       for(c)(lottery)
       {
         if(c[1][1])
            Msg(c[1][1]+" x {card"+c[0]+"} for "+c[1][0]);
       }
     }
     else if(ARG[0]=="start")
     {
       lottery.started=1;
       for(c)(inplay())
       {
         i=(card_data(c))[3];
         n=lottery{i}[1];
         lottery{i}=lottery{i}+(c,);
         Send("AddMarker",(c,0,n));
       }
       Say("Lottery is STARTING NOW!");
       Send("ShuffleDeck",deck);
     }
     else if(ARG[0]=="draw")
     {
         Send("Transfer", (1, ("deck.top", deck), ("play",0)));
     }
     else if(ARG[0]=="end")
     {
       lottery.started=0;
       Say("Lottery is FINISHED!");
     }
  }
  else if(length(ARG)>=4)
  {
     if(ARG[0]=="put")
     {
       u=ARG[1];
       n=toint(ARG[2]);
       c=join(tail(tail(tail(ARG)))," ");
       if(left(c,1)=="'")
         c=substr(c,1);
       if(right(c,1)=="'")
         c=substr(c,0,length(c)-1);

       i=images(c);
       if(length(i)==0)
          i=fuzzy_images(c);

       if(length(i)==0)
         Msg("{red}Card '"+c+"' not found.");
       else
       {
         i=random(i);
         Say("Using card {orange}"+c+"{yellow} for {orange}"+u);
         Send("Transfer", (1, ("out.of.play", i), ("play", 0)));
         Send("Transfer", (n, ("out.of.play", i), ("deck.top", deck)));
         lottery{i}=(u,n);
       }
     }
  }
  else
  {
    Msg("usage: /lottery put {yellow}<user> <num> <card>");
    Msg("              /lottery draw");
    Msg("              /lottery list");
    Msg("              /lottery start");
    Msg("              /lottery new");
    Msg("              /lottery end");
  }

  n=pop();
  i=pop();
  c=pop();
  u=pop();
}

#
# Giveteam(user) - Give card to sealed team member.
#
def Giveteam
{
  if(Mode()!="sealed")
    Msg("{red}This works only in sealed mode.");
  if(card.number)
  {
    if(mode!="chat")
      Say("{cyan}Giving "+card.name+" ...");
    net_send(server.meta,("GiveCard",(ARG,card.number)));
  }
}

#
# SOUNDS
# ======

#
# PlaySound() - Play a sound if enabled.
#
def PlaySound
{
	if(options{"nosound"}!="yes" && options{"nosound"}!="on")
	{
		if(typeof(ARG)=="integer")
		{
			play_sound(ARG);
		}
		elseif(typeof(ARG)=="string")
		{
			if(ARG=="coin")
				play_sound(sounds.flip_coin);
			elseif(ARG=="dice")
				play_sound(sounds.roll_dice);
			elseif(ARG=="shuffle")
				play_sound(sounds.shuffle);
			elseif(ARG=="notify")
				play_sound(sounds.notify);
		}
	}
}

#
# PlayCardSound(card number, real card number) - call appropriate functions to play a card sound.
#
def PlayCardSound
{
  push(s);
  push(found);
  
  found=0;

  s=card_sound(ARG[0]);
  if(s!=NULL && s>=0)
    PlaySound(card_sound(ARG[0]));
  else
  {
    if(isfunction("PlaySound"+tofnc(name(ARG[0]))))
      call("PlaySound"+tofnc(name(ARG[0])),ARG);
    else
    {
      for(a)(game.data{"play"})
      {
        s=card_attr(a,ARG[0]);
        if(s!=NULL && s!="" && isfunction("PlaySound"+tofnc(s)))
	{
          call("PlaySound"+tofnc(s),ARG);
		  found=1;
	}
      }
	  
      if(!found)
	    PlaySound(sounds.card_drop);
    }
  }
  
  found=pop();
  s=pop();
}

#
# PLAYBACK
# ========

# Testing for game log playback.
# UNFINISHED: needs better delay control and keyboard polling
#
def PlayLog
{
  push(l);
  push(e);
  push(c);
  push(s);
  push(i);
  push(mx);
  push(pause);

  if(options{"speed"})
    s=toint(options{"speed"});
  else
    s=200;

  l=logs{ARG};
  SetMode('playback');
  mx=length(l);
  i=0;
  pause=0;
  while(i<mx)
  {
    e=l[i];

    if(!pause && e[0]!="StartGame" && e[0]!="EndGame")
       call(function{e[0]},e[1]);

    if(i%10==0)
    {
      Timer();
      MainLoop();
    }

    c=get_command(s);
    if(c[0]=="key")
    {
      if(c[1]=="escape")
        i=mx;
      else if(c[1]=="space")
      {
        pause=!pause;
        if(pause)
          Msg("Pause on!");
        else
          Msg("Pause off!");
      }
      else if(c[1]=="right")
      {
        s=s-50;
        if(s<0)
           s=0;
        Msg("Speed "+s+"!");
      }
      else if(c[1]=="left")
      {
        s=s+50;
        Msg("Speed "+s+"!");
      }
      else
      {
        d(c);
      }
    }

    if(!pause)
       i=i+1;
  }
  SetMode('chat');

  pause=pop();
  mx=pop();
  i=pop();
  s=pop();
  c=pop();
  e=pop();
  l=pop();
}

#
# StartPlaybackMode() - Initialization of the playback mode.
#
def StartPlaybackMode
{
  deck_content=(,);
  ShowPlaymat();
  raise(chat_msg.box);
  MsgChat(" ");
  MsgChat("{hr}");
  MsgChat("Playback");
  MsgChat(" ");
}

#
# LeavePlaybackMode() - Cleaning operations when leaving playback mode.
#
def LeavePlaybackMode
{
  del_object(select("#>=10000",objects()));
  HidePlaymat();
}

#
# CommandLog() - Set logging on/off.
#
def CommandLog
{
  if(length(ARG)==0)
  {
    if(length(logs)==0)
      Msg("No logs available");
    else
      Msg("Logs made: "+join(keys(logs),", "));
  }
  else if(ARG==("off",))
  {
    if(!flag.logging)
      Msg("{red}Logging is not ON.");
    else
    {
      Msg("Logging OFF. Log '"+log.name+"' saved.");
      flag.logging=0;
      save("logs");
    }
  }
  else
  {
    if(flag.logging)
      CommandLog(,);
    push(l);
    l=join(ARG," ");
    log.name=l;
    flag.logging=1;
    logs{l}=(,);
    Msg("Logging ON: '"+l+"'.");
    l=pop();
  }
}

#
# CommandPlay() - Play a log file.
#
def CommandPlay
{
  push(l);

  l=join(ARG," ");
  if(!has_entry(l,logs))
    Msg("{red}No such log.");
  else
    PlayLog(l);

  l=pop();
}

#
# InitVisualAlert() - Trigger visual notification timer.
#
def InitVisualAlert
{
  if(screen.has_focus==0 && screen.alert_enabled==0 && options{"noalert"}!="yes" && options{"noalert"}!="on")
  {
	screen.alert_enabled=1;
	VisualAlertTimer(1);
  }
}

#
# VisualAlertTimer() - Visual notification timer function.
#
def VisualAlertTimer
{
  if(screen.alert_enabled==1)
  {
	  blink(ARG);
	  AddTimer(1,'VisualAlertTimer('+tostr(!ARG)+')');
  }
  else
    blink(0);
}
